<!DOCTYPE html>
<html>

<head>
    <title>WebGL Particle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
        }

        label {
            display: block;
            margin: 10px 0;
        }

        input,
        select {
            margin-left: 10px;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 3px;
        }

        button {
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }
    </style>
</head>

<body>
    <div id="menu"
        style="position: fixed; width: 100vw; height: 100vh; background: rgba(0,0,0,0.9); color: white; padding: 20px; font-family: Arial; z-index: 1000;">
        <h2>Particle Timer Settings</h2>

        <div class="section">
            <h3>Timer Settings</h3>
            <label>Minutes: <input type="number" id="minutes" min="0" value="1"></label>
            <label>Seconds: <input type="number" id="seconds" min="0" max="59" value="0"></label>
        </div>

        <div class="section">
            <h3>Particle Style</h3>
            <select id="presetStyle">
                <option value="minimal">Minimal</option>
                <option value="neon">Neon</option>
                <option value="glitch">Glitch</option>
            </select>
        </div>

        <div class="section">
            <h3>Custom Settings</h3>
            <label>Text Size: <input type="range" id="textSize" min="100" max="400" value="240"></label>
            <label>Particle Size: <input type="range" id="particleSize" min="1" max="20" value="4"></label>
            <label>Particle Count: <input type="range" id="particleDensity" min="1" max="5" value="2"></label>
            <label>Orbit Radius: <input type="range" id="radius" min="0.5" max="3" step="0.1" value="1.5"></label>
        </div>

        <button id="startTimer" style="padding: 10px 20px; margin-top: 20px;">Start Timer</button>
    </div>

    <canvas id="glCanvas"></canvas>

    <script type="x-shader/x-vertex" id="vertex-shader">
        attribute vec2 a_position;
        attribute vec3 a_color;
        attribute float a_size;
        varying vec3 v_color;

        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            gl_PointSize = a_size;
            v_color = a_color;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragment-shader">
        precision mediump float;
        varying vec3 v_color;

        void main() {
            vec2 center = gl_PointCoord - vec2(0.5);
            float dist = length(center);
            float alpha = 1.0 - smoothstep(0.1, 0.15, dist);
            gl_FragColor = vec4(v_color, alpha);
        }
    </script>

    <script>
        class ParticleConfig {
            constructor(config) {
                this.particles = {
                    position: {
                        min: config.positionMin,
                        spread: config.positionSpread
                    },
                    physics: {
                        acceleration: {
                            base: config.accelerationBase,
                            variation: config.accelerationVariation
                        },
                        damping: {
                            base: config.dampingBase,
                            variation: config.dampingVariation
                        }
                    },
                    appearance: {
                        size: {
                            base: config.sizeBase,
                            variation: config.sizeVariation
                        },
                        colors: config.colors
                    }
                };

                this.text = {
                    size: config.textSize,
                    scale: config.textScale,
                    density: config.textDensity
                };

                this.behavior = {
                    verticallyOrderedParticles: config.verticallyOrderedParticles,
                    radius: config.radius,
                    extraParticleMode: config.extraParticleMode
                };
            }
        }

        const PRESETS = {
            glitch: new ParticleConfig({
                positionMin: -0.9,
                positionSpread: 1.8,
                accelerationBase: 10,
                accelerationVariation: 0.0,
                dampingBase: 0.90,
                dampingVariation: 0.0,
                sizeBase: 3,
                sizeVariation: 0.0,
                colors: [
                    [0.95, 0.61, 0.73],
                    [0.56, 0.93, 0.56],
                    [0.68, 0.85, 0.90],
                    [0.97, 0.85, 0.45],
                    [0.85, 0.75, 0.95]
                ],
                textSize: 240,
                textScale: 1,
                textDensity: 1,
                verticallyOrderedParticles: false,
                extraParticleMode: "center",
                radius: 1.5
            }),

            neon: new ParticleConfig({
                positionMin: -0.9,
                positionSpread: 1.8,
                accelerationBase: 5,
                accelerationVariation: 5.0,
                dampingBase: 0.99,
                dampingVariation: 0.005,
                sizeBase: 4,
                sizeVariation: 2.0,
                colors: [
                    [1.0, 0.0, 1.0],
                    [0.0, 1.0, 1.0],
                    [1.0, 1.0, 0.0]
                ],
                textSize: 280,
                textScale: 1,
                textDensity: 2,
                verticallyOrderedParticles: true,
                extraParticleMode: "center",
                radius: 2
            }),

            minimal: new ParticleConfig({
                positionMin: -0.7,
                positionSpread: 1.2,
                accelerationBase: 3,
                accelerationVariation: 3,
                dampingBase: 0.95,
                dampingVariation: 0.04,
                sizeBase: 15,
                sizeVariation: 75,
                colors: [[1.0, 1.0, 1.0]],
                textSize: 30,
                textScale: 0.4,
                textDensity: 100,
                verticallyOrderedParticles: true,
                extraParticleMode: "circle",
                radius: 0.5
            })
        };

        let CONFIG = PRESETS.minimal;
        console.log(CONFIG);

        const canvas = document.getElementById('glCanvas');

        const stats = document.createElement('div');
        stats.style.position = 'fixed';
        stats.style.top = '10px';
        stats.style.left = '10px';
        stats.style.color = 'white';
        stats.style.fontFamily = 'monospace';
        stats.style.fontSize = '16px';
        stats.style.zIndex = '100';
        document.body.appendChild(stats);

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let timerRunning = false;

        const gl = canvas.getContext('webgl');
        gl.viewport(0, 0, canvas.width, canvas.height);

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

        let activePointsCount = 0;

        gl.shaderSource(vertexShader, document.getElementById('vertex-shader').textContent);
        gl.shaderSource(fragmentShader, document.getElementById('fragment-shader').textContent);
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const maxPoints = Math.max(
            getTextPoints("0:00", 1, false).realPointsLength,
            getTextPoints("8:88", 1, false).realPointsLength,
            getTextPoints("END", 1, false).realPointsLength
        );


        numParticles = maxPoints;
        particleArrays = createParticleArrays(numParticles);
        initializeParticles(particleArrays, 0, numParticles);
        console.log(particleArrays);
        function createParticleArrays(count) {
            return {
                positions: new Float32Array(count * 2),
                velocities: new Float32Array(count * 2),
                setPoints: new Float32Array(count * 2),
                accelerations: new Float32Array(count),
                dampings: new Float32Array(count),
                particleSizes: new Float32Array(count),
                particleColors: new Float32Array(count * 3)
            };
        }


        function initializeParticles(particleArrays, startIndex, endIndex) {
            for (let i = startIndex; i < endIndex; i++) {
                particleArrays.positions[i * 2] = Math.random() * CONFIG.particles.position.spread + CONFIG.particles.position.min;
                particleArrays.positions[i * 2 + 1] = Math.random() * CONFIG.particles.position.spread + CONFIG.particles.position.min;
                particleArrays.velocities[i * 2] = 0;
                particleArrays.velocities[i * 2 + 1] = 0;
                particleArrays.setPoints[i * 2] = 0;
                particleArrays.setPoints[i * 2 + 1] = 0;
                particleArrays.accelerations[i] = Math.max(CONFIG.particles.physics.acceleration.base + Math.random() * CONFIG.particles.physics.acceleration.variation, 0.0001);
                particleArrays.dampings[i] = Math.min(CONFIG.particles.physics.damping.base + Math.random() * CONFIG.particles.physics.damping.variation, 0.9999);
                particleArrays.particleSizes[i] = CONFIG.particles.appearance.size.base + Math.random() * CONFIG.particles.appearance.size.variation;

                const randomColor = CONFIG.particles.appearance.colors[Math.floor(Math.random() * CONFIG.particles.appearance.colors.length)];
                particleArrays.particleColors[i * 3] = randomColor[0];
                particleArrays.particleColors[i * 3 + 1] = randomColor[1];
                particleArrays.particleColors[i * 3 + 2] = randomColor[2];
            }
        }




        const positionBuffer = gl.createBuffer();
        const sizeBuffer = gl.createBuffer();
        const colorBuffer = gl.createBuffer();

        function updateBuffers(arrays) {
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.positions, gl.DYNAMIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.particleSizes, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.particleColors, gl.STATIC_DRAW);
        }

        updateBuffers(particleArrays);

        const positionAttribLocation = gl.getAttribLocation(program, 'a_position');
        const sizeAttribLocation = gl.getAttribLocation(program, 'a_size');
        const colorAttribLocation = gl.getAttribLocation(program, 'a_color');

        gl.enableVertexAttribArray(positionAttribLocation);
        gl.enableVertexAttribArray(sizeAttribLocation);
        gl.enableVertexAttribArray(colorAttribLocation);

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionAttribLocation, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
        gl.vertexAttribPointer(sizeAttribLocation, 1, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.vertexAttribPointer(colorAttribLocation, 3, gl.FLOAT, false, 0, 0);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;
        let fps = 0;
        function draw(currentTime) {
            if (!timerRunning) return;

            currentTime *= 0.001;
            let deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            if (deltaTime > 0.1) {
                deltaTime = 0.0;
            }

            const {
                positions,
                velocities,
                setPoints,
                accelerations,
                dampings
            } = particleArrays;

            const renderCount = CONFIG.behavior.extraParticleMode === 'circle' ? numParticles : activePointsCount;

            const dampingRate = (deltaTime) ** 2;

            for (let i = 0; i < renderCount; i++) {
                const dx = setPoints[i * 2] - positions[i * 2];
                const dy = setPoints[i * 2 + 1] - positions[i * 2 + 1];

                velocities[i * 2] = (velocities[i * 2] * dampings[i] * dampingRate) + (dx * accelerations[i]);
                velocities[i * 2 + 1] = (velocities[i * 2 + 1] * dampings[i] * dampingRate) + (dy * accelerations[i]);


                positions[i * 2] += velocities[i * 2] * (deltaTime);
                positions[i * 2 + 1] += velocities[i * 2 + 1] * (deltaTime);
            }

            frameCount++;
            if (currentTime - lastFpsTime >= 1.0) {
                fps = frameCount;
                frameCount = 0;
                lastFpsTime = currentTime;

                stats.textContent = `
                    FPS: ${fps}
                    Particles: ${numParticles}
                    Delta: ${deltaTime.toFixed(4)}ms
                `;
            }

            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.POINTS, 0, renderCount);

            if (true) {
                requestAnimationFrame(draw);
            }
            else {
                setTimeout(() => {
                    requestAnimationFrame(draw);
                }, 1);
            }
        }

        function getTextPoints(text, density, addExtraPoints = true) {
            const textSize = CONFIG.text.size;
            const textScale = CONFIG.text.scale;

            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');

            ctx.font = `bold ${textSize}px Arial`;
            const metrics = ctx.measureText(text);

            tempCanvas.width = metrics.width;
            tempCanvas.height = textSize;

            ctx.font = `bold ${textSize}px Arial`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            ctx.fillText(text, tempCanvas.width / 2, textSize / 2);

            const points = [];
            const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;

            // Scan for text points based on vertical ordering preference
            console.log(CONFIG.behavior.verticallyOrderedParticles);
            if (CONFIG.behavior.verticallyOrderedParticles) {
                for (let x = 0; x < tempCanvas.width; x += density) {
                    for (let y = 0; y < tempCanvas.height; y += density) {
                        const alpha = imageData[(y * tempCanvas.width + x) * 4 + 3];
                        if (alpha > 128) {
                            points.push({
                                x: ((x / tempCanvas.width) * 2 - 1) * textScale,
                                y: (-(y / tempCanvas.height) * 2 + 1) * textScale
                            });
                        }
                    }
                }
            } else {
                for (let y = 0; y < tempCanvas.height; y += density) {
                    for (let x = 0; x < tempCanvas.width; x += density) {
                        const alpha = imageData[(y * tempCanvas.width + x) * 4 + 3];
                        if (alpha > 128) {
                            points.push({
                                x: ((x / tempCanvas.width) * 2 - 1) * textScale,
                                y: (-(y / tempCanvas.height) * 2 + 1) * textScale
                            });
                        }
                    }
                }
            }

            const realPointsLength = points.length;

            if (addExtraPoints) {
                const remainingPoints = numParticles - points.length;

                switch (CONFIG.behavior.extraParticleMode) {
                    case 'circle':
                        const radius = CONFIG.behavior.radius;
                        const aspectRatio = canvas.width / canvas.height;
                        for (let i = 0; i < remainingPoints; i++) {
                            const angle = i * (2 * Math.PI / remainingPoints);
                            points.push({
                                x: Math.cos(angle) * radius,
                                y: Math.sin(angle) * radius * aspectRatio
                            });
                        }
                        break;

                    case 'center':
                        for (let i = 0; i < remainingPoints; i++) {
                            points.push({ x: 0, y: 0 });
                        }
                        break;

                    case 'maintain':
                        for (let i = 0; i < remainingPoints; i++) {
                            points.push({
                                x: particleArrays.positions[(points.length + i) * 2],
                                y: particleArrays.positions[(points.length + i) * 2 + 1]
                            });
                        }
                        break;
                }
            }

            return { realPointsLength, points };
        }




        let timeTxt = "";
        let endTime = (+new Date) + (60 * 1000);
        let msLeft = 0;

        function updateTimer() {
            const {
                positions,
                velocities,
                setPoints,
                accelerations,
                dampings
            } = particleArrays;

            msLeft = endTime - (+new Date);

            if (msLeft < 1000) {
                timeTxt = "END";
            } else {
                const time = new Date(msLeft);
                const mins = time.getUTCMinutes();
                timeTxt = mins + ':' + twoDigits(time.getUTCSeconds());
                setTimeout(updateTimer, 1000);
            }

            const { realPointsLength, points } = getTextPoints(timeTxt, 1, true);
            activePointsCount = realPointsLength;

            for (let i = 0; i < numParticles; i++) {
                setPoints[i * 2] = points[i].x;
                setPoints[i * 2 + 1] = points[i].y;
            }
        }

        function twoDigits(n) {
            return (n < 10 ? '0' : '') + n;
        }

        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            document.getElementById('menu').style.display = 'block';
        });

        document.getElementById('startTimer').addEventListener('click', () => {
            const minutes = parseInt(document.getElementById('minutes').value);
            const seconds = parseInt(document.getElementById('seconds').value);
            // const style = document.getElementById('presetStyle').value;

            // Object.assign(CONFIG, PRESETS[style]);

            // CONFIG.text.size = parseInt(document.getElementById('textSize').value);
            // CONFIG.particles.appearance.size.base = parseInt(document.getElementById('particleSize').value);
            // CONFIG.text.density = parseInt(document.getElementById('particleDensity').value);
            // CONFIG.behavior.radius = parseFloat(document.getElementById('radius').value);

            endTime = (+new Date) + ((minutes * 60 + seconds) * 1000);
            document.getElementById('menu').style.display = 'none';

            timerRunning = true;
            updateTimer();
            requestAnimationFrame(draw);
        });
    </script>
</body>

</html>