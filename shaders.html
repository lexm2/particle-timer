<!DOCTYPE html>
<html>

<head>
    <title>WebGL Particle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
        }

        label {
            display: block;
            margin: 10px 0;
        }

        input,
        select {
            margin-left: 10px;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 3px;
        }

        button {
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }
    </style>
</head>

<body>
    <div id="menu"
        style="position: fixed; width: 100vw; height: 100vh; background: rgba(0,0,0,0.9); color: white; padding: 20px 20px 80px 20px; font-family: Arial; z-index: 1000; overflow-y: auto; overflow-x: hidden;">

        <h2>Particle Timer Settings</h2>

        <button id="startTimer" style="padding: 10px 20px; margin-top: 20px; ">Start Timer</button>

        <div class="section">
            <h3>Timer Settings</h3>
            <label>Minutes: <input type="number" id="minutes" min="0" value="1"></label>
            <label>Seconds: <input type="number" id="seconds" min="0" max="59" value="0"></label>
            <div style="margin-top: 10px;">
                <button style="padding: 10px 20px;"
                    onclick="document.getElementById('minutes').value=5;document.getElementById('seconds').value=0">5
                    min</button>
                <button style="padding: 10px 20px; "
                    onclick="document.getElementById('minutes').value=10;document.getElementById('seconds').value=0">10
                    min</button>
                <button style="padding: 10px 20px; "
                    onclick="document.getElementById('minutes').value=20;document.getElementById('seconds').value=0">20
                    min</button>
            </div>
        </div>

        <div class="section">
            <h3>Particle Style</h3>
            <select id="presetStyle">
                <option value="minimal">Minimal</option>
                <option value="neon">Neon</option>
                <option value="glitch">Glitch</option>
                <option value="offScreenCircle">Off Screen Circle</option>
            </select>
        </div>

        <div class="section">
            <h3>Basic Settings</h3>
            <label>Text Scale: <input type="number" id="textScale" min="0.1" max="2" step="0.1" value="1"></label>
            <label>Particle Size: <input type="number" id="particleSize" min="1" max="20" value="4"></label>
        </div>

        <div class="section">
            <h3>Colors</h3>
            <div id="colorPickers">
                <input type="color" class="particleColor" value="#ffffff">
                <button id="addColor">Add Color</button>
                <button id="removeColor">Remove Color</button>
            </div>
        </div>

        <div class="section">
            <h3>Advanced Options</h3>
            <button id="toggleAdvanced" style="margin-bottom: 10px;">Show Advanced Options</button>
            <div id="advancedOptions" style="display: none;">
                <label>Text Resolution: <input type="number" id="textSize" min="100" max="400" value="240"></label>
                <label>Size Variation: <input type="number" id="sizeVariation" min="0" max="75" value="2"></label>
                <label>Particle Sepearation: <input type="number" id="particleDensity" min="1" max="5"
                        value="2"></label>
                <label>Orbit Radius: <input type="number" id="radius" min="0.5" max="3" step="0.1" value="1.5"></label>
                <h4>Particle Ordering</h4>
                <select id="particleOrdering">
                    <option value="vertical">Vertical</option>
                    <option value="horizontal">Horizontal</option>
                    <option value="optimized">Optimized</option>
                </select>
                <h4>Particle Physics</h4>
                <label>Position Min: <input type="number" id="positionMin" min="-2" max="0" step="0.1"
                        value="-0.9"></label>
                <label>Position Spread: <input type="number" id="positionSpread" min="0" max="3" step="0.1"
                        value="1.8"></label>
                <label>Acceleration Base: <input type="number" id="accelerationBase" min="0" max="20" step="0.5"
                        value="5"></label>
                <label>Acceleration Variation: <input type="number" id="accelerationVar" min="0" max="10" step="0.5"
                        value="5"></label>

                <h4>Particle Behavior</h4>
                <label>Damping Base: <input type="number" id="dampingBase" min="0.8" max="0.999" step="0.001"
                        value="0.99"></label>
                <label>Damping Variation: <input type="number" id="dampingVar" min="0" max="0.1" step="0.001"
                        value="0.005"></label>

                <h4>Extra Particle Mode</h4>
                <select id="extraParticleMode">
                    <option value="circle">Circle</option>
                    <option value="center">Center</option>
                    <option value="maintain">Maintain</option>
                    <option value="spiral">Spiral</option>
                    <option value="wave">Wave</option>
                    <option value="fountain">Fountain</option>
                    <option value="test">Test</option>
                </select>
            </div>
        </div>

        <div class="section">
            <h3>Save Configuration</h3>
            <label>Configuration Name: <input type="text" id="configName"></label>
            <button id="saveConfig">Save</button>
        </div>
        <div style="padding-bottom: 60px;"></div>
    </div>
    <canvas id="glCanvas"></canvas>
    <audio id="tickSound" src="https://assets.mixkit.co/active_storage/sfx/2568/2568.wav"></audio>
    <audio id="timerComplete" src="https://assets.mixkit.co/active_storage/sfx/2865/2865.wav"></audio>
    <script type="x-shader/x-vertex" id="vertex-shader">
        attribute vec2 a_position;
        attribute vec3 a_color;
        attribute float a_size;
        varying vec3 v_color;

        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            gl_PointSize = a_size;
            v_color = a_color;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragment-shader">
        precision mediump float;
        varying vec3 v_color;

        void main() {
            vec2 center = gl_PointCoord - vec2(0.5);
            float dist = length(center);
            float alpha = 1.0 - smoothstep(0.1, 0.15, dist);
            gl_FragColor = vec4(v_color, alpha);
        }
    </script>
    <script>
        class ParticleConfig {
            constructor(config) {
                if (config) {
                    this.particles = {
                        position: {
                            min: config.positionMin,
                            spread: config.positionSpread
                        },
                        physics: {
                            acceleration: {
                                base: config.accelerationBase,
                                variation: config.accelerationVariation
                            },
                            damping: {
                                base: config.dampingBase,
                                variation: config.dampingVariation
                            }
                        },
                        appearance: {
                            size: {
                                base: config.sizeBase,
                                variation: config.sizeVariation
                            },
                            colors: config.colors
                        }
                    };

                    this.text = {
                        size: config.textSize,
                        scale: config.textScale,
                        density: config.textDensity
                    };

                    this.behavior = {
                        ordering: config.ordering,
                        radius: config.radius,
                        extraParticleMode: config.extraParticleMode
                    };
                }
            }
        }

        function getConfigFromInputs() {
            return new ParticleConfig({
                positionMin: parseFloat(document.getElementById('positionMin').value),
                positionSpread: parseFloat(document.getElementById('positionSpread').value),
                accelerationBase: parseFloat(document.getElementById('accelerationBase').value),
                accelerationVariation: parseFloat(document.getElementById('accelerationVar').value),
                dampingBase: parseFloat(document.getElementById('dampingBase').value),
                dampingVariation: parseFloat(document.getElementById('dampingVar').value),
                sizeBase: parseFloat(document.getElementById('particleSize').value),
                sizeVariation: parseFloat(document.getElementById('sizeVariation').value),
                textSize: parseFloat(document.getElementById('textSize').value),
                textScale: parseFloat(document.getElementById('textScale').value),
                textDensity: parseFloat(document.getElementById('particleDensity').value),
                ordering: document.getElementById('particleOrdering').value,
                extraParticleMode: document.getElementById('extraParticleMode').value,
                radius: parseFloat(document.getElementById('radius').value),
                colors: Array.from(document.querySelectorAll('.particleColor')).map(cp => {
                    const hex = cp.value;
                    return [
                        parseInt(hex.slice(1, 3), 16) / 255,
                        parseInt(hex.slice(3, 5), 16) / 255,
                        parseInt(hex.slice(5, 7), 16) / 255
                    ];
                })
            });
        }


        const PRESETS = {
            minimal: new ParticleConfig({
                positionMin: -0.7,
                positionSpread: 1.2,
                accelerationBase: 3,
                accelerationVariation: 3,
                dampingBase: 0.95,
                dampingVariation: 0.04,
                sizeBase: 15,
                sizeVariation: 75,
                colors: [
                    [0.29, 0.31, 0.30], // #4a4e4d
                    [0.05, 0.60, 0.65], // #0e9aa7
                    [0.24, 0.64, 0.67], // #3da4ab
                    [0.96, 0.80, 0.38], // #f6cd61
                    [0.99, 0.54, 0.44]  // #fe8a71
                ],
                textSize: 30,
                textScale: 0.6,
                textDensity: 1,
                ordering: "vertical",
                extraParticleMode: "circle",
                radius: 0.8
            }),

            glitch: new ParticleConfig({
                positionMin: -0.9,
                positionSpread: 1.8,
                accelerationBase: 10,
                accelerationVariation: 0.0,
                dampingBase: 0.90,
                dampingVariation: 0.0,
                sizeBase: 3,
                sizeVariation: 0.0,
                colors: [
                    [0.95, 0.61, 0.73],
                    [0.56, 0.93, 0.56],
                    [0.68, 0.85, 0.90],
                    [0.97, 0.85, 0.45],
                    [0.85, 0.75, 0.95]
                ],
                textSize: 240,
                textScale: 1,
                textDensity: 1,
                ordering: "horizontal",
                extraParticleMode: "center",
                radius: 1.5
            }),

            neon: new ParticleConfig({
                positionMin: -0.9,
                positionSpread: 1.8,
                accelerationBase: 5,
                accelerationVariation: 5.0,
                dampingBase: 0.99,
                dampingVariation: 0.005,
                sizeBase: 4,
                sizeVariation: 2.0,
                colors: [
                    [1.0, 0.0, 1.0],
                    [0.0, 1.0, 1.0],
                    [1.0, 1.0, 0.0]
                ],
                textSize: 280,
                textScale: 1,
                textDensity: 2,
                ordering: "vertical",
                extraParticleMode: "maintain",
                radius: 2
            }),
        };

        let CONFIG = new ParticleConfig();

        const canvas = document.getElementById('glCanvas');

        let mouseX = 0;
        let mouseY = 0;
        let mouseVelocityX = 0;
        let mouseVelocityY = 0;
        let mouseClicked = false;
        let mouseDown = false;

        const rect = canvas.getBoundingClientRect();

        canvas.addEventListener('mousedown', () => {
            mouseDown = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const newMouseX = (e.clientX - rect.left) / rect.width * 2 - 1;
            const newMouseY = -((e.clientY - rect.top) / rect.height * 2 - 1);

            if (mouseDown) {
                mouseVelocityX = newMouseX - mouseX;
                mouseVelocityY = newMouseY - mouseY;
            }

            mouseX = newMouseX;
            mouseY = newMouseY;
        });

        canvas.addEventListener('click', () => {
            mouseClicked = true;
        });

        const stats = document.createElement('div');
        stats.style.position = 'fixed';
        stats.style.top = '10px';
        stats.style.left = '10px';
        stats.style.color = 'white';
        stats.style.fontFamily = 'monospace';
        stats.style.fontSize = '16px';
        stats.style.zIndex = '100';
        document.body.appendChild(stats);

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);


        let timerRunning = false;

        const gl = canvas.getContext('webgl');
        gl.viewport(0, 0, canvas.width, canvas.height);

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

        let activePointsCount = 0;
        let previousPoints = new Map();
        let particleArrays;
        let externalForces;

        gl.shaderSource(vertexShader, document.getElementById('vertex-shader').textContent);
        gl.shaderSource(fragmentShader, document.getElementById('fragment-shader').textContent);
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        function createParticleArrays(count) {
            return {
                positions: new Float32Array(count * 2),
                velocities: new Float32Array(count * 2),
                setPoints: new Float32Array(count * 2),
                accelerations: new Float32Array(count),
                dampings: new Float32Array(count),
                particleSizes: new Float32Array(count),
                particleColors: new Float32Array(count * 3)
            };
        }


        function initializeParticles(particleArrays, startIndex, endIndex) {
            for (let i = startIndex; i < endIndex; i++) {
                particleArrays.positions[i * 2] = Math.random() * CONFIG.particles.position.spread + CONFIG.particles.position.min;
                particleArrays.positions[i * 2 + 1] = Math.random() * CONFIG.particles.position.spread + CONFIG.particles.position.min;
                particleArrays.velocities[i * 2] = 0;
                particleArrays.velocities[i * 2 + 1] = 0;
                particleArrays.setPoints[i * 2] = 0;
                particleArrays.setPoints[i * 2 + 1] = 0;
                particleArrays.accelerations[i] = Math.max(CONFIG.particles.physics.acceleration.base + Math.random() * CONFIG.particles.physics.acceleration.variation, 0.0001);
                particleArrays.dampings[i] = Math.min(CONFIG.particles.physics.damping.base + Math.random() * CONFIG.particles.physics.damping.variation, 0.9999);
                particleArrays.particleSizes[i] = CONFIG.particles.appearance.size.base + Math.random() * CONFIG.particles.appearance.size.variation;

                const randomColor = CONFIG.particles.appearance.colors[Math.floor(Math.random() * CONFIG.particles.appearance.colors.length)];
                particleArrays.particleColors[i * 3] = randomColor[0];
                particleArrays.particleColors[i * 3 + 1] = randomColor[1];
                particleArrays.particleColors[i * 3 + 2] = randomColor[2];
            }
        }




        const positionBuffer = gl.createBuffer();
        const sizeBuffer = gl.createBuffer();
        const colorBuffer = gl.createBuffer();

        function updateBuffers(arrays) {
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.positions, gl.DYNAMIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.particleSizes, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.particleColors, gl.STATIC_DRAW);
        }

        const positionAttribLocation = gl.getAttribLocation(program, 'a_position');
        const sizeAttribLocation = gl.getAttribLocation(program, 'a_size');
        const colorAttribLocation = gl.getAttribLocation(program, 'a_color');

        gl.enableVertexAttribArray(positionAttribLocation);
        gl.enableVertexAttribArray(sizeAttribLocation);
        gl.enableVertexAttribArray(colorAttribLocation);

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionAttribLocation, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
        gl.vertexAttribPointer(sizeAttribLocation, 1, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.vertexAttribPointer(colorAttribLocation, 3, gl.FLOAT, false, 0, 0);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;
        let fps = 0;
        function draw(currentTime) {
            if (!timerRunning) return;

            currentTime *= 0.001;
            let deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            if (deltaTime > 0.1) {
                deltaTime = 0.0;
            }

            const {
                positions,
                velocities,
                setPoints,
                accelerations,
                dampings
            } = particleArrays;

            const renderCount = PARTICLE_MODES[CONFIG.behavior.extraParticleMode]?.renderExtras
                ? numParticles
                : activePointsCount;

            const dampingRate = (deltaTime) ** 2;

            //Explosions
            if (mouseClicked) {
                const pushForce = 200;
                const pushRadius = 100; // In pixels

                const mousePixelX = mouseX * canvas.width / 2;
                const mousePixelY = mouseY * canvas.height / 2;

                for (let i = 0; i < renderCount; i++) {
                    const particleX = setPoints[i * 2] * canvas.width / 2;
                    const particleY = setPoints[i * 2 + 1] * canvas.height / 2;

                    const dx = particleX - mousePixelX;
                    const dy = particleY - mousePixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius) {
                        const force = (1 - distance / pushRadius) * pushForce;
                        const normalizedDx = dx / canvas.width;
                        const normalizedDy = dy / canvas.height;
                        externalForces[i * 2] = normalizedDx * force;
                        externalForces[i * 2 + 1] = -normalizedDy * force;
                    }
                }
                mouseClicked = false;
            } else if (mouseDown) {
                const mouseSpeed = Math.sqrt(mouseVelocityX * mouseVelocityX + mouseVelocityY * mouseVelocityY);
                const pushForce = 2000 * (1 + mouseSpeed * 20); // Much stronger base force
                const pushRadius = 200 * (1 + mouseSpeed * 5); // Larger radius of effect

                const mousePixelX = mouseX * canvas.width / 2;
                const mousePixelY = mouseY * canvas.height / 2;

                for (let i = 0; i < renderCount; i++) {
                    const particleX = setPoints[i * 2] * canvas.width / 2;
                    const particleY = setPoints[i * 2 + 1] * canvas.height / 2;

                    const dx = particleX - mousePixelX;
                    const dy = particleY - mousePixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius) {
                        const normalX = dx / distance;
                        const normalY = dy / distance;

                        // Enhanced vortex effect
                        const crossProduct = (normalX * mouseVelocityY - normalY * mouseVelocityX) * 10;

                        // Add rotational component based on distance from center
                        const rotationFactor = Math.pow(1 - distance / pushRadius, 2) * 3;
                        const forceX = (-normalY * crossProduct - dx * rotationFactor) * mouseSpeed;
                        const forceY = (normalX * crossProduct - dy * rotationFactor) * mouseSpeed;

                        const forceMagnitude = (1 - distance / pushRadius) * pushForce;
                        externalForces[i * 2] = forceX * forceMagnitude / canvas.width;
                        externalForces[i * 2 + 1] = forceY * forceMagnitude / canvas.height;
                    }
                }
            }


            for (let i = 0; i < renderCount; i++) {
                const dx = setPoints[i * 2] - positions[i * 2];
                const dy = setPoints[i * 2 + 1] - positions[i * 2 + 1];

                velocities[i * 2] = (velocities[i * 2] * dampings[i] * dampingRate) + (dx * accelerations[i]) + (externalForces[i * 2]);
                velocities[i * 2 + 1] = (velocities[i * 2 + 1] * dampings[i] * dampingRate) + (dy * accelerations[i]) + (externalForces[i * 2 + 1]);


                positions[i * 2] += velocities[i * 2] * (deltaTime);
                positions[i * 2 + 1] += velocities[i * 2 + 1] * (deltaTime);

                // Decay external forces
                externalForces[i * 2] = decayForce(externalForces[i * 2], deltaTime);
                externalForces[i * 2 + 1] = decayForce(externalForces[i * 2 + 1], deltaTime);
            }

            frameCount++;
            if (currentTime - lastFpsTime >= 1.0) {
                fps = frameCount;
                frameCount = 0;
                lastFpsTime = currentTime;

                stats.textContent = `
                    FPS: ${fps}
                    Particles: ${numParticles}
                    Delta: ${deltaTime.toFixed(4)}ms
                `;
            }

            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.POINTS, 0, renderCount);

            if (true) {
                requestAnimationFrame(draw);
            }
            else {
                setTimeout(requestAnimationFrame(draw), 1);
            }
        }

        function decayForce(force, deltaTime) {
            if (Math.abs(force) > 0.01) {
                return force * Math.exp(-deltaTime * 5);
            }
            return 0;
        }

        const PARTICLE_MODES = {
            circle: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const radius = CONFIG.behavior.radius;
                    const aspectRatio = canvas.width / canvas.height;
                    for (let i = 0; i < remainingPoints; i++) {
                        const angle = i * (2 * Math.PI / remainingPoints);
                        points.push({
                            x: Math.cos(angle) * radius,
                            y: Math.sin(angle) * radius * aspectRatio
                        });
                    }
                }
            },
            center: {
                renderExtras: false,
                init: (points, remainingPoints) => {
                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({ x: 0, y: 0 });
                    }
                }
            },
            maintain: {
                renderExtras: false,
                init: (points, remainingPoints) => {
                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({
                            x: particleArrays.positions[(points.length + i) * 2],
                            y: particleArrays.positions[(points.length + i) * 2 + 1]
                        });
                    }
                }
            },
            spiral: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const spiralRadius = CONFIG.behavior.radius;
                    const spiralTurns = 3;
                    for (let i = 0; i < remainingPoints; i++) {
                        const distance = (i / remainingPoints) * spiralRadius;
                        const angle = i * (2 * Math.PI * spiralTurns / remainingPoints);
                        points.push({
                            x: Math.cos(angle) * distance,
                            y: Math.sin(angle) * distance
                        });
                    }
                }
            },
            wave: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const waveAmplitude = CONFIG.behavior.radius * 0.5;
                    const waveFrequency = 5;
                    for (let i = 0; i < remainingPoints; i++) {
                        const x = (i / remainingPoints) * 2 - 1;
                        points.push({
                            x: x * CONFIG.behavior.radius,
                            y: Math.sin(x * waveFrequency) * waveAmplitude
                        });
                    }
                }
            },
            fountain: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const fountainBase = -0.8;
                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({
                            x: (Math.random() * 2 - 1) * CONFIG.behavior.radius * 0.5,
                            y: fountainBase
                        });
                    }
                }
            },
            test: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({
                            x: -1,
                            y: 1
                        });
                    }
                }
            }
        };



        function getOrderedPoints(text) {
            const density = CONFIG.text.density;
            const textSize = CONFIG.text.size;
            const textScale = CONFIG.text.scale;

            const textCanvas = document.createElement('canvas');
            const ctx = textCanvas.getContext('2d');

            ctx.font = `bold ${textSize}px Arial`;

            const textMetrics = ctx.measureText(text);
            const textWidth = textMetrics.actualBoundingBoxLeft + textMetrics.actualBoundingBoxRight;

            const defaultMetric = ctx.measureText("0:00");

            const isTimeFormat = /^\d+:\d+$/.test(text);
            const referenceWidth = isTimeFormat ? textWidth : defaultMetric.actualBoundingBoxLeft + defaultMetric.actualBoundingBoxRight;

            const dynamicScale = textScale * (textWidth / referenceWidth);

            textCanvas.width = textWidth;
            textCanvas.height = textSize;

            ctx.font = `bold ${textSize}px Arial`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);


            const points = [];
            const imageData = ctx.getImageData(0, 0, textCanvas.width, textCanvas.height).data;

            switch (CONFIG.behavior.ordering) {
                case 'vertical':
                    for (let x = 0; x < textCanvas.width; x += density) {
                        for (let y = 0; y < textCanvas.height; y += density) {
                            const alpha = imageData[(y * textCanvas.width + x) * 4 + 3];
                            if (alpha > 128) {
                                points.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * dynamicScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * textScale
                                });
                            }
                        }
                    }
                    break;

                case 'horizontal':
                    for (let y = 0; y < textCanvas.height; y += density) {
                        for (let x = 0; x < textCanvas.width; x += density) {
                            const alpha = imageData[(y * textCanvas.width + x) * 4 + 3];
                            if (alpha > 128) {
                                points.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * dynamicScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * textScale
                                });
                            }
                        }
                    }
                    break;
                case 'optimized':
                    const validPixels = [];

                    for (let x = 0; x < textCanvas.width; x += density) {
                        for (let y = 0; y < textCanvas.height; y += density) {
                            const alpha = imageData[(y * textCanvas.width + x) * 4 + 3];
                            if (alpha > 128) {
                                validPixels.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * dynamicScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * textScale
                                });
                            }
                        }
                    }

                    if (previousPoints.size === 0) {
                        previousPoints.clear();
                        validPixels.forEach((point, index) => {
                            const key = `${point.x},${point.y}`;
                            previousPoints.set(key, index);
                        });
                        return validPixels;
                    }

                    const result = new Array(validPixels.length);
                    const usedPoints = new Set();
                    const unassignedIndices = new Set(Array.from({ length: validPixels.length }, (_, i) => i));

                    validPixels.forEach((point, i) => {
                        const key = `${point.x},${point.y}`;
                        const previousIndex = previousPoints.get(key);

                        if (previousIndex !== undefined && previousIndex < validPixels.length) {
                            result[previousIndex] = point;
                            usedPoints.add(i);
                            unassignedIndices.delete(previousIndex);
                        }
                    });

                    const remainingPoints = validPixels.filter((_, i) => !usedPoints.has(i));
                    const remainingIndices = Array.from(unassignedIndices);

                    remainingIndices.forEach((index, i) => {
                        result[index] = remainingPoints[i];
                    });

                    return result;
            }

            return points;
        }


        function getTextPoints(text, addExtraPoints = true) {
            const points = getOrderedPoints(text);
            const realPointsLength = points.length;

            if (addExtraPoints) {
                const mode = PARTICLE_MODES[CONFIG.behavior.extraParticleMode];
                const remainingPoints = numParticles - points.length;

                if (mode) {
                    mode.init(points, remainingPoints);
                }
            }

            previousPoints.clear();
            points.forEach((point, index) => {
                const key = `${point.x},${point.y}`;
                previousPoints.set(key, index);
            });

            return { realPointsLength, points };
        }

        let timeTxt = "";
        let endTime = (+new Date) + (60 * 1000);
        let msLeft = 0;

        let isFirstTick = true;

        function updateTimer() {
            const {
                positions,
                velocities,
                setPoints,
                accelerations,
                dampings
            } = particleArrays;

            msLeft = endTime - (+new Date);

            let secondsLeft = Math.floor(msLeft / 1000);

            if (secondsLeft <= 10 && secondsLeft >= 1) {
                document.getElementById('tickSound').play();
            }

            if (msLeft < 1000) {
                document.getElementById('timerComplete').play();
                timeTxt = "Time's up!";
            } else {
                const time = new Date(msLeft);
                const mins = time.getUTCMinutes();
                timeTxt = mins + ':' + twoDigits(time.getUTCSeconds());
                const delay = isFirstTick ? 1400 : 1000;
                isFirstTick = false;
                setTimeout(updateTimer, delay);
            }

            const { realPointsLength, points } = getTextPoints(timeTxt, true);
            activePointsCount = realPointsLength;

            for (let i = 0; i < numParticles; i++) {
                setPoints[i * 2] = points[i].x;
                setPoints[i * 2 + 1] = points[i].y;
            }
        }


        function twoDigits(n) {
            return (n < 10 ? '0' : '') + n;
        }

        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            document.getElementById('menu').style.display = 'block';
        });

        document.getElementById('startTimer').addEventListener('click', () => {
            const minutes = parseInt(document.getElementById('minutes').value);
            const seconds = parseInt(document.getElementById('seconds').value);

            initializeWithConfig(getConfigFromInputs(), minutes, seconds);
            endTime = (+new Date) + ((minutes * 60 + seconds) * 1000);
            document.getElementById('menu').style.display = 'none';

            timerRunning = true;
            updateTimer();
            requestAnimationFrame(draw);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.getElementById('menu').style.display = 'none';
            }
        });

        function saveConfigToCookie() {
            const configName = document.getElementById('configName').value;
            if (!configName) {
                document.getElementById('configName').classList.add('error');
                return;
            }

            const config = {
                name: configName,
                ...getConfigFromInputs()
            };

            document.cookie = `${configName}=${JSON.stringify(config)}; expires=${new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toUTCString()}; path=/; SameSite=Strict`;


            document.getElementById('configName').value = '';
            document.getElementById('configName').classList.remove('error');

            loadSavedPresets();
        }

        // Add event listener for the save button
        document.getElementById('saveConfig').addEventListener('click', saveConfigToCookie);




        document.getElementById('presetStyle').addEventListener('change', (e) => {
            const selectedPreset = PRESETS[e.target.value];
            updateInputsFromPreset(selectedPreset);
        });


        document.getElementById('toggleAdvanced').addEventListener('click', function () {
            const advancedOptions = document.getElementById('advancedOptions');
            const isHidden = advancedOptions.style.display === 'none';
            advancedOptions.style.display = isHidden ? 'block' : 'none';
            this.textContent = isHidden ? 'Hide Advanced Options' : 'Show Advanced Options';
        });

        const colorPickers = document.getElementById('colorPickers');
        document.getElementById('addColor').addEventListener('click', () => {
            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.className = 'particleColor';
            colorPickers.insertBefore(colorInput, document.getElementById('addColor'));
        });

        document.getElementById('removeColor').addEventListener('click', () => {
            const colors = colorPickers.querySelectorAll('.particleColor');
            if (colors.length > 1) {
                colors[colors.length - 1].remove();
            }
        });

        document.querySelectorAll('#advancedOptions input, #advancedOptions select')
            .forEach(input => {
                input.addEventListener('change', () => {
                    CONFIG = getConfigFromInputs();
                });
            });

        function updateInputsFromPreset(preset) {
            document.getElementById('textSize').value = preset.text.size;
            document.getElementById('textScale').value = preset.text.scale;
            document.getElementById('particleSize').value = preset.particles.appearance.size.base;
            document.getElementById('particleDensity').value = preset.text.density;
            document.getElementById('radius').value = preset.behavior.radius;
            document.getElementById('particleOrdering').value = preset.behavior.ordering;
            console.log(document.getElementById('particleOrdering').value);

            document.getElementById('positionMin').value = preset.particles.position.min;
            document.getElementById('positionSpread').value = preset.particles.position.spread;
            document.getElementById('accelerationBase').value = preset.particles.physics.acceleration.base;
            document.getElementById('accelerationVar').value = preset.particles.physics.acceleration.variation;
            document.getElementById('dampingBase').value = preset.particles.physics.damping.base;
            document.getElementById('dampingVar').value = preset.particles.physics.damping.variation;
            document.getElementById('extraParticleMode').value = preset.behavior.extraParticleMode;
            document.getElementById('sizeVariation').value = preset.particles.appearance.size.variation;

            const colorPickers = document.getElementById('colorPickers');
            Array.from(colorPickers.querySelectorAll('.particleColor')).forEach(picker => picker.remove());
            preset.particles.appearance.colors.forEach(color => {
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.className = 'particleColor';
                // Convert RGB [0-1] to hex
                const hex = '#' + color.map(c =>
                    Math.round(c * 255).toString(16).padStart(2, '0')
                ).join('');
                colorInput.value = hex;
                colorPickers.insertBefore(colorInput, document.getElementById('addColor'));
            });
        }


        function findLargestAreaTime(minutes, seconds) {
            const digitScores = {};
            for (let i = 0; i <= 9; i++) {
                digitScores[i] = getTextPoints(i.toString(), false).realPointsLength;
            }

            let maxScore = 0;
            let maxAreaTime = null;

            for (let m = minutes; m >= 0; m--) {
                const maxSecs = m === minutes ? seconds : 59;
                const minSecs = m === 0 ? 1 : 0;

                for (let s = maxSecs; s >= minSecs; s--) {
                    const timeDigits = `${m}${s.toString().padStart(2, '0')}`.split('').map(Number);
                    const score = timeDigits.reduce((sum, digit) => sum + digitScores[digit], 0);

                    if (score > maxScore) {
                        maxScore = score;
                        maxAreaTime = `${m}:${s.toString().padStart(2, '0')}`;
                    }
                }
            }

            return maxAreaTime;
        }

        function initializeWithConfig(newConfig, minutes, seconds) {
            Object.assign(CONFIG, newConfig);

            const maxPoints = Math.max(
                getTextPoints(findLargestAreaTime(minutes, seconds), false).realPointsLength,
                getTextPoints("Time's up!", false).realPointsLength
            );

            numParticles = maxPoints;
            particleArrays = createParticleArrays(numParticles);
            externalForces = new Float32Array(numParticles * 2);
            initializeParticles(particleArrays, 0, numParticles);
            updateBuffers(particleArrays);
        }

        function loadSavedPresets() {
            const presetSelect = document.getElementById('presetStyle');

            document.cookie.split(';').forEach(cookie => {
                const [name, value] = cookie.trim().split('=');
                if (name) {
                    try {
                        const config = JSON.parse(value);
                        if (config.name) {
                            const option = document.createElement('option');
                            option.value = name;
                            option.textContent = config.name;
                            presetSelect.appendChild(option);

                            PRESETS[name] = new ParticleConfig({
                                ...config,
                                colors: config.colors.map(hexToRGB),
                            });
                        }
                    } catch (e) {
                        console.warn('Error parsing cookie:', e);
                    }
                }
            });
        }

        loadSavedPresets();
        updateInputsFromPreset(PRESETS[document.getElementById('presetStyle').value]);
    </script>
</body>

</html>