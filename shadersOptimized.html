<!DOCTYPE html>
<html>

<head>
    <title>WebGL Particle Timer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
        }

        label {
            display: block;
            margin: 10px 0;
        }

        input,
        select {
            margin-left: 10px;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 3px;
        }

        button {
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }
    </style>
</head>

<body>
    <div id="menu"
        style="position: fixed; width: 100vw; height: 100vh; background: rgba(0,0,0,0.9); color: white; padding: 20px 20px 80px 20px; font-family: Arial; z-index: 1000; overflow-y: auto; overflow-x: hidden;">
        <button id="fullscreenButton"
            style="position: absolute; top: 10px; right: 60px; padding: 10px 20px;">Fullscreen</button>
        <h2>Particle Timer Settings</h2>
    </div>
    <canvas id="glCanvas"></canvas>
    <audio id="tickSound" src="https://assets.mixkit.co/active_storage/sfx/2568/2568.wav"></audio>
    <audio id="timerComplete" src="https://assets.mixkit.co/active_storage/sfx/2865/2865.wav"></audio>

    <script type="x-shader/x-vertex" id="vertex-shader">
        attribute vec2 a_position;
        attribute vec3 a_color;
        attribute float a_size;
        varying vec3 v_color;
    
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            gl_PointSize = a_size;
            v_color = a_color;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragment-shader">
        precision mediump float;
        varying vec3 v_color;
        uniform float u_glow_intensity;
        uniform float u_glow_size;
    
        void main() {
            vec2 coord = gl_PointCoord * 2.0 - 1.0;
            float dist = length(coord);
            
            float core = 1.0 - step(0.5, dist);
            
            float glow = u_glow_intensity > 0.0 ? 
                u_glow_intensity * exp(-dist * (1.0 / u_glow_size)) * (1.0 - dist) : 
                0.0;
            
            float alpha = core + glow;
            gl_FragColor = vec4(v_color, alpha);
        }
    </script>




    <script>
        const COLOR_PRESETS = {
            neonLights: [
                [1.0, 0.0, 1.0],  // Magenta
                [0.0, 1.0, 1.0],  // Cyan
                [1.0, 1.0, 0.0]   // Yellow
            ],
            pastelDream: [
                [0.95, 0.61, 0.73],  // Pink
                [0.56, 0.93, 0.56],  // Mint
                [0.68, 0.85, 0.90],  // Sky
                [0.97, 0.85, 0.45],  // Yellow
                [0.85, 0.75, 0.95]   // Lavender
            ],
            oceanBreeze: [
                [0.29, 0.31, 0.30],  // Dark teal
                [0.05, 0.60, 0.65],  // Turquoise
                [0.24, 0.64, 0.67],  // Sea blue
                [0.96, 0.80, 0.38],  // Sand
                [0.99, 0.54, 0.44]   // Coral
            ]
        };
        // Particle Configuration System
        const ConfigSchema = {
            fields: {
                particles: {
                    position: {
                        min: { type: 'number', min: -2, max: 0, step: 0.1, default: -0.7 },
                        spread: { type: 'number', min: 0, max: 3, step: 0.1, default: 1.2 }
                    },
                    physics: {
                        acceleration: {
                            base: { type: 'number', min: 0, max: 20, step: 0.5, default: 3 },
                            variation: { type: 'number', min: 0, max: 10, step: 0.5, default: 3 }
                        },
                        damping: {
                            base: { type: 'number', min: 0.8, max: 0.999, step: 0.001, default: 0.95 },
                            variation: { type: 'number', min: 0, max: 0.1, step: 0.001, default: 0.04 }
                        }
                    },
                    appearance: {
                        size: {
                            base: { type: 'number', min: 1, max: 20, default: 15 },
                            variation: { type: 'number', min: 0, max: 75, default: 75 }
                        },
                        colors: {
                            type: 'colorArray',
                            presets: COLOR_PRESETS,
                            default: COLOR_PRESETS.oceanBreeze
                        },
                        glow: {
                            intensity: { type: 'number', min: 0.1, max: 10, step: 0.1, default: 0 },
                            size: { type: 'number', min: 0.1, max: 10, step: 0.1, default: 2.0 }
                        }
                    },
                    mouseBehavior: {
                        pushForce: { type: 'number', min: 0, max: 5000, default: 2000 },
                        pushRadius: { type: 'number', min: 0, max: 500, default: 200 }
                    },
                },
                text: {
                    size: { type: 'number', min: 100, max: 400, default: 30 },
                    scale: { type: 'number', min: 0.1, max: 2, step: 0.1, default: 0.6 },
                    endTextScale: { type: 'number', min: 0.1, max: 2, step: 0.1, default: 0.4 },
                    density: { type: 'number', min: 1, max: 5, default: 1 },
                    endText: { type: 'string', default: 'Time\'s up!' },
                },
                behavior: {
                    ordering: {
                        type: 'select',
                        options: ['vertical', 'horizontal', 'optimized'],
                        default: 'vertical'
                    },
                    radius: { type: 'number', min: 0.5, max: 3, step: 0.1, default: 0.8 },
                    extraParticleMode: {
                        type: 'select',
                        options: ['circle', 'center', 'maintain', 'spiral', 'wave', 'fountain', 'test'],
                        default: 'circle'
                    }
                }
            },

            createDefault() {
                return this.createFromSchema(this.fields);
            },

            createFromSchema(schema) {
                const result = {};
                Object.entries(schema).forEach(([key, value]) => {
                    if (value.type) {
                        result[key] = value.default;
                    } else {
                        result[key] = this.createFromSchema(value);
                    }
                });
                return result;
            },

            generateUI(container) {
                this.buildUIFromSchema(this.fields, container);
            },

            buildUIFromSchema(schema, container, path = '') {
                Object.entries(schema).forEach(([key, value]) => {
                    const currentPath = path ? `${path}.${key}` : key;

                    if (value.type) {
                        container.appendChild(this.createControl(key, value, currentPath));
                    } else {
                        const section = document.createElement('div');
                        section.className = 'section';
                        section.innerHTML = `<h3>${key.charAt(0).toUpperCase() + key.slice(1)}</h3>`;
                        this.buildUIFromSchema(value, section, currentPath);
                        container.appendChild(section);
                    }
                });
            },

            createControl(key, config, path) {
                const label = document.createElement('label');
                label.textContent = key.charAt(0).toUpperCase() + key.slice(1) + ': ';

                const input = this.createInputByType(config);
                input.id = path.replace(/\./g, '_');
                input.dataset.configPath = path;

                label.appendChild(input);
                return label;
            },

            createInputByType(config) {
                let container, select, input, opt;

                switch (config.type) {
                    case 'colorArray':
                        container = document.createElement('div');
                        container.id = 'colorPickers';

                        select = document.createElement('select');
                        select.id = 'colorPreset';
                        Object.keys(COLOR_PRESETS).forEach(presetName => {
                            opt = document.createElement('option');
                            opt.value = presetName;
                            opt.textContent = presetName;
                            select.appendChild(opt);
                        });
                        container.appendChild(select);

                        config.default.forEach(color => {
                            input = document.createElement('input');
                            input.type = 'color';
                            input.className = 'particleColor';
                            input.value = `#${color.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('')}`;
                            container.appendChild(input);
                        });

                        return container;

                    case 'number':
                        input = document.createElement('input');
                        input.type = 'number';
                        input.min = config.min;
                        input.max = config.max;
                        input.step = config.step || 1;
                        input.value = config.default;
                        return input;

                    case 'select':
                        select = document.createElement('select');
                        config.options.forEach(option => {
                            opt = document.createElement('option');
                            opt.value = option;
                            opt.textContent = option;
                            select.appendChild(opt);
                        });
                        select.value = config.default;
                        return select;
                    case 'string':
                        input = document.createElement('input');
                        input.type = 'text';
                        input.value = config.default;
                        return input;
                    case 'boolean':
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = config.default;
                        return input;
                }
            }
        };

        function updateColorPickers(colors, container) {
            Array.from(container.querySelectorAll('.particleColor')).forEach(picker => picker.remove());

            colors.forEach(color => {
                const input = document.createElement('input');
                input.type = 'color';
                input.className = 'particleColor';
                const hexColor = `#${color.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('')}`;
                input.value = hexColor;
                container.appendChild(input);
            });
        }

        // Core state management
        const STATE = {
            config: null,
            presets: {
                current: null,
                saved: new Map(),
            },
            mouse: {
                x: 0,
                y: 0,
                velocityX: 0,
                velocityY: 0,
                clicked: false,
                down: false
            },
            particles: {
                arrays: null,
                count: 0,
                activeCount: 0,
                previousPoints: new Map(),
                externalForces: null
            },
            render: {
                canvas: null,
                gl: null,
                program: null,
                buffers: {
                    position: null,
                    size: null,
                    color: null
                },
                attributes: {
                    position: null,
                    size: null,
                    color: null
                }
            },
            stats: {
                frameCount: 0,
                lastFpsTime: 0,
                fps: 0,
                element: null
            },
            timer: {
                running: false,
                lastTime: 0
            },
            canvas: {
                rect: null,
                aspectRatio: 1
            },
            menu: {
                visible: true
            }
        };

        const PRESETS = {
            minimal: {
                particles: {
                    position: {
                        min: -0.7,
                        spread: 1.2
                    },
                    physics: {
                        acceleration: {
                            base: 3,
                            variation: 3
                        },
                        damping: {
                            base: 0.95,
                            variation: 0.04
                        }
                    },
                    appearance: {
                        size: {
                            base: 5,
                            variation: 10
                        },
                        colors: COLOR_PRESETS.oceanBreeze,
                        glow: {
                            intensity: 0.3,
                            size: 1.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 1500,
                        pushRadius: 100
                    },
                },
                text: {
                    size: 30,
                    scale: 0.6,
                    density: 1
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "circle",
                    radius: 0.8
                }
            },

            neon: {
                particles: {
                    position: {
                        min: -0.9,
                        spread: 1.8
                    },
                    physics: {
                        acceleration: {
                            base: 5,
                            variation: 5.0
                        },
                        damping: {
                            base: 0.99,
                            variation: 0.005
                        }
                    },
                    appearance: {
                        size: {
                            base: 1,
                            variation: 2.0
                        },
                        colors: COLOR_PRESETS.neonLights,

                        glow: {
                            intensity: 1,
                            size: 1.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 1000,
                        pushRadius: 100
                    },
                },
                text: {
                    size: 280,
                    scale: 1,
                    density: 2
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "maintain",
                    radius: 2
                }
            }
        };



        function applyPreset(presetName) {
            const preset = PRESETS[presetName];
            if (!preset) return;

            STATE.config = preset;

            document.querySelectorAll('[data-config-path]').forEach(input => {
                const path = input.dataset.configPath.split('.');
                let value = preset;

                for (const key of path) {
                    value = value[key];
                }

                if (input.type === 'color') {
                    input.value = rgbToHex(value);
                } else {
                    input.value = value;
                }
            });

            // Update color preset selector and pickers
            const colorPresetSelect = document.getElementById('colorPreset');
            const matchingPreset = Object.entries(COLOR_PRESETS).find(([_, colors]) =>
                JSON.stringify(colors) === JSON.stringify(preset.particles.appearance.colors)
            );
            if (matchingPreset) {
                colorPresetSelect.value = matchingPreset[0];
                updateColorPickers(preset.particles.appearance.colors, colorPresetSelect);
            }
        }


        function loadPresets() {
            // Load default presets into state
            Object.entries(PRESETS).forEach(([name, config]) => {
                STATE.presets.saved.set(name, config);
            });

            // Load saved presets from cookies
            document.cookie.split(';').forEach(cookie => {
                const [name, value] = cookie.trim().split('=');
                if (name) {
                    try {
                        const config = JSON.parse(value);
                        STATE.presets.saved.set(name, config);
                    } catch (e) {
                        console.warn('Invalid preset in cookie:', name);
                    }
                }
            });

            // Update preset select element
            document.getElementById('presetStyle').addEventListener('change', (e) => {
                const preset = PRESETS[e.target.value];
                STATE.config = preset;

                const colorPresetSelect = document.getElementById('colorPreset');
                const container = colorPresetSelect.parentElement;
                updateColorPickers(preset.particles.appearance.colors, container);
            });
        }


        function initializeWithConfig(newConfig, minutes, seconds) {
            // Update global config
            Object.assign(STATE.config, newConfig);

            // Calculate maximum required particles based on time format
            const maxPoints = Math.max(
                getTextPoints(findLargestAreaTime(minutes, seconds), false).realPointsLength,
                getTextPoints(STATE.config.text.endText, false).realPointsLength
            );

            // Update particle count in state
            STATE.particles.count = maxPoints;
            STATE.particles.arrays = createParticleArrays(maxPoints);
            STATE.particles.externalForces = new Float32Array(maxPoints * 2);

            // Initialize particle arrays
            initializeParticles(STATE.particles.arrays, 0, maxPoints);
            updateBuffers(STATE.particles.arrays);
        }

        // Helper function to find time format requiring most particles
        function findLargestAreaTime(minutes, seconds) {
            const digitScores = {};
            for (let i = 0; i <= 9; i++) {
                digitScores[i] = getTextPoints(i.toString(), false).realPointsLength;
            }

            let maxScore = 0;
            let maxAreaTime = null;

            for (let m = minutes; m >= 0; m--) {
                const maxSecs = m === minutes ? seconds : 59;
                const minSecs = m === 0 ? 1 : 0;

                for (let s = maxSecs; s >= minSecs; s--) {
                    const timeDigits = `${m}${s.toString().padStart(2, '0')}`.split('').map(Number);
                    const score = timeDigits.reduce((sum, digit) => sum + digitScores[digit], 0);

                    if (score > maxScore) {
                        maxScore = score;
                        maxAreaTime = `${m}:${s.toString().padStart(2, '0')}`;
                    }
                }
            }

            return maxAreaTime;
        }

        function getConfigFromInputs() {
            const config = ConfigSchema.createDefault();

            document.querySelectorAll('[data-config-path]').forEach(input => {
                const path = input.dataset.configPath.split('.');
                let target = config;

                // Navigate to the correct nested object
                for (let i = 0; i < path.length - 1; i++) {
                    target = target[path[i]];
                }

                const key = path[path.length - 1];
                if (key === 'colors') {
                    // Handle color array specially
                    target[key] = Array.from(document.querySelectorAll('.particleColor')).map(cp => {
                        const hex = cp.value;
                        return [
                            parseInt(hex.slice(1, 3), 16) / 255,
                            parseInt(hex.slice(3, 5), 16) / 255,
                            parseInt(hex.slice(5, 7), 16) / 255
                        ];
                    });
                } else if (input.type === 'number') {
                    target[key] = parseFloat(input.value);
                } else {
                    target[key] = input.value;
                }
            });

            return config;
        }


        // Helper functions
        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function twoDigits(n) {
            return (n < 10 ? '0' : '') + n;
        }


        // Initialize WebGL
        function initGL() {
            STATE.render.canvas = document.getElementById('glCanvas');
            STATE.render.gl = STATE.render.canvas.getContext('webgl', {
                antialias: false,
                depth: false,
                alpha: false,
                preserveDrawingBuffer: false
            });

            const gl = STATE.render.gl;

            // Compile shaders
            const vertexShader = compileShader(gl, gl.VERTEX_SHADER,
                document.getElementById('vertex-shader').textContent);
            const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER,
                document.getElementById('fragment-shader').textContent);

            // Create and link program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            STATE.render.program = program;
            STATE.render.uniforms = {
                glowIntensity: gl.getUniformLocation(program, 'u_glow_intensity')
            };
            STATE.render.uniforms.resolution = gl.getUniformLocation(program, 'u_resolution')
            STATE.render.uniforms.glowSize = gl.getUniformLocation(program, 'u_glow_size');

            // Initialize buffers
            STATE.render.buffers.position = gl.createBuffer();
            STATE.render.buffers.size = gl.createBuffer();
            STATE.render.buffers.color = gl.createBuffer();

            // Cache attribute locations
            STATE.render.attributes.position = gl.getAttribLocation(program, 'a_position');
            STATE.render.attributes.size = gl.getAttribLocation(program, 'a_size');
            STATE.render.attributes.color = gl.getAttribLocation(program, 'a_color');

            // Enable attributes
            gl.enableVertexAttribArray(STATE.render.attributes.position);
            gl.enableVertexAttribArray(STATE.render.attributes.size);
            gl.enableVertexAttribArray(STATE.render.attributes.color);

            // Set up vertex attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.position);
            gl.vertexAttribPointer(STATE.render.attributes.position, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.size);
            gl.vertexAttribPointer(STATE.render.attributes.size, 1, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.color);
            gl.vertexAttribPointer(STATE.render.attributes.color, 3, gl.FLOAT, false, 0, 0);

            // Set up blending
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }


        // Optimized particle array creation
        function createParticleArrays(count) {
            return {
                positions: new Float32Array(count * 2),
                velocities: new Float32Array(count * 2),
                setPoints: new Float32Array(count * 2),
                accelerations: new Float32Array(count),
                dampings: new Float32Array(count),
                particleSizes: new Float32Array(count),
                particleColors: new Float32Array(count * 3)
            };
        }

        // Optimized particle initialization
        function initializeParticles(arrays, startIndex, endIndex) {
            const config = STATE.config;
            for (let i = startIndex; i < endIndex; i++) {
                const posIndex = i * 2;
                const colorIndex = i * 3;

                arrays.positions[posIndex] = Math.random() * config.particles.position.spread + config.particles.position.min;
                arrays.positions[posIndex + 1] = Math.random() * config.particles.position.spread + config.particles.position.min;

                arrays.velocities[posIndex] = 0;
                arrays.velocities[posIndex + 1] = 0;

                arrays.setPoints[posIndex] = 0;
                arrays.setPoints[posIndex + 1] = 0;

                arrays.accelerations[i] = Math.max(
                    config.particles.physics.acceleration.base +
                    Math.random() * config.particles.physics.acceleration.variation,
                    0.0001
                );

                arrays.dampings[i] = Math.min(
                    config.particles.physics.damping.base +
                    Math.random() * config.particles.physics.damping.variation,
                    0.9999
                );

                arrays.particleSizes[i] = config.particles.appearance.size.base +
                    Math.random() * config.particles.appearance.size.variation;

                const randomColor = config.particles.appearance.colors[
                    Math.floor(Math.random() * config.particles.appearance.colors.length)
                ];
                arrays.particleColors[colorIndex] = randomColor[0];
                arrays.particleColors[colorIndex + 1] = randomColor[1];
                arrays.particleColors[colorIndex + 2] = randomColor[2];
            }
        }

        // Optimized buffer updates
        function updateBuffers(arrays) {
            const gl = STATE.render.gl;
            const buffers = STATE.render.buffers;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.positions, gl.DYNAMIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.size);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.particleSizes, gl.STATIC_DRAW);

            const colorArray = new Float32Array(arrays.particleColors);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
            gl.bufferData(gl.ARRAY_BUFFER, colorArray, gl.STATIC_DRAW);
        }

        // Optimized particle modes
        const PARTICLE_MODES = {
            getMode(modeName) {
                return PARTICLE_MODES[modeName] || PARTICLE_MODES.center;
            },
            initializeMode(mode, points, remainingPoints) {
                const initFn = PARTICLE_MODES.getMode(mode).init;
                if (initFn) initFn(points, remainingPoints);
            },
            circle: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const radius = STATE.config.behavior.radius;
                    const aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;
                    for (let i = 0; i < remainingPoints; i++) {
                        const angle = i * (2 * Math.PI / remainingPoints);
                        points.push({
                            x: Math.cos(angle) * radius,
                            y: Math.sin(angle) * radius * aspectRatio
                        });
                    }
                }
            },
            center: {
                renderExtras: false,
                init: (points, remainingPoints) => {
                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({ x: 0, y: 0 });
                    }
                }
            },
            maintain: {
                renderExtras: false,
                init: (points, remainingPoints) => {
                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({
                            x: STATE.particles.arrays.positions[(points.length + i) * 2],
                            y: STATE.particles.arrays.positions[(points.length + i) * 2 + 1]
                        });
                    }
                }
            },
            spiral: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const spiralRadius = CONFIG.behavior.radius;
                    const spiralTurns = 3;
                    for (let i = 0; i < remainingPoints; i++) {
                        const distance = (i / remainingPoints) * spiralRadius;
                        const angle = i * (2 * Math.PI * spiralTurns / remainingPoints);
                        points.push({
                            x: Math.cos(angle) * distance,
                            y: Math.sin(angle) * distance
                        });
                    }
                }
            },
            wave: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const waveAmplitude = CONFIG.behavior.radius * 0.5;
                    const waveFrequency = 5;
                    for (let i = 0; i < remainingPoints; i++) {
                        const x = (i / remainingPoints) * 2 - 1;
                        points.push({
                            x: x * CONFIG.behavior.radius,
                            y: Math.sin(x * waveFrequency) * waveAmplitude
                        });
                    }
                }
            },
            fountain: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const fountainBase = -0.8;
                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({
                            x: (Math.random() * 2 - 1) * CONFIG.behavior.radius * 0.5,
                            y: fountainBase
                        });
                    }
                }
            },
            test: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({
                            x: -1,
                            y: 1
                        });
                    }
                }
            }
        };

        // Optimized force application and physics
        function applyForces(deltaTime) {
            const mouse = STATE.mouse;
            const particles = STATE.particles;
            const canvas = STATE.render.canvas;

            const mousePixelX = STATE.mouse.x * canvas.width / 2;
            const mousePixelY = STATE.mouse.y * canvas.height / 2;

            const pushForce = STATE.config.particles.mouseBehavior.pushForce;
            const pushRadius = STATE.config.particles.mouseBehavior.pushRadius; // In pixels
            
            if (mouse.down) {
                for (let i = 0; i < particles.count; i++) {
                    const particleX = particles.arrays.positions[i * 2] * canvas.width / 2;
                    const particleY = particles.arrays.positions[i * 2 + 1] * canvas.height / 2;

                    const dx = particleX - mousePixelX;
                    const dy = particleY - mousePixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius) {
                        const normalX = dx / distance;
                        const normalY = dy / distance;

                        // Direct outward force
                        const forceX = normalX * pushForce ** 2;
                        const forceY = normalY * pushForce ** 2;

                        const forceMagnitude = (1 - distance / pushRadius);
                        particles.externalForces[i * 2] = forceX * forceMagnitude / canvas.width;
                        particles.externalForces[i * 2 + 1] = forceY * forceMagnitude / canvas.height;
                    }
                }
            }

            if (STATE.mouse.clicked) {
                for (let i = 0; i < particles.count; i++) {
                    const particleX = particles.arrays.positions[i * 2] * canvas.width / 2;
                    const particleY = particles.arrays.positions[i * 2 + 1] * canvas.height / 2;

                    const dx = particleX - mousePixelX;
                    const dy = particleY - mousePixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius) {
                        const force = (1 - distance / pushRadius) * pushForce;
                        const normalizedDx = dx / canvas.width;
                        const normalizedDy = dy / canvas.height;
                        particles.externalForces[i * 2] = normalizedDx * force;
                        particles.externalForces[i * 2 + 1] = -normalizedDy * force;
                    }
                }
                STATE.mouse.clicked = false;
            }
        }

        function decayForce(force, deltaTime) {
            return Math.abs(force) > 0.01 ? force * Math.exp(-deltaTime * 5) : 0;
        }


        function getTextPoints(text, addExtraPoints = true) {
            const points = getOrderedPoints(text);
            const realPointsLength = points.length;

            if (addExtraPoints) {
                const mode = PARTICLE_MODES[STATE.config.behavior.extraParticleMode];
                const remainingPoints = STATE.particles.count - points.length;

                if (mode) {
                    mode.init(points, remainingPoints);
                }
            }

            STATE.particles.previousPoints.clear();
            points.forEach((point, index) => {
                const key = `${point.x},${point.y}`;
                STATE.particles.previousPoints.set(key, index);
            });

            return { realPointsLength, points };
        }

        function getOrderedPoints(text) {
            const density = STATE.config.text.density;
            const textSize = STATE.config.text.size;
            const textScale = STATE.config.text.scale;

            const textCanvas = document.createElement('canvas');
            const ctx = textCanvas.getContext('2d');

            ctx.font = `bold ${textSize}px Arial`;

            const textMetrics = ctx.measureText(text);
            const textWidth = textMetrics.actualBoundingBoxLeft + textMetrics.actualBoundingBoxRight;
            const padding = textMetrics.actualBoundingBoxLeft;

            const defaultMetric = ctx.measureText("0:00");

            const isTimeFormat = /^\d+:\d+$/.test(text);
            const referenceWidth = isTimeFormat ? textWidth : defaultMetric.actualBoundingBoxLeft + defaultMetric.actualBoundingBoxRight;

            const dynamicScale = isTimeFormat ?
                textScale * (textWidth / referenceWidth) :
                STATE.config.text.endTextScale * (textWidth / referenceWidth);

            textCanvas.width = textWidth + Math.abs(padding * 2);
            textCanvas.height = textSize;

            ctx.font = `bold ${textSize}px Arial`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

            const points = [];
            const imageData = ctx.getImageData(0, 0, textCanvas.width, textCanvas.height).data;

            switch (STATE.config.behavior.ordering) {
                case 'vertical':
                    for (let x = 0; x < textCanvas.width; x += density) {
                        for (let y = 0; y < textCanvas.height; y += density) {
                            if (imageData[(y * textCanvas.width + x) * 4 + 3] > 128) {
                                points.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * dynamicScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * textScale
                                });
                            }
                        }
                    }
                    break;

                case 'horizontal':
                    for (let y = 0; y < textCanvas.height; y += density) {
                        for (let x = 0; x < textCanvas.width; x += density) {
                            if (imageData[(y * textCanvas.width + x) * 4 + 3] > 128) {
                                points.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * dynamicScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * textScale
                                });
                            }
                        }
                    }
                    break;

                case 'optimized':
                    const validPixels = [];
                    for (let x = 0; x < textCanvas.width; x += density) {
                        for (let y = 0; y < textCanvas.height; y += density) {
                            if (imageData[(y * textCanvas.width + x) * 4 + 3] > 128) {
                                validPixels.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * dynamicScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * textScale
                                });
                            }
                        }
                    }

                    if (STATE.particles.previousPoints.size === 0) {
                        return validPixels;
                    }

                    const result = new Array(validPixels.length);
                    const usedPoints = new Set();
                    const unassignedIndices = new Set(Array.from({ length: validPixels.length }, (_, i) => i));

                    validPixels.forEach((point, i) => {
                        const key = `${point.x},${point.y}`;
                        const previousIndex = STATE.particles.previousPoints.get(key);

                        if (previousIndex !== undefined && previousIndex < validPixels.length) {
                            result[previousIndex] = point;
                            usedPoints.add(i);
                            unassignedIndices.delete(previousIndex);
                        }
                    });

                    const remainingPoints = validPixels.filter((_, i) => !usedPoints.has(i));
                    Array.from(unassignedIndices).forEach((index, i) => {
                        result[index] = remainingPoints[i];
                    });

                    return result;
            }

            return points;
        }


        // Optimized rendering loop
        function draw(currentTime) {
            if (!STATE.timer.running) return;

            const drawStart = performance.now();
            currentTime *= 0.001;
            const deltaTime = Math.min(currentTime - STATE.timer.lastTime, 0.1);
            STATE.timer.lastTime = currentTime;

            const physicsStart = performance.now();
            const BATCH_SIZE = 1000;
            const particles = STATE.particles;
            const arrays = particles.arrays;
            const dampingRate = deltaTime * deltaTime;

            applyForces(deltaTime);

            for (let start = 0; start < particles.count; start += BATCH_SIZE) {
                const end = Math.min(start + BATCH_SIZE, particles.count);
                processParticleBatch(start, end, arrays, dampingRate, deltaTime);
            }

            STATE.stats.physicsTime = performance.now() - physicsStart;

            updateBuffers(arrays);
            render();

            STATE.stats.drawTime = performance.now() - drawStart;
            STATE.stats.frameCount++;

            if (currentTime - STATE.stats.lastFpsTime >= 1.0) {
                STATE.stats.fps = STATE.stats.frameCount;
                STATE.stats.frameCount = 0;
                STATE.stats.lastFpsTime = currentTime;
                STATE.stats.particleCount = particles.count;

                // Update stats display
                STATE.stats.element.textContent = `
            FPS: ${STATE.stats.fps}
            Particles: ${STATE.stats.particleCount}
            Draw Time: ${STATE.stats.drawTime.toFixed(2)}ms
            Physics Time: ${STATE.stats.physicsTime.toFixed(2)}ms
        `;
            }

            requestAnimationFrame(draw);
        }

        function processParticleBatch(start, end, arrays, dampingRate, deltaTime) {
            const particles = STATE.particles;
            for (let i = start; i < end; i++) {
                const idx = i * 2;
                const dx = arrays.setPoints[idx] - arrays.positions[idx];
                const dy = arrays.setPoints[idx + 1] - arrays.positions[idx + 1];

                arrays.velocities[idx] = arrays.velocities[idx] * arrays.dampings[i] * dampingRate +
                    dx * arrays.accelerations[i] + particles.externalForces[idx];
                arrays.velocities[idx + 1] = arrays.velocities[idx + 1] * arrays.dampings[i] * dampingRate +
                    dy * arrays.accelerations[i] + particles.externalForces[idx + 1];

                arrays.positions[idx] += arrays.velocities[idx] * deltaTime;
                arrays.positions[idx + 1] += arrays.velocities[idx + 1] * deltaTime;

                particles.externalForces[idx] = decayForce(particles.externalForces[idx], deltaTime);
                particles.externalForces[idx + 1] = decayForce(particles.externalForces[idx + 1], deltaTime);
            }
        }


        function render() {
            const gl = STATE.render.gl;

            gl.uniform2f(STATE.render.uniforms.resolution, gl.canvas.width, gl.canvas.height);

            gl.uniform1f(STATE.render.uniforms.glowIntensity, STATE.config.particles.appearance.glow.intensity);
            gl.uniform1f(STATE.render.uniforms.glowSize, STATE.config.particles.appearance.glow.size);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, STATE.particles.arrays.positions, gl.DYNAMIC_DRAW);

            const renderCount = PARTICLE_MODES[STATE.config.behavior.extraParticleMode]?.renderExtras
                ? STATE.particles.count
                : STATE.particles.activeCount;

            gl.drawArrays(gl.POINTS, 0, renderCount);
        }

        // Optimized timer system
        const TIMER = {
            endTime: 0,
            msLeft: 0,
            isFirstTick: true,
            text: "",

            update() {
                this.msLeft = this.endTime - (+new Date);
                const secondsLeft = Math.floor(this.msLeft / 1000);

                if (secondsLeft <= 10 && secondsLeft >= 1) {
                    document.getElementById('tickSound').play();
                }

                if (this.msLeft < 1000) {
                    document.getElementById('timerComplete').play();
                    this.text = STATE.config.text.endText;
                } else {
                    const time = new Date(this.msLeft);
                    const mins = time.getUTCMinutes();
                    this.text = `${mins}:${twoDigits(time.getUTCSeconds())}`;
                    const delay = this.isFirstTick ? 1400 : 1000;
                    this.isFirstTick = false;
                    setTimeout(() => this.update(), delay);
                }

                const { realPointsLength, points } = getTextPoints(this.text, true);
                STATE.particles.activeCount = realPointsLength;

                for (let i = 0; i < STATE.particles.count; i++) {
                    STATE.particles.arrays.setPoints[i * 2] = points[i].x;
                    STATE.particles.arrays.setPoints[i * 2 + 1] = points[i].y;
                }
            },

            start(minutes, seconds) {
                this.endTime = (+new Date) + ((minutes * 60 + seconds) * 1000);
                this.isFirstTick = true;
                this.update();
            }
        };

        function setTime(minutes) {
            document.getElementById('minutes').value = minutes;
            document.getElementById('seconds').value = 0;

            initializeWithConfig(getConfigFromInputs(), minutes, 0);
            TIMER.start(minutes, 0);

            STATE.menu.visible = false;
            document.getElementById('menu').style.display = 'none';
            STATE.timer.running = true;
            requestAnimationFrame(draw);
        }


        // Optimized initialization
        function init() {
            initGL();
            optimizedResize();
            STATE.canvas.rect = STATE.render.canvas.getBoundingClientRect();
            initUI();
            setupEventListeners();
            loadPresets();
            STATE.config = ConfigSchema.createDefault();

            STATE.stats.element = document.createElement('div');
            Object.assign(STATE.stats.element.style, {
                position: 'fixed',
                width: '100vw',
                height: '100vh',
                margin: '0',
                padding: '20px',
                zIndex: '100',
                overflow: 'hidden'
            });
            document.body.appendChild(STATE.stats.element);
        }

        function initUI() {
            const menu = document.getElementById('menu');

            // Add timer controls section
            const timerSection = document.createElement('div');
            timerSection.className = 'section';
            timerSection.innerHTML = `
                <button id="startTimer" style="padding: 10px 20px; margin-top: 20px;">Start Timer</button>
                <h3>Timer Settings</h3>
                <label>Minutes: <input type="number" id="minutes" min="0" value="1"></label>
                <label>Seconds: <input type="number" id="seconds" min="0" max="59" value="0"></label>
                <div style="margin-top: 10px;">
                    <button style="padding: 10px 20px;" onclick="setTime(5)">5 min</button>
                    <button style="padding: 10px 20px;" onclick="setTime(10)">10 min</button>
                    <button style="padding: 10px 20px;" onclick="setTime(20)">20 min</button>
                </div>
            `;
            menu.appendChild(timerSection);

            // Add preset style section
            const presetSection = document.createElement('div');
            presetSection.className = 'section';
            presetSection.innerHTML = `
                <h3>Particle Style</h3>
                <select id="presetStyle">
                    <option value="minimal">Minimal</option>
                    <option value="neon">Neon</option>
                </select>
            `;

            const saveSection = document.createElement('div');
            saveSection.className = 'section';
            saveSection.innerHTML = `
                <h3>Save Configuration</h3>
                <label>Configuration Name: <input type="text" id="configName"></label>
                <button id="saveConfig">Save</button>
            `;

            menu.appendChild(saveSection);
            menu.appendChild(presetSection);

            ConfigSchema.generateUI(menu);

            const paddingDiv = document.createElement('div');
            paddingDiv.style.paddingBottom = '80px';
            menu.appendChild(paddingDiv);
        }


        // Event handlers
        function setupEventListeners() {
            const canvas = STATE.render.canvas;

            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                STATE.menu.visible = true;
                document.getElementById('menu').style.display = 'block';
            });

            document.getElementById('startTimer').addEventListener('click', () => {
                const minutes = parseInt(document.getElementById('minutes').value);
                const seconds = parseInt(document.getElementById('seconds').value);

                initializeWithConfig(getConfigFromInputs(), minutes, seconds);
                TIMER.start(minutes, seconds);
                document.getElementById('menu').style.display = 'none';

                STATE.timer.running = true;
                STATE.menu.visible = false;
                requestAnimationFrame(draw);
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    STATE.menu.visible = false;
                    document.getElementById('menu').style.display = 'none';
                }
            });

            document.getElementById('fullscreenButton').addEventListener('click', () => {
                fetch('https://cdn.jsdelivr.net/gh/lexm2/particle-timer/shadersOptimized.html')
                    .then(response => response.text())
                    .then(html => {
                        const newTab = window.open('', '_blank');
                        newTab.document.write(html);
                        newTab.document.close();
                        newTab.onload = () => {
                            newTab.focus();
                            newTab.document.documentElement.requestFullscreen();
                        };
                    });
            });

            document.getElementById('colorPreset').addEventListener('change', (e) => {
                const colors = COLOR_PRESETS[e.target.value];
                const container = e.target.parentElement;
                updateColorPickers(colors, container);
                STATE.config.particles.appearance.colors = colors;
            });

            window.addEventListener('resize', optimizedResize);

            canvas.addEventListener('mousedown', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.down = true;
            });

            canvas.addEventListener('mouseup', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.down = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (STATE.menu.visible) return;
                const newMouseX = (e.clientX - STATE.canvas.rect.left) / STATE.canvas.rect.width * 2 - 1;
                const newMouseY = -((e.clientY - STATE.canvas.rect.top) / STATE.canvas.rect.height * 2 - 1);

                if (STATE.mouse.down) {
                    STATE.mouse.velocityX = newMouseX - STATE.mouse.x;
                    STATE.mouse.velocityY = newMouseY - STATE.mouse.y;
                }

                STATE.mouse.x = newMouseX;
                STATE.mouse.y = newMouseY;
            });

            canvas.addEventListener('click', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.clicked = true;
            });

            document.getElementById('presetStyle').addEventListener('change', (e) => {
                applyPreset(e.target.value);
            });

            document.getElementById('saveConfig').addEventListener('click', () => {
                const configName = document.getElementById('configName').value;
                if (!configName) return;

                const config = getConfigFromInputs();
                STATE.presets.saved.set(configName, config);

                document.cookie = `${configName}=${JSON.stringify(config)}; expires=${new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toUTCString()}; path=/; SameSite=Strict`;

                loadPresets();
                document.getElementById('configName').value = '';
            });
        }


        function optimizedResize() {
            const pixelRatio = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;

            STATE.render.canvas.width = width * pixelRatio;
            STATE.render.canvas.height = height * pixelRatio;
            STATE.render.canvas.style.width = width + 'px';
            STATE.render.canvas.style.height = height + 'px';

            STATE.render.gl.viewport(0, 0, STATE.render.canvas.width, STATE.render.canvas.height);
            STATE.canvas.aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;
            STATE.canvas.rect = STATE.render.canvas.getBoundingClientRect();
        }

        init();

    </script>
</body>

</html>