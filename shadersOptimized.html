<!DOCTYPE html>
<html>

<head>
    <title>WebGL Particle Timer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
        }

        label {
            display: block;
            margin: 10px 0;
        }

        input,
        select {
            margin-left: 10px;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 3px;
        }

        button {
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }
    </style>
</head>

<body>
    <div id="menu"
        style="position: fixed; width: 100vw; height: 100vh; background: rgba(0,0,0,0.9); color: white; padding: 20px 20px 80px 20px; font-family: Arial; z-index: 1000; overflow-y: auto; overflow-x: hidden;">
        <button id="fullscreenButton"
            style="position: absolute; top: 10px; right: 60px; padding: 10px 20px;">Fullscreen</button>
        <h2>Particle Timer Settings</h2>
    </div>
    <canvas id="glCanvas"></canvas>
    <audio id="tickSound" src="https://assets.mixkit.co/active_storage/sfx/2568/2568.wav"></audio>
    <audio id="timerComplete" src="https://assets.mixkit.co/active_storage/sfx/2865/2865.wav"></audio>

    <script type="x-shader/x-vertex" id="vertex-shader">
        attribute vec2 a_position;
        attribute vec3 a_color;
        attribute float a_size;
        varying vec3 v_color;
    
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            gl_PointSize = a_size;
            v_color = a_color;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragment-shader">
        precision mediump float;
        varying vec3 v_color;
        uniform float u_glow_intensity;
        uniform float u_glow_size;
    
        void main() {
            vec2 coord = gl_PointCoord * 2.0 - 1.0;
            float dist = length(coord);
            
            float core = 1.0 - step(0.5, dist);
            
            float glow = u_glow_intensity > 0.0 ? 
                u_glow_intensity * exp(-dist * (1.0 / u_glow_size)) * (1.0 - dist) : 
                0.0;
            
            float alpha = core + glow;
            gl_FragColor = vec4(v_color, alpha);
        }
    </script>




    <script>
        // Replace the existing COLOR_PRESETS object with this expanded version
        const COLOR_PRESETS = {
            // Original presets
            neonLights: [
                [1.0, 0.0, 1.0],  // Magenta
                [0.0, 1.0, 1.0],  // Cyan
                [1.0, 1.0, 0.0]   // Yellow
            ],
            pastelDream: [
                [0.95, 0.61, 0.73],  // Pink
                [0.56, 0.93, 0.56],  // Mint
                [0.68, 0.85, 0.90],  // Sky
                [0.97, 0.85, 0.45],  // Yellow
                [0.85, 0.75, 0.95]   // Lavender
            ],
            oceanBreeze: [
                [0.29, 0.31, 0.30],  // Dark teal
                [0.05, 0.60, 0.65],  // Turquoise
                [0.24, 0.64, 0.67],  // Sea blue
                [0.96, 0.80, 0.38],  // Sand
                [0.99, 0.54, 0.44]   // Coral
            ],
            sunset: [
                [0.98, 0.37, 0.05],  // Orange-red
                [0.98, 0.64, 0.18],  // Orange
                [0.91, 0.84, 0.42],  // Yellow
                [0.69, 0.19, 0.38],  // Deep purple
                [0.44, 0.28, 0.56]   // Violet
            ],
            cyberpunk: [
                [0.94, 0.21, 0.59],  // Hot pink
                [0.07, 0.91, 0.91],  // Bright cyan
                [0.98, 0.98, 0.06],  // Electric yellow
                [0.6, 0.0, 0.8],     // Purple
                [0.13, 0.05, 0.19]   // Dark purple
            ],
            forestGlade: [
                [0.13, 0.55, 0.13],  // Forest green
                [0.42, 0.56, 0.14],  // Olive
                [0.68, 0.85, 0.32],  // Light green
                [0.88, 0.87, 0.74],  // Beige
                [0.55, 0.27, 0.07]   // Brown
            ],
            retroWave: [
                [0.93, 0.0, 0.54],   // Hot pink
                [0.16, 0.84, 0.99],  // Bright blue
                [0.99, 0.42, 0.52],  // Salmon
                [0.47, 0.04, 0.65],  // Purple
                [0.11, 0.0, 0.31]    // Deep blue
            ],
            candyShop: [
                [0.97, 0.39, 0.53],  // Bubblegum
                [0.99, 0.71, 0.38],  // Orange
                [0.55, 0.93, 0.55],  // Mint
                [0.38, 0.69, 0.96],  // Sky blue
                [0.91, 0.44, 0.99]   // Lavender
            ],
            fireAndIce: [
                [0.99, 0.24, 0.0],   // Fire red
                [0.99, 0.56, 0.0],   // Orange
                [0.0, 0.66, 0.98],   // Ice blue
                [0.0, 0.47, 0.75],   // Blue
                [0.93, 0.9, 0.81]    // Off-white
            ],
            monochrome: [
                [0.0, 0.0, 0.0],     // Black
                [0.2, 0.2, 0.2],     // Dark gray
                [0.4, 0.4, 0.4],     // Gray
                [0.7, 0.7, 0.7],     // Light gray
                [1.0, 1.0, 1.0]      // White
            ],
            tropicalParadise: [
                [0.95, 0.36, 0.25],  // Coral
                [0.16, 0.73, 0.58],  // Teal
                [0.99, 0.85, 0.21],  // Sunshine
                [0.0, 0.6, 0.45],    // Palm
                [0.95, 0.61, 0.07]   // Mango
            ],
            galaxyDust: [
                [0.07, 0.03, 0.15],  // Deep space
                [0.17, 0.05, 0.35],  // Purple space
                [0.19, 0.28, 0.54],  // Cosmic blue
                [0.67, 0.55, 0.85],  // Lavender
                [0.93, 0.89, 0.99]   // Stardust
            ],
            autumnLeaves: [
                [0.55, 0.27, 0.07],  // Brown
                [0.82, 0.33, 0.0],   // Rust
                [0.91, 0.45, 0.0],   // Orange
                [0.99, 0.75, 0.0],   // Golden
                [0.6, 0.2, 0.0]      // Deep red
            ],
            winterFrost: [
                [0.88, 0.94, 0.99],  // Ice white
                [0.69, 0.85, 0.93],  // Pale blue
                [0.5, 0.67, 0.85],   // Cold blue
                [0.26, 0.45, 0.68],  // Winter blue
                [0.13, 0.21, 0.37]   // Deep blue
            ],
            rainbowVibrant: [
                [0.93, 0.11, 0.14],  // Red
                [0.99, 0.59, 0.0],   // Orange
                [0.99, 0.91, 0.0],   // Yellow
                [0.0, 0.75, 0.22],   // Green
                [0.0, 0.51, 0.98],   // Blue
                [0.45, 0.0, 0.88]    // Purple
            ],
            darkMode: [
                [0.13, 0.13, 0.13],  // Dark gray
                [0.2, 0.2, 0.2],     // Medium gray
                [0.33, 0.33, 0.33],  // Gray
                [0.93, 0.93, 0.93],  // Light gray
                [0.0, 0.48, 1.0]     // Accent blue
            ],
            mintChocolate: [
                [0.36, 0.82, 0.55],  // Mint
                [0.2, 0.63, 0.46],   // Dark mint
                [0.37, 0.22, 0.13],  // Chocolate
                [0.23, 0.12, 0.05],  // Dark chocolate
                [0.85, 0.99, 0.85]   // Light mint
            ],
            berryBliss: [
                [0.75, 0.0, 0.19],   // Raspberry
                [0.53, 0.0, 0.27],   // Cranberry
                [0.34, 0.0, 0.25],   // Blackberry
                [0.2, 0.0, 0.36],    // Dark purple
                [0.95, 0.68, 0.79]   // Light pink
            ],
            goldLuxury: [
                [0.83, 0.69, 0.22],  // Gold
                [0.52, 0.39, 0.0],   // Dark gold
                [0.95, 0.87, 0.51],  // Light gold
                [0.13, 0.13, 0.13],  // Black
                [0.93, 0.93, 0.93]   // White
            ],
            marineDeep: [
                [0.0, 0.05, 0.16],   // Deep marine
                [0.0, 0.11, 0.33],   // Dark blue
                [0.0, 0.22, 0.49],   // Navy
                [0.0, 0.46, 0.74],   // Ocean blue
                [0.39, 0.83, 0.96]   // Sky blue
            ],
            cottonCandy: [
                [0.99, 0.62, 0.77],  // Pink
                [0.99, 0.84, 0.92],  // Light pink
                [0.85, 0.65, 0.93],  // Lavender
                [0.69, 0.88, 0.9],   // Light blue
                [0.99, 0.93, 0.64]   // Light yellow
            ],
            electroNight: [
                [0.05, 0.05, 0.05],  // Almost black
                [0.33, 0.0, 0.5],    // Deep purple
                [0.0, 0.4, 0.6],     // Deep blue
                [0.0, 0.8, 0.8],     // Cyan
                [0.0, 1.0, 0.0]      // Neon green
            ]
        };

        // Particle Configuration System
        const ConfigSchema = {
            fields: {
                particles: {
                    position: {
                        min: { type: 'number', min: -2, max: 0, step: 0.1, default: -0.7 },
                        spread: { type: 'number', min: 0, max: 3, step: 0.1, default: 1.2 }
                    },
                    physics: {
                        acceleration: {
                            base: { type: 'number', min: 0, max: 20, step: 0.5, default: 3 },
                            variation: { type: 'number', min: 0, max: 10, step: 0.5, default: 3 }
                        },
                        damping: {
                            base: { type: 'number', min: 0.8, max: 0.999, step: 0.001, default: 0.95 },
                            variation: { type: 'number', min: 0, max: 0.1, step: 0.001, default: 0.04 }
                        }
                    },
                    appearance: {
                        size: {
                            base: { type: 'number', min: 1, max: 20, default: 15 },
                            variation: { type: 'number', min: 0, max: 75, default: 10 }
                        },
                        colors: {
                            type: 'colorArray',
                            presets: COLOR_PRESETS,
                            default: COLOR_PRESETS.oceanBreeze
                        },
                        glow: {
                            intensity: { type: 'number', min: 0.1, max: 10, step: 0.1, default: 0.3 },
                            size: { type: 'number', min: 0.1, max: 10, step: 0.1, default: 2.0 }
                        }
                    },
                    mouseBehavior: {
                        pushForce: { type: 'number', min: 0, max: 5000, default: 1500 },
                        pushRadius: { type: 'number', min: 0, max: 500, default: 100 }
                    },
                },
                text: {
                    size: { type: 'number', min: 100, max: 400, default: 30 },
                    scale: { type: 'number', min: 0.1, max: 2, step: 0.1, default: 0.6 },
                    verticalOffset: { type: 'number', min: -10, max: 10, step: 0.01, default: 1 },
                    endTextScale: { type: 'number', min: 0.1, max: 2, step: 0.1, default: 1 },
                    density: { type: 'number', min: 1, max: 5, default: 1 },
                    endText: { type: 'string', default: 'Time\'s up!' },
                    font: {
                        type: 'select',
                        options: [
                            "Arial", "Courier New", "Georgia", "Times New Roman", "Verdana",
                            "Helvetica", "Impact", "Tahoma", "Trebuchet MS", "Comic Sans MS",
                            "Arial Black", "Lucida Console", "Lucida Sans Unicode", "Palatino Linotype",
                            "Book Antiqua", "Garamond", "MS Sans Serif", "MS Serif"
                        ],
                        default: "Courier New"
                    },
                    isBold: { type: 'boolean', default: true }

                },
                behavior: {
                    ordering: {
                        type: 'select',
                        options: ['vertical', 'horizontal', 'optimized'],
                        default: 'vertical'
                    },
                    radius: { type: 'number', min: 0.5, max: 3, step: 0.1, default: 0.8 },
                    extraParticleMode: {
                        type: 'select',
                        options: ['circle', 'center', 'maintain', 'spiral', 'wave', 'fountain', 'test'],
                        default: 'circle'
                    }
                }
            },

            createDefault() {
                return this.createFromSchema(this.fields);
            },

            createFromSchema(schema) {
                const result = {};
                Object.entries(schema).forEach(([key, value]) => {
                    if (value.type) {
                        result[key] = value.default;
                    } else {
                        result[key] = this.createFromSchema(value);
                    }
                });
                return result;
            },

            generateUI(container) {
                this.buildUIFromSchema(this.fields, container);
            },

            buildUIFromSchema(schema, container, path = '') {
                Object.entries(schema).forEach(([key, value]) => {
                    const currentPath = path ? `${path}.${key}` : key;

                    if (value.type) {
                        container.appendChild(this.createControl(key, value, currentPath));
                    } else {
                        const section = document.createElement('div');
                        section.className = 'section';
                        section.innerHTML = `<h3>${key.charAt(0).toUpperCase() + key.slice(1)}</h3>`;
                        this.buildUIFromSchema(value, section, currentPath);
                        container.appendChild(section);
                    }
                });
            },

            createControl(key, config, path) {
                const label = document.createElement('label');
                label.textContent = key.charAt(0).toUpperCase() + key.slice(1) + ': ';

                const input = this.createInputByType(config);
                input.id = path.replace(/\./g, '_');
                input.dataset.configPath = path;

                label.appendChild(input);
                return label;
            },

            createInputByType(config) {
                let container, select, input, opt;

                switch (config.type) {
                    case 'colorArray':
                        container = document.createElement('div');
                        container.id = 'colorPickers';

                        select = document.createElement('select');
                        select.id = 'colorPreset';
                        Object.keys(COLOR_PRESETS).forEach(presetName => {
                            opt = document.createElement('option');
                            opt.value = presetName;
                            opt.textContent = presetName;
                            select.appendChild(opt);
                        });
                        container.appendChild(select);

                        config.default.forEach(color => {
                            input = document.createElement('input');
                            input.type = 'color';
                            input.className = 'particleColor';
                            input.value = `#${color.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('')}`;
                            container.appendChild(input);
                        });

                        return container;

                    case 'number':
                        input = document.createElement('input');
                        input.type = 'number';
                        input.min = config.min;
                        input.max = config.max;
                        input.step = config.step || 1;
                        input.value = config.default;
                        return input;

                    case 'select':
                        select = document.createElement('select');


                        if (config.options[0] === "Arial") {
                            config.options.forEach(option => {
                                opt = document.createElement('option');
                                opt.value = option;
                                opt.textContent = option;
                                opt.style.fontFamily = option;
                                select.appendChild(opt);
                            });
                        } else {
                            // Regular select handling
                            config.options.forEach(option => {
                                opt = document.createElement('option');
                                opt.value = option;
                                opt.textContent = option;
                                select.appendChild(opt);
                            });
                        }

                        select.value = config.default;
                        return select;
                    case 'string':
                        input = document.createElement('input');
                        input.type = 'text';
                        input.value = config.default;
                        return input;
                    case 'boolean':
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = config.default;
                        return input;
                }
            }
        };

        function detectAvailableFonts(fontArray) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const referenceFont = 'monospace';
            const testString = 'mmmmmmmmmmlli';

            ctx.font = `16px ${referenceFont}`;
            const referenceFontWidth = ctx.measureText(testString).width;

            const availableFonts = fontArray.filter(font => {
                ctx.font = `16px "${font}", ${referenceFont}`;
                const testWidth = ctx.measureText(testString).width;

                return testWidth !== referenceFontWidth;
            });

            if (!availableFonts.includes('Courier New')) {
                availableFonts.unshift('Courier New');
            }

            return availableFonts;
        }

        function updateColorPickers(colors, container) {
            Array.from(container.querySelectorAll('.particleColor')).forEach(picker => picker.remove());

            colors.forEach(color => {
                const input = document.createElement('input');
                input.type = 'color';
                input.className = 'particleColor';
                const hexColor = `#${color.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('')}`;
                input.value = hexColor;
                container.appendChild(input);
            });
        }

        // Core state management
        const STATE = {
            config: null,
            presets: {
                current: null,
                saved: new Map(),
            },
            mouse: {
                x: 0,
                y: 0,
                velocityX: 0,
                velocityY: 0,
                clicked: false,
                down: false
            },
            particles: {
                arrays: null,
                count: 0,
                activeCount: 0,
                previousPoints: new Map(),
                externalForces: null
            },
            render: {
                canvas: null,
                gl: null,
                program: null,
                buffers: {
                    position: null,
                    size: null,
                    color: null
                },
                attributes: {
                    position: null,
                    size: null,
                    color: null
                }
            },
            stats: {
                frameCount: 0,
                lastFpsTime: 0,
                fps: 0,
                element: null
            },
            timer: {
                running: false,
                lastTime: 0
            },
            canvas: {
                rect: null,
                aspectRatio: 1
            },
            menu: {
                visible: true
            }
        };

        const PRESETS = {
            minimal: {
                particles: {
                    position: {
                        min: -0.7,
                        spread: 1.2
                    },
                    physics: {
                        acceleration: {
                            base: 3,
                            variation: 3
                        },
                        damping: {
                            base: 0.95,
                            variation: 0.04
                        }
                    },
                    appearance: {
                        size: {
                            base: 5,
                            variation: 10
                        },
                        colors: COLOR_PRESETS.oceanBreeze,
                        glow: {
                            intensity: 0.3,
                            size: 1.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 1500,
                        pushRadius: 100
                    },
                },
                text: {
                    size: 30,
                    scale: 0.6,
                    density: 1
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "circle",
                    radius: 0.8
                }
            },

            neon: {
                particles: {
                    position: {
                        min: -0.9,
                        spread: 1.8
                    },
                    physics: {
                        acceleration: {
                            base: 5,
                            variation: 5.0
                        },
                        damping: {
                            base: 0.99,
                            variation: 0.005
                        }
                    },
                    appearance: {
                        size: {
                            base: 1,
                            variation: 2.0
                        },
                        colors: COLOR_PRESETS.neonLights,

                        glow: {
                            intensity: 1,
                            size: 1.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 1000,
                        pushRadius: 100
                    },
                },
                text: {
                    size: 280,
                    scale: 1,
                    density: 2
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "center",
                    radius: 2
                }
            },
            sunset: {
                particles: {
                    appearance: {
                        size: {
                            base: 8,
                            variation: 12
                        },
                        colors: COLOR_PRESETS.sunset,
                        glow: {
                            intensity: 0.6,
                            size: 2.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2.5,
                            variation: 2.0
                        },
                        damping: {
                            base: 0.97,
                            variation: 0.02
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "wave",
                    radius: 1.2
                }
            },

            cyberpunk: {
                particles: {
                    appearance: {
                        size: {
                            base: 4,
                            variation: 15
                        },
                        colors: COLOR_PRESETS.cyberpunk,
                        glow: {
                            intensity: 1.8,
                            size: 3.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 5,
                            variation: 4
                        }
                    },
                    mouseBehavior: {
                        pushForce: 2500,
                        pushRadius: 150
                    }
                },
                text: {
                    size: 50,
                    scale: 0.7,
                    density: 1
                },
                behavior: {
                    extraParticleMode: "fountain",
                    radius: 1.5
                }
            },

            forestGlade: {
                particles: {
                    appearance: {
                        size: {
                            base: 6,
                            variation: 8
                        },
                        colors: COLOR_PRESETS.forestGlade,
                        glow: {
                            intensity: 0.2,
                            size: 1.2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2,
                            variation: 1.5
                        },
                        damping: {
                            base: 0.98,
                            variation: 0.01
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "circle"
                }
            },

            retroWave: {
                particles: {
                    appearance: {
                        size: {
                            base: 3,
                            variation: 6
                        },
                        colors: COLOR_PRESETS.retroWave,
                        glow: {
                            intensity: 1.2,
                            size: 2.5
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "wave",
                    radius: 1.0
                }
            },

            candyShop: {
                particles: {
                    appearance: {
                        size: {
                            base: 7,
                            variation: 10
                        },
                        colors: COLOR_PRESETS.candyShop,
                        glow: {
                            intensity: 0.4,
                            size: 1.8
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 3.5,
                            variation: 2.5
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "circle"
                }
            },

            fireAndIce: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 15
                        },
                        colors: COLOR_PRESETS.fireAndIce,
                        glow: {
                            intensity: 0.7,
                            size: 2.2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 4,
                            variation: 3
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "fountain"
                }
            },

            monochrome: {
                particles: {
                    appearance: {
                        size: {
                            base: 3,
                            variation: 3
                        },
                        colors: COLOR_PRESETS.monochrome,
                        glow: {
                            intensity: 0.1,
                            size: 1.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2.5,
                            variation: 1.0
                        },
                        damping: {
                            base: 0.97,
                            variation: 0.01
                        }
                    }
                },
                behavior: {
                    ordering: "optimized"
                }
            },

            tropicalParadise: {
                particles: {
                    appearance: {
                        size: {
                            base: 8,
                            variation: 12
                        },
                        colors: COLOR_PRESETS.tropicalParadise,
                        glow: {
                            intensity: 0.5,
                            size: 2.0
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "circle",
                    radius: 1.2
                }
            },

            galaxyDust: {
                particles: {
                    position: {
                        spread: 1.5
                    },
                    appearance: {
                        size: {
                            base: 2,
                            variation: 18
                        },
                        colors: COLOR_PRESETS.galaxyDust,
                        glow: {
                            intensity: 1.5,
                            size: 3.0
                        }
                    },
                    physics: {
                        damping: {
                            base: 0.99,
                            variation: 0.005
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "spiral",
                    radius: 1.8
                }
            },

            autumnLeaves: {
                particles: {
                    appearance: {
                        size: {
                            base: 6,
                            variation: 8
                        },
                        colors: COLOR_PRESETS.autumnLeaves,
                        glow: {
                            intensity: 0.3,
                            size: 1.5
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2,
                            variation: 2.5
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "wave",
                    radius: 1.1
                }
            },

            winterFrost: {
                particles: {
                    appearance: {
                        size: {
                            base: 4,
                            variation: 6
                        },
                        colors: COLOR_PRESETS.winterFrost,
                        glow: {
                            intensity: 0.8,
                            size: 2.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2,
                            variation: 1.5
                        },
                        damping: {
                            base: 0.96,
                            variation: 0.02
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "circle",
                    radius: 1.0
                }
            },

            rainbowVibrant: {
                particles: {
                    appearance: {
                        size: {
                            base: 7,
                            variation: 10
                        },
                        colors: COLOR_PRESETS.rainbowVibrant,
                        glow: {
                            intensity: 0.6,
                            size: 1.8
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "circle",
                    radius: 1.3
                }
            },

            darkMode: {
                particles: {
                    appearance: {
                        size: {
                            variation: 0
                        },
                        colors: COLOR_PRESETS.darkMode,
                        glow: {
                            intensity: 1,
                            size: 2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 7,
                            variation: 5.0
                        },
                    },
                },
                text: {
                    size: 50,
                    scale: 1,
                },
                behavior: {
                    extraParticleMode: "maintain"
                }
            },

            mintChocolate: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 7
                        },
                        colors: COLOR_PRESETS.mintChocolate,
                        glow: {
                            intensity: 0.3,
                            size: 1.6
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "wave"
                }
            },

            berryBliss: {
                particles: {
                    appearance: {
                        size: {
                            base: 6,
                            variation: 9
                        },
                        colors: COLOR_PRESETS.berryBliss,
                        glow: {
                            intensity: 0.7,
                            size: 2.0
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "spiral",
                    radius: 1.1
                }
            },

            goldLuxury: {
                particles: {
                    appearance: {
                        size: {
                            base: 4,
                            variation: 6
                        },
                        colors: COLOR_PRESETS.goldLuxury,
                        glow: {
                            intensity: 1.1,
                            size: 2.2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2.5,
                            variation: 1.5
                        },
                        damping: {
                            base: 0.97,
                            variation: 0.015
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "circle",
                    radius: 0.9
                }
            },

            marineDeep: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 8
                        },
                        colors: COLOR_PRESETS.marineDeep,
                        glow: {
                            intensity: 0.9,
                            size: 2.4
                        }
                    },
                    physics: {
                        damping: {
                            base: 0.98,
                            variation: 0.01
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "wave",
                    radius: 1.1
                }
            },

            cottonCandy: {
                particles: {
                    appearance: {
                        size: {
                            base: 7,
                            variation: 9
                        },
                        colors: COLOR_PRESETS.cottonCandy,
                        glow: {
                            intensity: 0.4,
                            size: 1.7
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "circle"
                }
            },

            electroNight: {
                particles: {
                    appearance: {
                        size: {
                            base: 3,
                            variation: 12
                        },
                        colors: COLOR_PRESETS.electroNight,
                        glow: {
                            intensity: 2.0,
                            size: 3.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 4,
                            variation: 3
                        }
                    }
                },
                behavior: {
                    extraParticleMode: "spiral",
                    radius: 1.3
                }
            }
        };



        function applyPreset(presetName) {
            let preset = PRESETS[presetName];

            if (!preset && STATE.presets.saved.has(presetName)) {
                preset = STATE.presets.saved.get(presetName);
            }

            // If still no preset found, return
            if (!preset) {
                console.warn(`No preset found with name: ${presetName}`);
                return;
            }

            console.log(`Applying preset: ${presetName}`, preset);

            saveLastUsedConfig(presetName);

            // Set the current config to the selected preset
            STATE.config = Object.assign({}, preset);

            // Update all UI elements with the preset values
            document.querySelectorAll('[data-config-path]').forEach(input => {
                const path = input.dataset.configPath.split('.');
                let value = preset;

                // Navigate down the object path
                for (const key of path) {
                    if (value === undefined || value === null) {
                        console.warn(`Invalid path for ${input.dataset.configPath}, missing: ${key}`);
                        return;
                    }
                    value = value[key];
                }

                if (value === undefined || value === null) {
                    console.warn(`No value found for path: ${input.dataset.configPath}`);
                    return;
                }

                // Special handling for color inputs
                if (input.type === 'color') {
                    input.value = rgbToHex(value);
                } else if (input.type === 'select-one') {
                    input.value = value;
                } else if (input.type === 'number') {
                    input.value = value;
                } else if (input.className === 'particleColor') {
                    // Skip individual color pickers as they'll be handled below
                } else {
                    input.value = value;
                }
            });

            const colorPresetSelect = document.getElementById('colorPreset');
            if (preset.particles && preset.particles.appearance && preset.particles.appearance.colors) {
                const colors = preset.particles.appearance.colors;
                const container = colorPresetSelect.parentElement;

                // Try to find if this matches a built-in color preset
                const matchingPreset = Object.entries(COLOR_PRESETS).find(([_, presetColors]) =>
                    JSON.stringify(presetColors) === JSON.stringify(colors)
                );

                if (matchingPreset) {
                    colorPresetSelect.value = matchingPreset[0];
                }

                // Update the actual color pickers
                updateColorPickers(colors, container);
            }

            console.log("Preset applied successfully");
        }

        function rgbToHex(rgbArray) {
            if (!Array.isArray(rgbArray) || rgbArray.length < 3) {
                console.warn("Invalid RGB array:", rgbArray);
                return "#FFFFFF";
            }

            return '#' + rgbArray.map(component => {
                const hex = Math.round(component * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        const StorageUtils = {
            set: function (name, value) {
                try {
                    const serialized = JSON.stringify(value);
                    localStorage.setItem(name, serialized);
                    return true;
                } catch (e) {
                    console.error('Error saving to localStorage:', e);
                    return false;
                }
            },

            get: function (name) {
                try {
                    const serialized = localStorage.getItem(name);
                    if (serialized === null) return null;
                    return JSON.parse(serialized);
                } catch (e) {
                    console.error('Error retrieving from localStorage:', e);
                    return null;
                }
            },

            delete: function (name) {
                localStorage.removeItem(name);
            },

            getAllKeys: function () {
                return Object.keys(localStorage).filter(key =>
                    key.startsWith('particle_timer_preset_'));
            }
        };

        function saveLastUsedConfig(configName) {
            try {
                localStorage.setItem('particle_timer_last_config', configName);
                console.log(`Saved "${configName}" as last used config`);
            } catch (e) {
                console.error('Error saving last used config:', e);
            }
        }

        function loadLastUsedConfig() {
            try {
                const lastConfig = localStorage.getItem('particle_timer_last_config');
                if (lastConfig) {
                    console.log(`Found last used config: "${lastConfig}"`);

                    setTimeout(() => {
                        const presetSelect = document.getElementById('presetStyle');

                        let configExists = false;
                        for (let i = 0; i < presetSelect.options.length; i++) {
                            if (presetSelect.options[i].value === lastConfig) {
                                presetSelect.selectedIndex = i;
                                configExists = true;
                                break;
                            }
                        }

                        if (configExists) {
                            console.log(`Applying last used config: "${lastConfig}"`);
                            applyPreset(lastConfig);
                        } else {
                            console.log(`Last config "${lastConfig}" not found, using default`);
                        }
                    }, 100);
                }
            } catch (e) {
                console.error('Error loading last used config:', e);
            }
        }

        function loadPresets() {
            // Load default presets into state
            Object.entries(PRESETS).forEach(([name, config]) => {
                STATE.presets.saved.set(name, config);
            });

            console.log('Loading saved presets...');

            // Get all preset keys from localStorage
            const presetKeys = StorageUtils.getAllKeys();

            presetKeys.forEach(fullKey => {
                try {
                    const config = StorageUtils.get(fullKey);
                    if (!config) return;

                    // Remove the prefix to get the actual name
                    const name = fullKey.replace('particle_timer_preset_', '');

                    STATE.presets.saved.set(name, config);

                    // Add to preset selector if it doesn't exist
                    const presetSelect = document.getElementById('presetStyle');
                    if (presetSelect && !Array.from(presetSelect.options).some(opt => opt.value === name)) {
                        const opt = document.createElement('option');
                        opt.value = name;
                        opt.textContent = name;
                        presetSelect.appendChild(opt);
                        console.log(`Added ${name} to preset selector`);
                    }

                    console.log(`Successfully loaded saved preset: ${name}`);
                } catch (e) {
                    console.warn('Error loading preset:', fullKey, e);
                }
            });

            console.log('Available presets after loading:', Array.from(STATE.presets.saved.keys()));
        }


        function initializeWithConfig(newConfig, minutes, seconds) {
            Object.assign(STATE.config, newConfig);

            const maxPoints = Math.max(
                getTextPoints(findLargestAreaTime(minutes, seconds), false).realPointsLength,
                getTextPoints(STATE.config.text.endText, false).realPointsLength
            );

            STATE.particles.count = maxPoints;
            STATE.particles.arrays = createParticleArrays(maxPoints);
            STATE.particles.externalForces = new Float32Array(maxPoints * 2);

            initializeParticles(STATE.particles.arrays, 0, maxPoints);
            updateBuffers(STATE.particles.arrays);
        }

        function findLargestAreaTime(minutes, seconds) {
            const digitScores = {};
            for (let i = 0; i <= 9; i++) {
                digitScores[i] = getTextPoints(i.toString(), false).realPointsLength;
            }

            let maxScore = 0;
            let maxAreaTime = null;

            for (let m = minutes; m >= 0; m--) {
                const maxSecs = m === minutes ? seconds : 59;
                const minSecs = m === 0 ? 1 : 0;

                for (let s = maxSecs; s >= minSecs; s--) {
                    const timeDigits = `${m}${s.toString().padStart(2, '0')}`.split('').map(Number);
                    const score = timeDigits.reduce((sum, digit) => sum + digitScores[digit], 0);

                    if (score > maxScore) {
                        maxScore = score;
                        maxAreaTime = `${m}:${s.toString().padStart(2, '0')}`;
                    }
                }
            }

            return maxAreaTime;
        }

        function getConfigFromInputs() {
            const config = ConfigSchema.createDefault();

            document.querySelectorAll('[data-config-path]').forEach(input => {
                const path = input.dataset.configPath.split('.');
                let target = config;

                // Navigate to the correct nested object
                for (let i = 0; i < path.length - 1; i++) {
                    target = target[path[i]];
                }

                const key = path[path.length - 1];
                if (key === 'colors') {
                    // Handle color array specially
                    target[key] = Array.from(document.querySelectorAll('.particleColor')).map(cp => {
                        const hex = cp.value;
                        return [
                            parseInt(hex.slice(1, 3), 16) / 255,
                            parseInt(hex.slice(3, 5), 16) / 255,
                            parseInt(hex.slice(5, 7), 16) / 255
                        ];
                    });
                } else if (input.type === 'number') {
                    target[key] = parseFloat(input.value);
                } else {
                    target[key] = input.value;
                }
            });

            return config;
        }


        // Helper functions
        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function twoDigits(n) {
            return (n < 10 ? '0' : '') + n;
        }


        // Initialize WebGL
        function initGL() {
            STATE.render.canvas = document.getElementById('glCanvas');
            STATE.render.gl = STATE.render.canvas.getContext('webgl', {
                antialias: false,
                depth: false,
                alpha: false,
                preserveDrawingBuffer: false
            });

            const gl = STATE.render.gl;

            // Compile shaders
            const vertexShader = compileShader(gl, gl.VERTEX_SHADER,
                document.getElementById('vertex-shader').textContent);
            const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER,
                document.getElementById('fragment-shader').textContent);

            // Create and link program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            STATE.render.program = program;
            STATE.render.uniforms = {
                glowIntensity: gl.getUniformLocation(program, 'u_glow_intensity')
            };
            STATE.render.uniforms.resolution = gl.getUniformLocation(program, 'u_resolution')
            STATE.render.uniforms.glowSize = gl.getUniformLocation(program, 'u_glow_size');

            // Initialize buffers
            STATE.render.buffers.position = gl.createBuffer();
            STATE.render.buffers.size = gl.createBuffer();
            STATE.render.buffers.color = gl.createBuffer();

            // Cache attribute locations
            STATE.render.attributes.position = gl.getAttribLocation(program, 'a_position');
            STATE.render.attributes.size = gl.getAttribLocation(program, 'a_size');
            STATE.render.attributes.color = gl.getAttribLocation(program, 'a_color');

            // Enable attributes
            gl.enableVertexAttribArray(STATE.render.attributes.position);
            gl.enableVertexAttribArray(STATE.render.attributes.size);
            gl.enableVertexAttribArray(STATE.render.attributes.color);

            // Set up vertex attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.position);
            gl.vertexAttribPointer(STATE.render.attributes.position, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.size);
            gl.vertexAttribPointer(STATE.render.attributes.size, 1, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.color);
            gl.vertexAttribPointer(STATE.render.attributes.color, 3, gl.FLOAT, false, 0, 0);

            // Set up blending
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }


        // Optimized particle array creation
        function createParticleArrays(count) {
            return {
                positions: new Float32Array(count * 2),
                velocities: new Float32Array(count * 2),
                setPoints: new Float32Array(count * 2),
                accelerations: new Float32Array(count),
                dampings: new Float32Array(count),
                particleSizes: new Float32Array(count),
                particleColors: new Float32Array(count * 3)
            };
        }

        // Optimized particle initialization
        function initializeParticles(arrays, startIndex, endIndex) {
            const config = STATE.config;
            for (let i = startIndex; i < endIndex; i++) {
                const posIndex = i * 2;
                const colorIndex = i * 3;

                arrays.positions[posIndex] = Math.random() * config.particles.position.spread + config.particles.position.min;
                arrays.positions[posIndex + 1] = Math.random() * config.particles.position.spread + config.particles.position.min;

                arrays.velocities[posIndex] = 0;
                arrays.velocities[posIndex + 1] = 0;

                arrays.setPoints[posIndex] = 0;
                arrays.setPoints[posIndex + 1] = 0;

                arrays.accelerations[i] = Math.max(
                    config.particles.physics.acceleration.base +
                    Math.random() * config.particles.physics.acceleration.variation,
                    0.0001
                );

                arrays.dampings[i] = Math.min(
                    config.particles.physics.damping.base +
                    Math.random() * config.particles.physics.damping.variation,
                    0.9999
                );

                arrays.particleSizes[i] = config.particles.appearance.size.base +
                    Math.random() * config.particles.appearance.size.variation;

                const randomColor = config.particles.appearance.colors[
                    Math.floor(Math.random() * config.particles.appearance.colors.length)
                ];
                arrays.particleColors[colorIndex] = randomColor[0];
                arrays.particleColors[colorIndex + 1] = randomColor[1];
                arrays.particleColors[colorIndex + 2] = randomColor[2];
            }
        }

        // Optimized buffer updates
        function updateBuffers(arrays) {
            const gl = STATE.render.gl;
            const buffers = STATE.render.buffers;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.positions, gl.DYNAMIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.size);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.particleSizes, gl.STATIC_DRAW);

            const colorArray = new Float32Array(arrays.particleColors);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
            gl.bufferData(gl.ARRAY_BUFFER, colorArray, gl.STATIC_DRAW);
        }

        // Optimized particle modes
        const PARTICLE_MODES = {
            getMode(modeName) {
                return PARTICLE_MODES[modeName] || PARTICLE_MODES.center;
            },
            initializeMode(mode, points, remainingPoints) {
                const initFn = PARTICLE_MODES.getMode(mode).init;
                if (initFn) initFn(points, remainingPoints);
            },
            circle: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const radius = STATE.config.behavior.radius;
                    const aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;
                    for (let i = 0; i < remainingPoints; i++) {
                        const angle = i * (2 * Math.PI / remainingPoints);
                        points.push({
                            x: Math.cos(angle) * radius,
                            y: Math.sin(angle) * radius * aspectRatio
                        });
                    }
                }
            },
            center: {
                renderExtras: false,
                init: (points, remainingPoints) => {
                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({ x: 0, y: 0 });
                    }
                }
            },
            spiral: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const spiralRadius = STATE.config.behavior.radius;
                    const spiralTurns = 3;
                    const aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;

                    for (let i = 0; i < remainingPoints; i++) {
                        const distance = (i / remainingPoints) * spiralRadius;
                        const angle = i * (2 * Math.PI * spiralTurns / remainingPoints);
                        points.push({
                            x: Math.cos(angle) * distance,
                            y: Math.sin(angle) * distance * aspectRatio
                        });
                    }
                }
            },
            wave: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const radius = STATE.config.behavior.radius;
                    const waveAmplitude = radius * 0.5;
                    const waveFrequency = 5;
                    const aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;

                    for (let i = 0; i < remainingPoints; i++) {
                        const x = ((i / remainingPoints) * 2 - 1) * radius;
                        points.push({
                            x: x,
                            y: Math.sin(x * waveFrequency / radius) * waveAmplitude * aspectRatio
                        });
                    }
                }
            },
            fountain: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const radius = STATE.config.behavior.radius;
                    const fountainBase = -0.8;
                    const aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;

                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({
                            x: (Math.random() * 2 - 1) * radius * 0.5,
                            y: fountainBase * aspectRatio
                        });
                    }
                }
            },
            test: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    for (let i = 0; i < remainingPoints; i++) {
                        points.push({
                            x: -1,
                            y: 1
                        });
                    }
                }
            },
            maintain: {
                renderExtras: true,
                init: (points, remainingPoints) => {
                    const radius = STATE.config.behavior.radius * 3;

                    for (let i = 0; i < remainingPoints; i++) {
                        const angle = i * (2 * Math.PI / remainingPoints);
                        points.push({
                            x: Math.cos(angle) * radius,
                            y: Math.sin(angle) * radius
                        });
                    }
                }
            }
        };

        // Optimized force application and physics
        function applyForces(deltaTime) {
            const mouse = STATE.mouse;
            const particles = STATE.particles;
            const canvas = STATE.render.canvas;

            const mousePixelX = STATE.mouse.x * canvas.width / 2;
            const mousePixelY = STATE.mouse.y * canvas.height / 2;

            const pushForce = STATE.config.particles.mouseBehavior.pushForce;
            const pushRadius = STATE.config.particles.mouseBehavior.pushRadius; // In pixels

            if (mouse.down) {
                for (let i = 0; i < particles.count; i++) {
                    const particleX = particles.arrays.positions[i * 2] * canvas.width / 2;
                    const particleY = particles.arrays.positions[i * 2 + 1] * canvas.height / 2;

                    const dx = particleX - mousePixelX;
                    const dy = particleY - mousePixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius) {
                        const normalX = dx / distance;
                        const normalY = dy / distance;

                        // Direct outward force
                        const forceX = normalX * pushForce ** 2;
                        const forceY = normalY * pushForce ** 2;

                        const forceMagnitude = (1 - distance / pushRadius);
                        particles.externalForces[i * 2] = forceX * forceMagnitude / canvas.width;
                        particles.externalForces[i * 2 + 1] = forceY * forceMagnitude / canvas.height;
                    }
                }
            }

            if (STATE.mouse.clicked) {
                for (let i = 0; i < particles.count; i++) {
                    const particleX = particles.arrays.positions[i * 2] * canvas.width / 2;
                    const particleY = particles.arrays.positions[i * 2 + 1] * canvas.height / 2;

                    const dx = particleX - mousePixelX;
                    const dy = particleY - mousePixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius) {
                        const force = (1 - distance / pushRadius) * pushForce;
                        const normalizedDx = dx / canvas.width;
                        const normalizedDy = dy / canvas.height;
                        particles.externalForces[i * 2] = normalizedDx * force;
                        particles.externalForces[i * 2 + 1] = -normalizedDy * force;
                    }
                }
                STATE.mouse.clicked = false;
            }
        }

        function decayForce(force, deltaTime) {
            return Math.abs(force) > 0.01 ? force * Math.exp(-deltaTime * 5) : 0;
        }


        function getTextPoints(text, addExtraPoints = true) {
            const points = getOrderedPoints(text);
            const realPointsLength = points.length;

            if (addExtraPoints) {
                const mode = PARTICLE_MODES[STATE.config.behavior.extraParticleMode];
                const remainingPoints = STATE.particles.count - points.length;

                if (mode) {
                    mode.init(points, remainingPoints);
                }
            }

            STATE.particles.previousPoints.clear();
            points.forEach((point, index) => {
                const key = `${point.x},${point.y}`;
                STATE.particles.previousPoints.set(key, index);
            });

            return { realPointsLength, points };
        }

        function getOrderedPoints(text) {
            const density = STATE.config.text.density;
            const textSize = STATE.config.text.size;
            const textScale = STATE.config.text.scale;
            const endTextScale = STATE.config.text.endTextScale;
            const selectedFont = STATE.config.text.font;
            const isBold = STATE.config.text.isBold;
            const fontWeight = isBold ? 'bold' : 'normal';

            const textCanvas = document.createElement('canvas');
            const ctx = textCanvas.getContext('2d');

            // Use a monospace font for consistent character widths
            ctx.font = `${fontWeight} ${textSize}px "${selectedFont}"`;

            const isTimeFormat = /^\d+:\d+$/.test(text);

            // Set a reference aspect ratio to maintain consistent proportions
            const referenceWidth = ctx.measureText("8:88").width;
            const referenceHeight = textSize;
            const referenceAspectRatio = referenceWidth / referenceHeight;

            let canvasWidth, canvasHeight, scaleFactor;

            if (isTimeFormat) {
                // Time format - use fixed width based on maximum possible time
                const maxWidthMetrics = ctx.measureText("9:99");
                const maxWidth = maxWidthMetrics.width;
                const padding = maxWidth * 0.1; // 10% padding

                canvasWidth = maxWidth + padding * 2;
                canvasHeight = textSize * 1.5; // Enough height with some padding

                // Scale factor remains 1.0 for time format as it's our reference
                scaleFactor = textScale;
            } else {
                // End text - maintain aspect ratio relative to the reference
                const endTextMetrics = ctx.measureText(text);
                const endTextWidth = endTextMetrics.width;
                const endTextPadding = endTextWidth * 0.1; // 10% padding

                canvasWidth = endTextWidth + endTextPadding * 2;
                canvasHeight = textSize * 1.5;

                // Calculate a scale factor that maintains aspect ratio
                // This ensures the end text has the same proportions as the timer
                const endTextAspectRatio = canvasWidth / canvasHeight;
                scaleFactor = endTextScale * (referenceAspectRatio / endTextAspectRatio);
            }

            // Set canvas dimensions
            textCanvas.width = canvasWidth;
            textCanvas.height = canvasHeight;

            // Reset context after canvas resize
            ctx.font = `${fontWeight} ${textSize}px "${selectedFont}"`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

            // Generate points from the canvas pixels
            const points = [];
            const imageData = ctx.getImageData(0, 0, textCanvas.width, textCanvas.height).data;

            // Calculate x and y scale factors to maintain aspect ratio
            const xScale = isTimeFormat ? textScale : endTextScale;
            const yScale = xScale; // Use same scale to maintain aspect ratio

            switch (STATE.config.behavior.ordering) {
                case 'vertical':
                    for (let x = 0; x < textCanvas.width; x += density) {
                        for (let y = 0; y < textCanvas.height; y += density) {
                            if (imageData[(y * textCanvas.width + x) * 4 + 3] > 128) {
                                points.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * xScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * yScale
                                });
                            }
                        }
                    }
                    break;

                case 'horizontal':
                    for (let y = 0; y < textCanvas.height; y += density) {
                        for (let x = 0; x < textCanvas.width; x += density) {
                            if (imageData[(y * textCanvas.width + x) * 4 + 3] > 128) {
                                points.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * xScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * yScale
                                });
                            }
                        }
                    }
                    break;

                case 'optimized':
                    const validPixels = [];
                    for (let x = 0; x < textCanvas.width; x += density) {
                        for (let y = 0; y < textCanvas.height; y += density) {
                            if (imageData[(y * textCanvas.width + x) * 4 + 3] > 128) {
                                validPixels.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * xScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * yScale
                                });
                            }
                        }
                    }

                    // Rest of optimized case remains the same...
                    if (STATE.particles.previousPoints.size === 0) {
                        return validPixels;
                    }

                    const result = new Array(validPixels.length);
                    const usedPoints = new Set();
                    const unassignedIndices = new Set(Array.from({ length: validPixels.length }, (_, i) => i));

                    validPixels.forEach((point, i) => {
                        const key = `${point.x},${point.y}`;
                        const previousIndex = STATE.particles.previousPoints.get(key);

                        if (previousIndex !== undefined && previousIndex < validPixels.length) {
                            result[previousIndex] = point;
                            usedPoints.add(i);
                            unassignedIndices.delete(previousIndex);
                        }
                    });

                    const remainingPoints = validPixels.filter((_, i) => !usedPoints.has(i));
                    Array.from(unassignedIndices).forEach((index, i) => {
                        result[index] = remainingPoints[i];
                    });

                    return result;
            }

            return points;
        }



        // Optimized rendering loop
        function draw(currentTime) {
            if (!STATE.timer.running) return;

            const drawStart = performance.now();
            currentTime *= 0.001;
            const deltaTime = Math.min(currentTime - STATE.timer.lastTime, 0.1);
            STATE.timer.lastTime = currentTime;

            const physicsStart = performance.now();
            const BATCH_SIZE = 1000;
            const particles = STATE.particles;
            const arrays = particles.arrays;
            const dampingRate = deltaTime * deltaTime;

            applyForces(deltaTime);

            for (let start = 0; start < particles.count; start += BATCH_SIZE) {
                const end = Math.min(start + BATCH_SIZE, particles.count);
                processParticleBatch(start, end, arrays, dampingRate, deltaTime);
            }

            STATE.stats.physicsTime = performance.now() - physicsStart;

            updateBuffers(arrays);
            render();

            STATE.stats.drawTime = performance.now() - drawStart;
            STATE.stats.frameCount++;

            if (currentTime - STATE.stats.lastFpsTime >= 1.0) {
                STATE.stats.fps = STATE.stats.frameCount;
                STATE.stats.frameCount = 0;
                STATE.stats.lastFpsTime = currentTime;
                STATE.stats.particleCount = particles.count;

                // Update stats display
                STATE.stats.element.textContent = `
            FPS: ${STATE.stats.fps}
            Particles: ${STATE.stats.particleCount}
            Draw Time: ${STATE.stats.drawTime.toFixed(2)}ms
            Physics Time: ${STATE.stats.physicsTime.toFixed(2)}ms
        `;
            }

            requestAnimationFrame(draw);
        }

        function processParticleBatch(start, end, arrays, dampingRate, deltaTime) {
            const particles = STATE.particles;
            for (let i = start; i < end; i++) {
                const idx = i * 2;
                const dx = arrays.setPoints[idx] - arrays.positions[idx];
                const dy = arrays.setPoints[idx + 1] - arrays.positions[idx + 1];

                arrays.velocities[idx] = arrays.velocities[idx] * arrays.dampings[i] * dampingRate +
                    dx * arrays.accelerations[i] + particles.externalForces[idx];
                arrays.velocities[idx + 1] = arrays.velocities[idx + 1] * arrays.dampings[i] * dampingRate +
                    dy * arrays.accelerations[i] + particles.externalForces[idx + 1];

                arrays.positions[idx] += arrays.velocities[idx] * deltaTime;
                arrays.positions[idx + 1] += arrays.velocities[idx + 1] * deltaTime;

                particles.externalForces[idx] = decayForce(particles.externalForces[idx], deltaTime);
                particles.externalForces[idx + 1] = decayForce(particles.externalForces[idx + 1], deltaTime);
            }
        }


        function render() {
            const gl = STATE.render.gl;

            gl.uniform2f(STATE.render.uniforms.resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(STATE.render.uniforms.glowIntensity, STATE.config.particles.appearance.glow.intensity);
            gl.uniform1f(STATE.render.uniforms.glowSize, STATE.config.particles.appearance.glow.size);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, STATE.particles.arrays.positions, gl.DYNAMIC_DRAW);

            const mode = PARTICLE_MODES[STATE.config.behavior.extraParticleMode];

            if (mode?.renderExtras && STATE.particles.activeCount < STATE.particles.count) {
                gl.drawArrays(gl.POINTS, STATE.particles.activeCount, STATE.particles.count - STATE.particles.activeCount);
                gl.drawArrays(gl.POINTS, 0, STATE.particles.activeCount);
            } else {
                gl.drawArrays(gl.POINTS, 0, STATE.particles.activeCount);
            }
        }

        // Optimized timer system
        const TIMER = {
            endTime: 0,
            msLeft: 0,
            isFirstTick: true,
            text: "",

            update() {
                this.msLeft = this.endTime - (+new Date);
                const secondsLeft = Math.floor(this.msLeft / 1000);

                if (secondsLeft <= 10 && secondsLeft >= 1) {
                    document.getElementById('tickSound').play();
                }

                if (this.msLeft < 1000) {
                    document.getElementById('timerComplete').play();
                    this.text = STATE.config.text.endText;
                } else {
                    const time = new Date(this.msLeft);
                    const mins = time.getUTCMinutes();
                    this.text = `${mins}:${twoDigits(time.getUTCSeconds())}`;
                    const delay = this.isFirstTick ? 1400 : 1000;
                    this.isFirstTick = false;
                    setTimeout(() => this.update(), delay);
                }

                const { realPointsLength, points } = getTextPoints(this.text, true);
                STATE.particles.activeCount = realPointsLength;

                for (let i = 0; i < STATE.particles.count; i++) {
                    STATE.particles.arrays.setPoints[i * 2] = points[i].x;
                    STATE.particles.arrays.setPoints[i * 2 + 1] = points[i].y;
                }
            },

            start(minutes, seconds) {
                this.endTime = (+new Date) + ((minutes * 60 + seconds) * 1000);
                this.isFirstTick = true;
                this.update();
            }
        };

        function setTime(minutes) {
            document.getElementById('minutes').value = minutes;
            document.getElementById('seconds').value = 0;

            initializeWithConfig(getConfigFromInputs(), minutes, 0);
            TIMER.start(minutes, 0);

            STATE.menu.visible = false;
            document.getElementById('menu').style.display = 'none';
            STATE.timer.running = true;
            requestAnimationFrame(draw);
        }


        // Optimized initialization
        function init() {
            initGL();
            optimizedResize();
            STATE.canvas.rect = STATE.render.canvas.getBoundingClientRect();
            initUI();
            setupEventListeners();
            loadPresets();
            STATE.config = ConfigSchema.createDefault();

            loadLastUsedConfig();

            STATE.stats.element = document.createElement('div');
            Object.assign(STATE.stats.element.style, {
                position: 'fixed',
                width: '100vw',
                height: '100vh',
                margin: '0',
                padding: '20px',
                zIndex: '100',
                overflow: 'hidden'
            });
            document.body.appendChild(STATE.stats.element);
        }

        function initUI() {
            const menu = document.getElementById('menu');

            // Add timer controls section
            const timerSection = document.createElement('div');
            timerSection.className = 'section';
            timerSection.innerHTML = `
                <button id="startTimer" style="padding: 10px 20px; margin-top: 20px;">Start Timer</button>
                <h3>Timer Settings</h3>
                <label>Minutes: <input type="number" id="minutes" min="0" value="1"></label>
                <label>Seconds: <input type="number" id="seconds" min="0" max="59" value="0"></label>
                <div style="margin-top: 10px;">
                    <button style="padding: 10px 20px;" onclick="setTime(5)">5 min</button>
                    <button style="padding: 10px 20px;" onclick="setTime(10)">10 min</button>
                    <button style="padding: 10px 20px;" onclick="setTime(20)">20 min</button>
                </div>
            `;
            menu.appendChild(timerSection);

            // Add preset style section
            const presetSection = document.createElement('div');
            presetSection.className = 'section';
            presetSection.innerHTML = `
                <h3>Particle Style</h3>
                <div style="display: flex; align-items: center; margin-bottom: 10px; max-width: 300px;">
                    <select id="presetStyle" style="width: auto; min-width: 150px; margin-right: 10px;">
                        <!-- Options will be added dynamically -->
                    </select>
                    <button id="deletePreset" style="background: #d44; padding: 5px 10px;">Delete</button>
                </div>
                <div id="presetInfo" style="font-size: 0.8em; font-style: italic; margin-bottom: 10px;">
                    Built-in presets cannot be deleted.
                </div>
            `;

            menu.appendChild(presetSection);

            const presetSelect = document.getElementById('presetStyle');

            Object.keys(PRESETS).forEach(presetName => {
                const option = document.createElement('option');
                option.value = presetName;

                const displayName = presetName
                    .replace(/([A-Z])/g, ' $1')
                    .replace(/^./, str => str.toUpperCase());

                option.textContent = displayName;
                presetSelect.appendChild(option);
            });


            const saveSection = document.createElement('div');
            saveSection.className = 'section';
            saveSection.innerHTML = `
                <h3>Save Configuration</h3>
                <label>Configuration Name: <input type="text" id="configName"></label>
                <button id="saveConfig">Save</button>
            `;

            menu.appendChild(saveSection);

            ConfigSchema.generateUI(menu);

            const paddingDiv = document.createElement('div');
            paddingDiv.style.paddingBottom = '80px';
            menu.appendChild(paddingDiv);
        }


        // Event handlers
        function setupEventListeners() {
            const canvas = STATE.render.canvas;

            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                STATE.menu.visible = true;
                document.getElementById('menu').style.display = 'block';
            });

            document.getElementById('startTimer').addEventListener('click', () => {
                const minutes = parseInt(document.getElementById('minutes').value);
                const seconds = parseInt(document.getElementById('seconds').value);

                initializeWithConfig(getConfigFromInputs(), minutes, seconds);
                TIMER.start(minutes, seconds);
                document.getElementById('menu').style.display = 'none';

                STATE.timer.running = true;
                STATE.menu.visible = false;
                requestAnimationFrame(draw);
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    STATE.menu.visible = false;
                    document.getElementById('menu').style.display = 'none';
                }
            });

            document.getElementById('fullscreenButton').addEventListener('click', () => {
                window.open('https://htmlpreview.github.io/?https://github.com/lexm2/particle-timer/blob/main/shadersOptimized.html', '_blank');
            });


            document.getElementById('colorPreset').addEventListener('change', (e) => {
                const colors = COLOR_PRESETS[e.target.value];
                const container = e.target.parentElement;
                updateColorPickers(colors, container);
                STATE.config.particles.appearance.colors = colors;
            });

            window.addEventListener('resize', optimizedResize);

            canvas.addEventListener('mousedown', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.down = true;
            });

            canvas.addEventListener('mouseup', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.down = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (STATE.menu.visible) return;
                const newMouseX = (e.clientX - STATE.canvas.rect.left) / STATE.canvas.rect.width * 2 - 1;
                const newMouseY = -((e.clientY - STATE.canvas.rect.top) / STATE.canvas.rect.height * 2 - 1);

                if (STATE.mouse.down) {
                    STATE.mouse.velocityX = newMouseX - STATE.mouse.x;
                    STATE.mouse.velocityY = newMouseY - STATE.mouse.y;
                }

                STATE.mouse.x = newMouseX;
                STATE.mouse.y = newMouseY;
            });

            canvas.addEventListener('click', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.clicked = true;
            });

            document.getElementById('presetStyle').addEventListener('change', (e) => {
                applyPreset(e.target.value);
            });

            document.getElementById('deletePreset').addEventListener('click', () => {
                const presetSelect = document.getElementById('presetStyle');
                const selectedPreset = presetSelect.value;

                if (Object.keys(PRESETS).includes(selectedPreset)) {
                    alert('Cannot delete built-in presets.');
                    return;
                }

                if (confirm(`Are you sure you want to delete the preset "${selectedPreset}"?`)) {
                    localStorage.removeItem('particle_timer_preset_' + selectedPreset);

                    STATE.presets.saved.delete(selectedPreset);

                    for (let i = 0; i < presetSelect.options.length; i++) {
                        if (presetSelect.options[i].value === selectedPreset) {
                            presetSelect.remove(i);
                            break;
                        }
                    }

                    presetSelect.selectedIndex = 0;
                    applyPreset(presetSelect.value);

                    console.log(`Deleted preset: ${selectedPreset}`);
                }
            });

            document.getElementById('saveConfig').addEventListener('click', () => {
                const configName = document.getElementById('configName').value;
                if (!configName) {
                    alert('Please enter a configuration name');
                    return;
                }

                const config = getConfigFromInputs();
                const storageName = 'particle_timer_preset_' + configName;

                saveLastUsedConfig(configName);

                STATE.presets.saved.set(configName, config);

                if (StorageUtils.set(storageName, config)) {
                    console.log(`Configuration "${configName}" saved successfully`);
                    // Optional: Show feedback to user
                    alert(`Configuration "${configName}" saved successfully`);
                } else {
                    alert('Failed to save configuration');
                }

                loadPresets();
                document.getElementById('configName').value = '';
            });

            const fontSelect = document.getElementById('text_font');
            if (fontSelect) {
                fontSelect.addEventListener('change', function () {
                    const fontPath = this.dataset.configPath;
                    const pathParts = fontPath.split('.');
                    let target = STATE.config;

                    for (let i = 0; i < pathParts.length - 1; i++) {
                        target = target[pathParts[i]];
                    }

                    target[pathParts[pathParts.length - 1]] = this.value;

                    if (STATE.timer.running) {
                        TIMER.update();
                    }
                });
            }

            const boldToggle = document.getElementById('text_isBold');
            if (boldToggle) {
                boldToggle.addEventListener('change', function () {
                    STATE.config.text.isBold = this.checked;
                    if (STATE.timer.running) {
                        TIMER.update();
                    }
                });
            }
        }


        function optimizedResize() {
            const pixelRatio = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;

            STATE.render.canvas.width = width * pixelRatio;
            STATE.render.canvas.height = height * pixelRatio;
            STATE.render.canvas.style.width = width + 'px';
            STATE.render.canvas.style.height = height + 'px';

            STATE.render.gl.viewport(0, 0, STATE.render.canvas.width, STATE.render.canvas.height);
            STATE.canvas.aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;
            STATE.canvas.rect = STATE.render.canvas.getBoundingClientRect();
        }

        init();

    </script>
</body>

</html>