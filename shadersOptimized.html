<!DOCTYPE html>
<html>

<head>
    <title>WebGL Particle Timer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
        }

        label {
            display: block;
            margin: 10px 0;
        }

        input,
        select {
            margin-left: 10px;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 3px;
        }

        button {
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }

        #pauseButton {
            transition: transform 0.3s ease !important;
            display: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #pauseButton:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }

        .pause-line {
            border-radius: 2px;
        }

        #pauseButton.play .pause-line.left {
            transform: translate(35%, 0) rotate(-45deg) scaleY(1.2);
        }

        #pauseButton.play .pause-line.right {
            transform: translate(35%, 0) rotate(45deg) scaleY(1.2);
        }

        #pauseButton.pause .pause-line.left {
            transform: none;
        }

        #pauseButton.pause .pause-line.right {
            transform: none;
        }

        #pauseButton.play {
            transform: rotate(-90deg);
        }

        #pauseButton:active {
            transform: scale(0.9);
        }
    </style>
</head>

<body>
    <div id="menu"
        style="position: fixed; width: 100vw; height: 100vh; background: rgba(0,0,0,0.9); color: white; padding: 20px 20px 80px 20px; font-family: Arial; z-index: 1000; overflow-y: auto; overflow-x: hidden;">
        <button id="fullscreenButton"
            style="position: absolute; top: 10px; right: 60px; padding: 10px 20px;">Fullscreen</button>
        <h2>Particle Timer Settings</h2>
    </div>
    <canvas id="glCanvas"></canvas>
    <div id="pauseButton"
        style="position: fixed; top: 20px; right: 20px; z-index: 1000; cursor: pointer; background-color: rgba(0,0,0,0.5); width: 50px; height: 50px; border-radius: 50%; display: none; justify-content: center; align-items: center; transition: background-color 0.3s;">
        <div id="pauseIcon" style="width: 50%; height: 50%; position: relative;">
            <div class="pause-line left"
                style="position: absolute; width: 30%; height: 100%; background-color: white; left: 0; transition: all 0.3s;">
            </div>
            <div class="pause-line right"
                style="position: absolute; width: 30%; height: 100%; background-color: white; right: 0; transition: all 0.3s;">
            </div>
        </div>
    </div>
    <audio id="tickSound" src="https://assets.mixkit.co/active_storage/sfx/2568/2568.wav"></audio>
    <audio id="timerComplete" src="https://assets.mixkit.co/active_storage/sfx/2865/2865.wav"></audio>

    <script type="x-shader/x-vertex" id="vertex-shader">
        attribute vec2 a_position;
        attribute vec3 a_color;
        attribute float a_size;
        varying vec3 v_color;
    
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            gl_PointSize = a_size;
            v_color = a_color;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragment-shader">
        precision mediump float;
        varying vec3 v_color;
        uniform float u_glow_intensity;
        uniform float u_glow_size;
    
        void main() {
            vec2 coord = gl_PointCoord * 2.0 - 1.0;
            float dist = length(coord);
            
            float core = 1.0 - step(0.5, dist);
            
            float glow = u_glow_intensity > 0.0 ? 
                u_glow_intensity * exp(-dist * (1.0 / u_glow_size)) * (1.0 - dist) : 
                0.0;
            
            float alpha = core + glow;
            gl_FragColor = vec4(v_color, alpha);
        }
    </script>




    <script>
        // Replace the existing COLOR_PRESETS object with this expanded version
        const COLOR_PRESETS = {
            // Original presets
            neonLights: [
                [1.0, 0.0, 1.0],  // Magenta
                [0.0, 1.0, 1.0],  // Cyan
                [1.0, 1.0, 0.0]   // Yellow
            ],
            pastelDream: [
                [0.95, 0.61, 0.73],  // Pink
                [0.56, 0.93, 0.56],  // Mint
                [0.68, 0.85, 0.90],  // Sky
                [0.97, 0.85, 0.45],  // Yellow
                [0.85, 0.75, 0.95]   // Lavender
            ],
            oceanBreeze: [
                [0.29, 0.31, 0.30],  // Dark teal
                [0.05, 0.60, 0.65],  // Turquoise
                [0.24, 0.64, 0.67],  // Sea blue
                [0.96, 0.80, 0.38],  // Sand
                [0.99, 0.54, 0.44]   // Coral
            ],
            sunset: [
                [0.98, 0.37, 0.05],  // Orange-red
                [0.98, 0.64, 0.18],  // Orange
                [0.91, 0.84, 0.42],  // Yellow
                [0.69, 0.19, 0.38],  // Deep purple
                [0.44, 0.28, 0.56]   // Violet
            ],
            cyberpunk: [
                [0.94, 0.21, 0.59],  // Hot pink
                [0.07, 0.91, 0.91],  // Bright cyan
                [0.98, 0.98, 0.06],  // Electric yellow
                [0.6, 0.0, 0.8],     // Purple
                [0.13, 0.05, 0.19]   // Dark purple
            ],
            forestGlade: [
                [0.13, 0.55, 0.13],  // Forest green
                [0.42, 0.56, 0.14],  // Olive
                [0.68, 0.85, 0.32],  // Light green
                [0.88, 0.87, 0.74],  // Beige
                [0.55, 0.27, 0.07]   // Brown
            ],
            retroWave: [
                [0.93, 0.0, 0.54],   // Hot pink
                [0.16, 0.84, 0.99],  // Bright blue
                [0.99, 0.42, 0.52],  // Salmon
                [0.47, 0.04, 0.65],  // Purple
                [0.11, 0.0, 0.31]    // Deep blue
            ],
            candyShop: [
                [0.97, 0.39, 0.53],  // Bubblegum
                [0.99, 0.71, 0.38],  // Orange
                [0.55, 0.93, 0.55],  // Mint
                [0.38, 0.69, 0.96],  // Sky blue
                [0.91, 0.44, 0.99]   // Lavender
            ],
            fireAndIce: [
                [0.99, 0.24, 0.0],   // Fire red
                [0.99, 0.56, 0.0],   // Orange
                [0.0, 0.66, 0.98],   // Ice blue
                [0.0, 0.47, 0.75],   // Blue
                [0.93, 0.9, 0.81]    // Off-white
            ],
            monochrome: [
                [0.0, 0.0, 0.0],     // Black
                [0.2, 0.2, 0.2],     // Dark gray
                [0.4, 0.4, 0.4],     // Gray
                [0.7, 0.7, 0.7],     // Light gray
                [1.0, 1.0, 1.0]      // White
            ],
            tropicalParadise: [
                [0.95, 0.36, 0.25],  // Coral
                [0.16, 0.73, 0.58],  // Teal
                [0.99, 0.85, 0.21],  // Sunshine
                [0.0, 0.6, 0.45],    // Palm
                [0.95, 0.61, 0.07]   // Mango
            ],
            galaxyDust: [
                [0.07, 0.03, 0.15],  // Deep space
                [0.17, 0.05, 0.35],  // Purple space
                [0.19, 0.28, 0.54],  // Cosmic blue
                [0.67, 0.55, 0.85],  // Lavender
                [0.93, 0.89, 0.99]   // Stardust
            ],
            autumnLeaves: [
                [0.55, 0.27, 0.07],  // Brown
                [0.82, 0.33, 0.0],   // Rust
                [0.91, 0.45, 0.0],   // Orange
                [0.99, 0.75, 0.0],   // Golden
                [0.6, 0.2, 0.0]      // Deep red
            ],
            winterFrost: [
                [0.88, 0.94, 0.99],  // Ice white
                [0.69, 0.85, 0.93],  // Pale blue
                [0.5, 0.67, 0.85],   // Cold blue
                [0.26, 0.45, 0.68],  // Winter blue
                [0.13, 0.21, 0.37]   // Deep blue
            ],
            rainbowVibrant: [
                [0.93, 0.11, 0.14],  // Red
                [0.99, 0.59, 0.0],   // Orange
                [0.99, 0.91, 0.0],   // Yellow
                [0.0, 0.75, 0.22],   // Green
                [0.0, 0.51, 0.98],   // Blue
                [0.45, 0.0, 0.88]    // Purple
            ],
            darkMode: [
                [0.13, 0.13, 0.13],  // Dark gray
                [0.2, 0.2, 0.2],     // Medium gray
                [0.33, 0.33, 0.33],  // Gray
                [0.93, 0.93, 0.93],  // Light gray
                [0.0, 0.48, 1.0]     // Accent blue
            ],
            mintChocolate: [
                [0.36, 0.82, 0.55],  // Mint
                [0.2, 0.63, 0.46],   // Dark mint
                [0.37, 0.22, 0.13],  // Chocolate
                [0.23, 0.12, 0.05],  // Dark chocolate
                [0.85, 0.99, 0.85]   // Light mint
            ],
            berryBliss: [
                [0.75, 0.0, 0.19],   // Raspberry
                [0.53, 0.0, 0.27],   // Cranberry
                [0.34, 0.0, 0.25],   // Blackberry
                [0.2, 0.0, 0.36],    // Dark purple
                [0.95, 0.68, 0.79]   // Light pink
            ],
            goldLuxury: [
                [0.83, 0.69, 0.22],  // Gold
                [0.52, 0.39, 0.0],   // Dark gold
                [0.95, 0.87, 0.51],  // Light gold
                [0.13, 0.13, 0.13],  // Black
                [0.93, 0.93, 0.93]   // White
            ],
            marineDeep: [
                [0.0, 0.05, 0.16],   // Deep marine
                [0.0, 0.11, 0.33],   // Dark blue
                [0.0, 0.22, 0.49],   // Navy
                [0.0, 0.46, 0.74],   // Ocean blue
                [0.39, 0.83, 0.96]   // Sky blue
            ],
            cottonCandy: [
                [0.99, 0.62, 0.77],  // Pink
                [0.99, 0.84, 0.92],  // Light pink
                [0.85, 0.65, 0.93],  // Lavender
                [0.69, 0.88, 0.9],   // Light blue
                [0.99, 0.93, 0.64]   // Light yellow
            ],
            electroNight: [
                [0.05, 0.05, 0.05],  // Almost black
                [0.33, 0.0, 0.5],    // Deep purple
                [0.0, 0.4, 0.6],     // Deep blue
                [0.0, 0.8, 0.8],     // Cyan
                [0.0, 1.0, 0.0]      // Neon green
            ]
        };

        // Optimized particle modes
        const ParticleFunctions = {
            registry: {},

            register(name, functionBody) {
                this.registry[name] = functionBody;
            },

            getFunction(name) {
                if (!this.registry[name]) {
                    console.warn(`Particle function "${name}" not found, falling back to circle pattern`);
                    return this.registry['circle'];
                }
                return this.registry[name];
            },

            applyToPoints(modeName, points, remainingPoints) {
                const radius = STATE.config.behavior.radius;
                const aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;
                const animationTime = performance.now() / 1000;

                const timerInfo = {
                    msLeft: TIMER.msLeft || 0,
                    endTime: TIMER.endTime || 0,
                    progress: 0,
                    totalDuration: 0
                };

                if (TIMER.endTime) {
                    timerInfo.totalDuration = TIMER.endTime - TIMER.startTime;
                    timerInfo.progress = Math.max(0, Math.min(1, TIMER.msLeft / timerInfo.totalDuration));
                }

                try {
                    const functionBody = this.getFunction(modeName);

                    const createPoint = new Function(
                        'angle', 'index', 'total', 'radius', 'aspectRatio',
                        'time', 'timer',
                        functionBody
                    );

                    for (let i = 0; i < remainingPoints; i++) {
                        const angle = i * (2 * Math.PI / remainingPoints);
                        const newPoint = createPoint(angle, i, remainingPoints, radius, aspectRatio, animationTime, timerInfo);
                        points.push(newPoint);
                    }
                } catch (error) {
                    console.error(`Error in particle function "${modeName}":`, error);
                    console.log(`Function parameters: radius=${radius}, aspectRatio=${aspectRatio}, timerInfo=`, timerInfo);
                    this.fallbackCircle(points, remainingPoints);
                }
            },

            fallbackCircle(points, remainingPoints) {
                const radius = STATE.config.behavior.radius;
                const aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;

                for (let i = 0; i < remainingPoints; i++) {
                    const angle = i * (2 * Math.PI / remainingPoints);
                    points.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius * aspectRatio
                    });
                }
            }
        };

        ParticleFunctions.register('progressCircle', `
            // Get progress directly from the timer object or calculate it
            let progressPercentage;
            
            if (timer && typeof timer.progress === 'number') {
                // Use provided progress if available
                progressPercentage = timer.progress;
            } else if (typeof TIMER !== 'undefined' && TIMER.msLeft && TIMER.initialDuration) {
                // Calculate directly if we have the needed values
                progressPercentage = Math.max(0, Math.min(1, TIMER.msLeft / TIMER.initialDuration));
            } else {
                // Fallback to a simple calculation if all else fails
                const totalTimeEstimate = 60 * 1000; // Assume 1 minute timer
                progressPercentage = Math.max(0, Math.min(1, (TIMER.msLeft || 0) / totalTimeEstimate));
            }
            
            // Ensure we have a valid value between 0 and 1
            progressPercentage = Math.max(0.01, Math.min(1, progressPercentage || 0));
            
            // Calculate full circle angle
            const fullCircle = 2 * Math.PI;
            
            // Scale the angle to fit within the progress percentage
            // This redistributes all particles to fit within the available arc
            const scaledAngle = angle * progressPercentage;
            
            // Position particles using the scaled angle
            return {
                x: Math.cos(scaledAngle) * radius,
                y: Math.sin(scaledAngle) * radius * aspectRatio
            };
        `);


        ParticleFunctions.register('circle', `
            return {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius * aspectRatio
            };
        `);

        ParticleFunctions.register('center', `
            return { x: 0, y: 0 };
        `);

        ParticleFunctions.register('spiral', `
            const distance = (index / total) * radius;
            const spiralTurns = 3;
            const spiralAngle = angle + index * (2 * Math.PI * spiralTurns / total);
            
            return {
                x: Math.cos(spiralAngle) * distance,
                y: Math.sin(spiralAngle) * distance * aspectRatio
            };
        `);

        ParticleFunctions.register('wave', `
            const x = ((index / total) * 2 - 1) * radius;
            const waveAmplitude = radius * 0.5;
            const waveFrequency = 5;
            
            return {
                x: x,
                y: Math.sin(x * waveFrequency / radius) * waveAmplitude * aspectRatio
            };
        `);

        ParticleFunctions.register('fountain', `
            const fountainBase = -0.8;
            
            return {
                x: (Math.random() * 2 - 1) * radius * 0.5,
                y: fountainBase * aspectRatio
            };
        `);

        ParticleFunctions.register('maintain', `
            const largeRadius = radius * 3;
            const angle = (index / total) * 2 * Math.PI;
            
            return {
                x: Math.cos(angle) * largeRadius,
                y: Math.sin(angle) * largeRadius
            };
        `);

        // Add some dynamic, time-based functions
        ParticleFunctions.register('pulsatingCircle', `
            return {
                x: Math.cos(angle) * radius * (1 + 0.3 * Math.sin(time)),
                y: Math.sin(angle) * radius * aspectRatio * (1 + 0.3 * Math.cos(time))
            };
        `);

        ParticleFunctions.register('dynamicSpiral', `
            const distance = (index / total) * radius * (1 + 0.2 * Math.sin(time));
            const extraAngle = time * 0.5;
            
            return {
                x: Math.cos(angle + extraAngle) * distance,
                y: Math.sin(angle + extraAngle) * distance * aspectRatio
            };
        `);

        ParticleFunctions.register('flower', `
            const petals = 5;
            const petalSize = 0.3 + 0.1 * Math.sin(time);
            const modifiedRadius = radius * (1 + petalSize * Math.sin(petals * angle));
            
            return {
                x: Math.cos(angle) * modifiedRadius,
                y: Math.sin(angle) * modifiedRadius * aspectRatio
            };
        `);

        ParticleFunctions.register('orbit', `
            // Main center
            if (index === 0) return { x: 0, y: 0 };

            // Orbiting bodies
            const orbitCount = 3;
            const orbitIndex = index % orbitCount;
            const particlesPerOrbit = Math.floor(total / orbitCount);
            const particleInOrbitIndex = Math.floor(index / orbitCount);
            const orbitRadius = (orbitIndex + 1) * radius / orbitCount;
            const orbitAngle = (particleInOrbitIndex / particlesPerOrbit) * 2 * Math.PI + time * (0.5 / (orbitIndex + 1));

            return {
                x: Math.cos(orbitAngle) * orbitRadius,
                y: Math.sin(orbitAngle) * orbitRadius * aspectRatio
            };
        `);

        // Particle Configuration System
        const ConfigSchema = {
            fields: {
                particles: {
                    position: {
                        min: { type: 'number', min: -2, max: 0, step: 0.1, default: -0.7 },
                        spread: { type: 'number', min: 0, max: 3, step: 0.1, default: 1.2 }
                    },
                    physics: {
                        acceleration: {
                            base: { type: 'number', min: 0, max: 20, step: 0.5, default: 3 },
                            variation: { type: 'number', min: 0, max: 10, step: 0.5, default: 3 }
                        },
                        damping: {
                            base: { type: 'number', min: 0.8, max: 0.999, step: 0.001, default: 0.95 },
                            variation: { type: 'number', min: 0, max: 0.1, step: 0.001, default: 0.04 }
                        }
                    },
                    appearance: {
                        size: {
                            base: { type: 'number', min: 1, max: 20, default: 15 },
                            variation: { type: 'number', min: 0, max: 75, default: 10 }
                        },
                        colors: {
                            type: 'colorArray',
                            presets: COLOR_PRESETS,
                            default: COLOR_PRESETS.oceanBreeze
                        },
                        glow: {
                            intensity: { type: 'number', min: 0.1, max: 10, step: 0.1, default: 0.3 },
                            size: { type: 'number', min: 0.1, max: 10, step: 0.1, default: 2.0 }
                        }
                    },
                    mouseBehavior: {
                        pushForce: { type: 'number', min: 0, max: 5000, default: 1500 },
                        pushRadius: { type: 'number', min: 0, max: 500, default: 100 }
                    },
                },
                text: {
                    size: { type: 'number', min: 100, max: 400, default: 30 },
                    scale: { type: 'number', min: 0.1, max: 2, step: 0.1, default: 0.6 },
                    verticalOffset: { type: 'number', min: -10, max: 10, step: 0.01, default: 1 },
                    endTextScale: { type: 'number', min: 0.1, max: 2, step: 0.1, default: 1 },
                    density: { type: 'number', min: 1, max: 5, default: 1 },
                    endText: { type: 'string', default: 'Time\'s up!' },
                    font: {
                        type: 'select',
                        options: [
                            "Arial", "Courier New", "Georgia", "Times New Roman", "Verdana",
                            "Helvetica", "Impact", "Tahoma", "Trebuchet MS", "Comic Sans MS",
                            "Arial Black", "Lucida Console", "Lucida Sans Unicode", "Palatino Linotype",
                            "Book Antiqua", "Garamond", "MS Sans Serif", "MS Serif"
                        ],
                        default: "Courier New"
                    },
                    isBold: { type: 'boolean', default: true }

                },
                behavior: {
                    ordering: {
                        type: 'select',
                        options: ['vertical', 'horizontal', 'optimized'],
                        default: 'vertical'
                    },
                    radius: { type: 'number', min: 0.5, max: 3, step: 0.1, default: 0.8 },
                    extraParticleMode: {
                        type: 'select',
                        options: Object.keys(ParticleFunctions.registry),
                        default: 'circle'
                    },
                    tickSyncRendering: { type: 'boolean', default: false }
                }
            },

            createDefault() {
                return this.createFromSchema(this.fields);
            },

            createFromSchema(schema) {
                const result = {};
                Object.entries(schema).forEach(([key, value]) => {
                    if (value.type) {
                        result[key] = value.default;
                    } else {
                        result[key] = this.createFromSchema(value);
                    }
                });
                return result;
            },

            generateUI(container) {
                this.buildUIFromSchema(this.fields, container);
            },

            buildUIFromSchema(schema, container, path = '') {
                Object.entries(schema).forEach(([key, value]) => {
                    const currentPath = path ? `${path}.${key}` : key;

                    if (value.type) {
                        container.appendChild(this.createControl(key, value, currentPath));
                    } else {
                        const section = document.createElement('div');
                        section.className = 'section';
                        section.innerHTML = `<h3>${key.charAt(0).toUpperCase() + key.slice(1)}</h3>`;
                        this.buildUIFromSchema(value, section, currentPath);
                        container.appendChild(section);
                    }
                });
            },

            createControl(key, config, path) {
                const label = document.createElement('label');
                label.textContent = key.charAt(0).toUpperCase() + key.slice(1) + ': ';

                const input = this.createInputByType(config);
                input.id = path.replace(/\./g, '_');
                input.dataset.configPath = path;

                label.appendChild(input);
                return label;
            },

            createInputByType(config) {
                let container, select, input, opt;

                switch (config.type) {
                    case 'colorArray':
                        container = document.createElement('div');
                        container.id = 'colorPickers';

                        select = document.createElement('select');
                        select.id = 'colorPreset';
                        Object.keys(COLOR_PRESETS).forEach(presetName => {
                            opt = document.createElement('option');
                            opt.value = presetName;
                            opt.textContent = presetName;
                            select.appendChild(opt);
                        });
                        container.appendChild(select);

                        config.default.forEach(color => {
                            input = document.createElement('input');
                            input.type = 'color';
                            input.className = 'particleColor';
                            input.value = `#${color.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('')}`;
                            container.appendChild(input);
                        });

                        return container;

                    case 'number':
                        input = document.createElement('input');
                        input.type = 'number';
                        input.min = config.min;
                        input.max = config.max;
                        input.step = config.step || 1;
                        input.value = config.default;
                        return input;

                    case 'select':
                        select = document.createElement('select');


                        if (config.options[0] === "Arial") {
                            config.options.forEach(option => {
                                opt = document.createElement('option');
                                opt.value = option;
                                opt.textContent = option;
                                opt.style.fontFamily = option;
                                select.appendChild(opt);
                            });
                        } else {
                            // Regular select handling
                            config.options.forEach(option => {
                                opt = document.createElement('option');
                                opt.value = option;
                                opt.textContent = option;
                                select.appendChild(opt);
                            });
                        }

                        select.value = config.default;
                        return select;
                    case 'string':
                        input = document.createElement('input');
                        input.type = 'text';
                        input.value = config.default;
                        return input;
                    case 'boolean':
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = config.default;
                        return input;
                }
            }
        };

        function detectAvailableFonts(fontArray) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const referenceFont = 'monospace';
            const testString = 'mmmmmmmmmmlli';

            ctx.font = `16px ${referenceFont}`;
            const referenceFontWidth = ctx.measureText(testString).width;

            const availableFonts = fontArray.filter(font => {
                ctx.font = `16px "${font}", ${referenceFont}`;
                const testWidth = ctx.measureText(testString).width;

                return testWidth !== referenceFontWidth;
            });

            if (!availableFonts.includes('Courier New')) {
                availableFonts.unshift('Courier New');
            }

            return availableFonts;
        }

        function updateColorPickers(colors, container) {
            Array.from(container.querySelectorAll('.particleColor')).forEach(picker => picker.remove());

            colors.forEach(color => {
                const input = document.createElement('input');
                input.type = 'color';
                input.className = 'particleColor';
                const hexColor = `#${color.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('')}`;
                input.value = hexColor;
                container.appendChild(input);
            });
        }

        // Core state management
        const STATE = {
            config: null,
            presets: {
                current: null,
                saved: new Map(),
            },
            mouse: {
                x: 0,
                y: 0,
                velocityX: 0,
                velocityY: 0,
                clicked: false,
                down: false
            },
            particles: {
                arrays: null,
                count: 0,
                activeCount: 0,
                previousPoints: new Map(),
                externalForces: null
            },
            render: {
                canvas: null,
                gl: null,
                program: null,
                buffers: {
                    position: null,
                    size: null,
                    color: null
                },
                attributes: {
                    position: null,
                    size: null,
                    color: null
                }
            },
            stats: {
                frameCount: 0,
                lastFpsTime: 0,
                fps: 0,
                element: null
            },
            timer: {
                running: false,
                paused: false,
                lastTime: 0
            },
            canvas: {
                rect: null,
                aspectRatio: 1
            },
            menu: {
                visible: true
            }
        };

        const PRESETS = {
            minimal: {
                particles: {
                    position: {
                        min: -0.7,
                        spread: 1.2
                    },
                    physics: {
                        acceleration: {
                            base: 3,
                            variation: 3
                        },
                        damping: {
                            base: 0.95,
                            variation: 0.04
                        }
                    },
                    appearance: {
                        size: {
                            base: 5,
                            variation: 10
                        },
                        colors: COLOR_PRESETS.oceanBreeze,
                        glow: {
                            intensity: 0.3,
                            size: 1.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 1500,
                        pushRadius: 100
                    },
                },
                text: {
                    size: 30,
                    scale: 0.6,
                    density: 1
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "circle",
                    radius: 0.8
                }
            },

            neon: {
                particles: {
                    position: {
                        min: -0.9,
                        spread: 1.8
                    },
                    physics: {
                        acceleration: {
                            base: 5,
                            variation: 5.0
                        },
                        damping: {
                            base: 0.99,
                            variation: 0.005
                        }
                    },
                    appearance: {
                        size: {
                            base: 1,
                            variation: 2.0
                        },
                        colors: COLOR_PRESETS.neonLights,

                        glow: {
                            intensity: 1,
                            size: 1.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 1000,
                        pushRadius: 100
                    },
                },
                text: {
                    size: 280,
                    scale: 1,
                    density: 2
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "center",
                    radius: 2
                }
            },
            sunset: {
                particles: {
                    appearance: {
                        size: {
                            base: 8,
                            variation: 12
                        },
                        colors: COLOR_PRESETS.sunset,
                        glow: {
                            intensity: 0.6,
                            size: 2.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 4.5,
                            variation: 2
                        },
                        damping: {
                            base: 0.97,
                            variation: 0.02
                        }
                    }
                },
                text: {
                    size: 50,
                    scale: 0.7,
                    font: "Impact",
                    font: "Georgia",
                    isBold: true
                },
                behavior: {
                    ordering: "optimized", // Methodical effect
                    extraParticleMode: "wave",
                    radius: 1.2
                }
            },
            cyberpunk: {
                particles: {
                    position: {
                        min: -5,
                        spread: 8
                    },
                    appearance: {
                        size: {
                            base: 4,
                            variation: 15
                        },
                        colors: COLOR_PRESETS.cyberpunk,
                        glow: {
                            intensity: 1.8,
                            size: 3.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 10,
                            variation: 4
                        }
                    },
                    mouseBehavior: {
                        pushForce: 2500,
                        pushRadius: 150
                    }
                },
                text: {
                    size: 50,
                    scale: 0.7,
                    density: 1,
                    font: "Impact",
                },
                behavior: {
                    extraParticleMode: "center",
                    ordering: "horizontal",
                    radius: 1.5
                }
            },

            forestGlade: {
                particles: {
                    appearance: {
                        size: {
                            base: 6,
                            variation: 8
                        },
                        colors: COLOR_PRESETS.forestGlade,
                        glow: {
                            intensity: 0.2,
                            size: 1.2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2,
                            variation: 3
                        },
                        damping: {
                            base: 0.98,
                            variation: 0.01
                        }
                    }
                },
                text: {
                    size: 40,
                    scale: 0.65,
                    density: 1,
                    font: "Garamond",
                    isBold: false
                },
                behavior: {
                    ordering: "optimized", // Methodical effect
                    extraParticleMode: "circle"
                }
            },

            retroWave: {
                particles: {
                    appearance: {
                        size: {
                            base: 3,
                            variation: 6
                        },
                        colors: COLOR_PRESETS.retroWave,
                        glow: {
                            intensity: 1.2,
                            size: 2.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 2500,
                        pushRadius: 150
                    },
                    physics: {
                        acceleration: {
                            base: 5,
                            variation: 5,
                        },
                    },
                },
                text: {
                    size: 60,
                    scale: 0.8,
                    font: "Arial Black",
                    isBold: true
                },
                behavior: {
                    ordering: "horizontal",
                    extraParticleMode: "wave",
                    radius: 2
                }
            },

            candyShop: {
                particles: {
                    appearance: {
                        size: {
                            base: 7,
                            variation: 10
                        },
                        colors: COLOR_PRESETS.candyShop,
                        glow: {
                            intensity: 0.4,
                            size: 1.8
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 3.5,
                            variation: 2.5
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Comic Sans MS",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "circle",
                    radius: 0.7
                }
            },

            fireAndIce: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 15
                        },
                        colors: COLOR_PRESETS.fireAndIce,
                        glow: {
                            intensity: 0.7,
                            size: 2.2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 4,
                            variation: 3
                        }
                    }
                },
                text: {
                    size: 50,
                    scale: 0.75,
                    density: 1,
                    font: "Trebuchet MS",
                    isBold: true
                },
                behavior: {
                    ordering: "horizontal", // Glitch effect for fire/ice contrast
                    extraParticleMode: "fountain"
                }
            },

            monochrome: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 3
                        },
                        colors: COLOR_PRESETS.monochrome,
                        glow: {
                            intensity: 2,
                            size: 2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2.5,
                            variation: 1.0
                        },
                        damping: {
                            base: 0.97,
                            variation: 0.01
                        }
                    }
                },
                text: {
                    size: 60,
                    scale: 1,
                    density: 1,
                    font: "Courier New",
                    isBold: false
                },
                behavior: {
                    ordering: "optimized",
                    extraParticleMode: "center"
                }
            },

            tropicalParadise: {
                particles: {
                    appearance: {
                        size: {
                            base: 8,
                            variation: 12
                        },
                        colors: COLOR_PRESETS.tropicalParadise,
                        glow: {
                            intensity: 0.5,
                            size: 2.0
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Verdana",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "maintain",
                    radius: 1.2
                }
            },

            galaxyDust: {
                particles: {
                    position: {
                        spread: 1.5
                    },
                    appearance: {
                        size: {
                            base: 2,
                            variation: 18
                        },
                        colors: COLOR_PRESETS.galaxyDust,
                        glow: {
                            intensity: 1.5,
                            size: 3.0
                        }
                    },
                    physics: {
                        damping: {
                            base: 0.99,
                            variation: 0.005
                        }
                    }
                },
                text: {
                    size: 55,
                    scale: 0.8,
                    font: "Palatino Linotype",
                    isBold: true
                },
                behavior: {
                    ordering: "optimized", // Methodical for space-like precision
                    extraParticleMode: "spiral",
                    radius: 1.8
                }
            },

            autumnLeaves: {
                particles: {
                    appearance: {
                        size: {
                            base: 15,
                            variation: 8
                        },
                        colors: COLOR_PRESETS.autumnLeaves,
                        glow: {
                            intensity: 0.3,
                            size: 1.5
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2,
                            variation: 8
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Book Antiqua",
                    isBold: false
                },
                behavior: {
                    ordering: "horizontal", // Glitch-like for falling leaves effect
                    extraParticleMode: "wave",
                    radius: 1.1
                }
            },

            winterFrost: {
                particles: {
                    appearance: {
                        size: {
                            base: 4,
                            variation: 6
                        },
                        colors: COLOR_PRESETS.winterFrost,
                        glow: {
                            intensity: 0.8,
                            size: 2.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2.7,
                            variation: 1.5
                        },
                        damping: {
                            base: 0,
                            variation: 0
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Tahoma",
                    isBold: false
                },
                behavior: {
                    ordering: "optimized", // Methodical for snowflake precision
                    extraParticleMode: "circle",
                    radius: 0.8
                }
            },

            rainbowVibrant: {
                particles: {
                    appearance: {
                        size: {
                            base: 7,
                            variation: 10
                        },
                        colors: COLOR_PRESETS.rainbowVibrant,
                        glow: {
                            intensity: 0.6,
                            size: 1.8
                        }
                    }
                },
                text: {
                    size: 50,
                    scale: 0.75,
                    density: 1,
                    font: "Lucida Sans Unicode",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "circle",
                    radius: 1
                }
            },

            darkMode: {
                particles: {
                    appearance: {
                        size: {
                            variation: 0
                        },
                        colors: COLOR_PRESETS.darkMode,
                        glow: {
                            intensity: 1,
                            size: 2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 7,
                            variation: 5.0
                        },
                    },
                },
                text: {
                    size: 50,
                    scale: 1,
                    font: "MS Sans Serif",
                    isBold: true
                },
                behavior: {
                    ordering: "optimized",
                    extraParticleMode: "maintain"
                }
            },

            mintChocolate: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 7
                        },
                        colors: COLOR_PRESETS.mintChocolate,
                        glow: {
                            intensity: 0.3,
                            size: 1.6
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Lucida Console",
                    isBold: false
                },
                behavior: {
                    ordering: "horizontal", // Glitch effect for contrast
                    extraParticleMode: "test"
                }
            },

            berryBliss: {
                particles: {
                    appearance: {
                        size: {
                            base: 6,
                            variation: 9
                        },
                        colors: COLOR_PRESETS.berryBliss,
                        glow: {
                            intensity: 0.7,
                            size: 2.0
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Times New Roman",
                    isBold: true
                },
                behavior: {
                    ordering: "horizontal", // Glitch effect
                    extraParticleMode: "spiral",
                    radius: 1.1
                }
            },

            goldLuxury: {
                particles: {
                    appearance: {
                        size: {
                            base: 4,
                            variation: 6
                        },
                        colors: COLOR_PRESETS.goldLuxury,
                        glow: {
                            intensity: 1.1,
                            size: 2.2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 3,
                            variation: 1.5
                        },
                        damping: {
                            base: 0.5,
                            variation: 1
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Garamond",
                    isBold: true
                },
                behavior: {
                    ordering: "optimized",
                    extraParticleMode: "circle",
                    radius: 0.9
                }
            },

            marineDeep: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 8
                        },
                        colors: COLOR_PRESETS.marineDeep,
                        glow: {
                            intensity: 0.9,
                            size: 2.4
                        }
                    },
                    physics: {
                        damping: {
                            base: 0.98,
                            variation: 0.01
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Helvetica",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "wave",
                    radius: 1.1
                }
            },

            cottonCandy: {
                particles: {
                    appearance: {
                        size: {
                            base: 7,
                            variation: 9
                        },
                        colors: COLOR_PRESETS.cottonCandy,
                        glow: {
                            intensity: 0.4,
                            size: 1.7
                        }
                    }
                },
                text: {
                    size: 40,
                    scale: 0.65,
                    density: 1,
                    font: "Comic Sans MS",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "circle"
                }
            },

            electroNight: {
                particles: {
                    appearance: {
                        size: {
                            base: 3,
                            variation: 12
                        },
                        colors: COLOR_PRESETS.electroNight,
                        glow: {
                            intensity: 2.0,
                            size: 3.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 4,
                            variation: 3
                        }
                    }
                },
                text: {
                    size: 55,
                    scale: 0.8,
                    density: 1,
                    font: "Arial Black",
                    isBold: true
                },
                behavior: {
                    ordering: "horizontal", // Glitch effect for electro theme
                    extraParticleMode: "spiral",
                    radius: 1.3
                }
            }
        };



        function applyPreset(presetName) {
            let preset = PRESETS[presetName];

            if (!preset && STATE.presets.saved.has(presetName)) {
                preset = STATE.presets.saved.get(presetName);
            }

            // If still no preset found, return
            if (!preset) {
                console.warn(`No preset found with name: ${presetName}`);
                return;
            }

            console.log(`Applying preset: ${presetName}`, preset);

            saveLastUsedConfig(presetName);

            // Set the current config to the selected preset
            STATE.config = Object.assign({}, preset);

            // Update all UI elements with the preset values
            document.querySelectorAll('[data-config-path]').forEach(input => {
                const path = input.dataset.configPath.split('.');
                let value = preset;

                // Navigate down the object path
                for (const key of path) {
                    if (value === undefined || value === null) {
                        console.warn(`Invalid path for ${input.dataset.configPath}, missing: ${key}`);
                        return;
                    }
                    value = value[key];
                }

                if (value === undefined || value === null) {
                    console.warn(`No value found for path: ${input.dataset.configPath}`);
                    return;
                }

                // Special handling for color inputs
                if (input.type === 'color') {
                    input.value = rgbToHex(value);
                } else if (input.type === 'select-one') {
                    input.value = value;
                } else if (input.type === 'number') {
                    input.value = value;
                } else if (input.className === 'particleColor') {
                    // Skip individual color pickers as they'll be handled below
                } else {
                    input.value = value;
                }
            });

            const colorPresetSelect = document.getElementById('colorPreset');
            if (preset.particles && preset.particles.appearance && preset.particles.appearance.colors) {
                const colors = preset.particles.appearance.colors;
                const container = colorPresetSelect.parentElement;

                // Try to find if this matches a built-in color preset
                const matchingPreset = Object.entries(COLOR_PRESETS).find(([_, presetColors]) =>
                    JSON.stringify(presetColors) === JSON.stringify(colors)
                );

                if (matchingPreset) {
                    colorPresetSelect.value = matchingPreset[0];
                }

                // Update the actual color pickers
                updateColorPickers(colors, container);
            }

            console.log("Preset applied successfully");
        }

        function rgbToHex(rgbArray) {
            if (!Array.isArray(rgbArray) || rgbArray.length < 3) {
                console.warn("Invalid RGB array:", rgbArray);
                return "#FFFFFF";
            }

            return '#' + rgbArray.map(component => {
                const hex = Math.round(component * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        const StorageUtils = {
            set: function (name, value) {
                try {
                    const serialized = JSON.stringify(value);
                    localStorage.setItem(name, serialized);
                    return true;
                } catch (e) {
                    console.error('Error saving to localStorage:', e);
                    return false;
                }
            },

            get: function (name) {
                try {
                    const serialized = localStorage.getItem(name);
                    if (serialized === null) return null;
                    return JSON.parse(serialized);
                } catch (e) {
                    console.error('Error retrieving from localStorage:', e);
                    return null;
                }
            },

            delete: function (name) {
                localStorage.removeItem(name);
            },

            getAllKeys: function () {
                return Object.keys(localStorage).filter(key =>
                    key.startsWith('particle_timer_preset_'));
            }
        };

        function saveLastUsedConfig(configName) {
            try {
                localStorage.setItem('particle_timer_last_config', configName);
                console.log(`Saved "${configName}" as last used config`);
            } catch (e) {
                console.error('Error saving last used config:', e);
            }
        }

        function loadLastUsedConfig() {
            try {
                const lastConfig = localStorage.getItem('particle_timer_last_config');
                if (lastConfig) {
                    console.log(`Found last used config: "${lastConfig}"`);

                    setTimeout(() => {
                        const presetSelect = document.getElementById('presetStyle');

                        let configExists = false;
                        for (let i = 0; i < presetSelect.options.length; i++) {
                            if (presetSelect.options[i].value === lastConfig) {
                                presetSelect.selectedIndex = i;
                                configExists = true;
                                break;
                            }
                        }

                        if (configExists) {
                            console.log(`Applying last used config: "${lastConfig}"`);
                            applyPreset(lastConfig);
                        } else {
                            console.log(`Last config "${lastConfig}" not found, using default`);
                        }
                    }, 100);
                }
            } catch (e) {
                console.error('Error loading last used config:', e);
            }
        }

        function loadPresets() {
            // Load default presets into state
            Object.entries(PRESETS).forEach(([name, config]) => {
                STATE.presets.saved.set(name, config);
            });

            console.log('Loading saved presets...');

            // Get all preset keys from localStorage
            const presetKeys = StorageUtils.getAllKeys();

            presetKeys.forEach(fullKey => {
                try {
                    const config = StorageUtils.get(fullKey);
                    if (!config) return;

                    // Remove the prefix to get the actual name
                    const name = fullKey.replace('particle_timer_preset_', '');

                    STATE.presets.saved.set(name, config);

                    // Add to preset selector if it doesn't exist
                    const presetSelect = document.getElementById('presetStyle');
                    if (presetSelect && !Array.from(presetSelect.options).some(opt => opt.value === name)) {
                        const opt = document.createElement('option');
                        opt.value = name;
                        opt.textContent = name;
                        presetSelect.appendChild(opt);
                        console.log(`Added ${name} to preset selector`);
                    }

                    console.log(`Successfully loaded saved preset: ${name}`);
                } catch (e) {
                    console.warn('Error loading preset:', fullKey, e);
                }
            });

            console.log('Available presets after loading:', Array.from(STATE.presets.saved.keys()));
        }


        function initializeWithConfig(newConfig, minutes, seconds) {
            Object.assign(STATE.config, newConfig);

            const maxPoints = Math.max(
                getTextPoints(findLargestAreaTime(minutes, seconds), false).realPointsLength,
                getTextPoints(STATE.config.text.endText, false).realPointsLength
            );

            STATE.particles.count = maxPoints;
            STATE.particles.arrays = createParticleArrays(maxPoints);
            STATE.particles.externalForces = new Float32Array(maxPoints * 2);

            initializeParticles(STATE.particles.arrays, 0, maxPoints);
            updateBuffers(STATE.particles.arrays);
        }

        function findLargestAreaTime(minutes, seconds) {
            const digitScores = {};
            for (let i = 0; i <= 9; i++) {
                digitScores[i] = getTextPoints(i.toString(), false).realPointsLength;
            }

            let maxScore = 0;
            let maxAreaTime = null;

            for (let m = minutes; m >= 0; m--) {
                const maxSecs = m === minutes ? seconds : 59;
                const minSecs = m === 0 ? 1 : 0;

                for (let s = maxSecs; s >= minSecs; s--) {
                    const timeDigits = `${m}${s.toString().padStart(2, '0')}`.split('').map(Number);
                    const score = timeDigits.reduce((sum, digit) => sum + digitScores[digit], 0);

                    if (score > maxScore) {
                        maxScore = score;
                        maxAreaTime = `${m}:${s.toString().padStart(2, '0')}`;
                    }
                }
            }

            return maxAreaTime;
        }

        function getConfigFromInputs() {
            const config = ConfigSchema.createDefault();

            document.querySelectorAll('[data-config-path]').forEach(input => {
                const path = input.dataset.configPath.split('.');
                let target = config;

                // Navigate to the correct nested object
                for (let i = 0; i < path.length - 1; i++) {
                    if (!target[path[i]]) {
                        console.warn(`Path segment ${path[i]} not found in config object`);
                        return;
                    }
                    target = target[path[i]];
                }

                const key = path[path.length - 1];
                if (!target.hasOwnProperty(key)) {
                    console.warn(`Key ${key} not found in config object at path ${path.slice(0, -1).join('.')}`);
                    return;
                }

                if (key === 'colors') {
                    target[key] = Array.from(document.querySelectorAll('.particleColor')).map(cp => {
                        const hex = cp.value;
                        return [
                            parseInt(hex.slice(1, 3), 16) / 255,
                            parseInt(hex.slice(3, 5), 16) / 255,
                            parseInt(hex.slice(5, 7), 16) / 255
                        ];
                    });
                } else if (input.type === 'checkbox') {
                    target[key] = input.checked;
                } else if (input.type === 'number') {
                    target[key] = parseFloat(input.value);
                } else {
                    target[key] = input.value;
                }
            });

            return config;
        }


        // Helper functions
        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function twoDigits(n) {
            return (n < 10 ? '0' : '') + n;
        }


        // Initialize WebGL
        function initGL() {
            STATE.render.canvas = document.getElementById('glCanvas');
            STATE.render.gl = STATE.render.canvas.getContext('webgl', {
                antialias: false,
                depth: false,
                alpha: false,
                preserveDrawingBuffer: false
            });

            const gl = STATE.render.gl;

            // Compile shaders
            const vertexShader = compileShader(gl, gl.VERTEX_SHADER,
                document.getElementById('vertex-shader').textContent);
            const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER,
                document.getElementById('fragment-shader').textContent);

            // Create and link program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            STATE.render.program = program;
            STATE.render.uniforms = {
                glowIntensity: gl.getUniformLocation(program, 'u_glow_intensity')
            };
            STATE.render.uniforms.resolution = gl.getUniformLocation(program, 'u_resolution')
            STATE.render.uniforms.glowSize = gl.getUniformLocation(program, 'u_glow_size');

            // Initialize buffers
            STATE.render.buffers.position = gl.createBuffer();
            STATE.render.buffers.size = gl.createBuffer();
            STATE.render.buffers.color = gl.createBuffer();

            // Cache attribute locations
            STATE.render.attributes.position = gl.getAttribLocation(program, 'a_position');
            STATE.render.attributes.size = gl.getAttribLocation(program, 'a_size');
            STATE.render.attributes.color = gl.getAttribLocation(program, 'a_color');

            // Enable attributes
            gl.enableVertexAttribArray(STATE.render.attributes.position);
            gl.enableVertexAttribArray(STATE.render.attributes.size);
            gl.enableVertexAttribArray(STATE.render.attributes.color);

            // Set up vertex attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.position);
            gl.vertexAttribPointer(STATE.render.attributes.position, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.size);
            gl.vertexAttribPointer(STATE.render.attributes.size, 1, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.color);
            gl.vertexAttribPointer(STATE.render.attributes.color, 3, gl.FLOAT, false, 0, 0);

            // Set up blending
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }


        // Optimized particle array creation
        function createParticleArrays(count) {
            return {
                positions: new Float32Array(count * 2),
                velocities: new Float32Array(count * 2),
                setPoints: new Float32Array(count * 2),
                accelerations: new Float32Array(count),
                dampings: new Float32Array(count),
                particleSizes: new Float32Array(count),
                particleColors: new Float32Array(count * 3)
            };
        }

        // Optimized particle initialization
        function initializeParticles(arrays, startIndex, endIndex) {
            const config = STATE.config;
            for (let i = startIndex; i < endIndex; i++) {
                const posIndex = i * 2;
                const colorIndex = i * 3;

                arrays.positions[posIndex] = Math.random() * config.particles.position.spread + config.particles.position.min;
                arrays.positions[posIndex + 1] = Math.random() * config.particles.position.spread + config.particles.position.min;

                arrays.velocities[posIndex] = 0;
                arrays.velocities[posIndex + 1] = 0;

                arrays.setPoints[posIndex] = 0;
                arrays.setPoints[posIndex + 1] = 0;

                arrays.accelerations[i] = Math.max(
                    config.particles.physics.acceleration.base +
                    Math.random() * config.particles.physics.acceleration.variation,
                    0.0001
                );

                arrays.dampings[i]
                config.particles.physics.damping.base +
                    Math.random() * config.particles.physics.damping.variation;

                arrays.particleSizes[i] = config.particles.appearance.size.base +
                    Math.random() * config.particles.appearance.size.variation;

                const randomColor = config.particles.appearance.colors[
                    Math.floor(Math.random() * config.particles.appearance.colors.length)
                ];
                arrays.particleColors[colorIndex] = randomColor[0];
                arrays.particleColors[colorIndex + 1] = randomColor[1];
                arrays.particleColors[colorIndex + 2] = randomColor[2];
            }
        }

        // Optimized buffer updates
        function updateBuffers(arrays) {
            const gl = STATE.render.gl;
            const buffers = STATE.render.buffers;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.positions, gl.DYNAMIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.size);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.particleSizes, gl.STATIC_DRAW);

            const colorArray = new Float32Array(arrays.particleColors);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
            gl.bufferData(gl.ARRAY_BUFFER, colorArray, gl.STATIC_DRAW);
        }


        // Optimized force application and physics
        function applyForces(deltaTime) {
            const mouse = STATE.mouse;
            const particles = STATE.particles;
            const canvas = STATE.render.canvas;

            const mousePixelX = STATE.mouse.x * canvas.width / 2;
            const mousePixelY = STATE.mouse.y * canvas.height / 2;

            const pushForce = STATE.config.particles.mouseBehavior.pushForce ? STATE.config.particles.mouseBehavior.pushForce : 0;
            const pushRadius = STATE.config.particles.mouseBehavior.pushRadius; // In pixels

            if (mouse.down) {
                for (let i = 0; i < particles.count; i++) {
                    const particleX = particles.arrays.positions[i * 2] * canvas.width / 2;
                    const particleY = particles.arrays.positions[i * 2 + 1] * canvas.height / 2;

                    const dx = particleX - mousePixelX;
                    const dy = particleY - mousePixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius) {
                        const normalX = dx / distance;
                        const normalY = dy / distance;

                        // Direct outward force
                        const forceX = normalX * pushForce ** 2;
                        const forceY = normalY * pushForce ** 2;

                        const forceMagnitude = (1 - distance / pushRadius);
                        particles.externalForces[i * 2] = forceX * forceMagnitude / canvas.width;
                        particles.externalForces[i * 2 + 1] = forceY * forceMagnitude / canvas.height;
                    }
                }
            }

            if (STATE.mouse.clicked) {
                for (let i = 0; i < particles.count; i++) {
                    const particleX = particles.arrays.positions[i * 2] * canvas.width / 2;
                    const particleY = particles.arrays.positions[i * 2 + 1] * canvas.height / 2;

                    const dx = particleX - mousePixelX;
                    const dy = particleY - mousePixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius) {
                        const force = (1 - distance / pushRadius) * pushForce;
                        const normalizedDx = dx / canvas.width;
                        const normalizedDy = dy / canvas.height;
                        particles.externalForces[i * 2] = normalizedDx * force;
                        particles.externalForces[i * 2 + 1] = -normalizedDy * force;
                    }
                }
                STATE.mouse.clicked = false;
            }
        }

        function decayForce(force, deltaTime) {
            return Math.abs(force) > 0.01 ? force * Math.exp(-deltaTime * 5) : 0;
        }


        function getTextPoints(text, addExtraPoints = true) {
            const points = getOrderedPoints(text);
            const realPointsLength = points.length;

            if (addExtraPoints) {
                const mode = STATE.config.behavior.extraParticleMode;
                const remainingPoints = STATE.particles.count - points.length;

                if (remainingPoints > 0) {
                    ParticleFunctions.applyToPoints(mode, points, remainingPoints);
                }
            }

            STATE.particles.previousPoints.clear();
            points.forEach((point, index) => {
                const key = `${point.x},${point.y}`;
                STATE.particles.previousPoints.set(key, index);
            });

            return { realPointsLength, points };
        }

        function getOrderedPoints(text) {
            const density = STATE.config.text.density;
            const textSize = STATE.config.text.size;
            const textScale = STATE.config.text.scale;
            const endTextScale = STATE.config.text.endTextScale;
            const selectedFont = STATE.config.text.font;
            const isBold = STATE.config.text.isBold;
            const fontWeight = isBold ? 'bold' : 'normal';
            const verticalOffset = STATE.config.text.verticalOffset || 1.0;

            // Additional vertical scaling factor to make text taller
            const verticalScaleFactor = 1.5;

            const textCanvas = document.createElement('canvas');
            const ctx = textCanvas.getContext('2d');

            // Set font for text measurements
            ctx.font = `${fontWeight} ${textSize}px "${selectedFont}"`;

            const isTimeFormat = /^\d+:\d+$/.test(text);

            // Get text metrics for proper sizing
            const textMetrics = ctx.measureText(text);

            // Calculate canvas dimensions with padding
            let canvasWidth, canvasHeight;

            if (isTimeFormat) {
                // For time format, use a consistent width
                const maxWidth = ctx.measureText("9:99").width;
                canvasWidth = maxWidth * 1.2; // 20% padding
                canvasHeight = textSize * 1.5;
            } else {
                // For end text, use its natural width
                canvasWidth = textMetrics.width * 1.2; // 20% padding
                canvasHeight = textSize * 1.5;
            }

            // Set canvas dimensions
            textCanvas.width = Math.ceil(canvasWidth);
            textCanvas.height = Math.ceil(canvasHeight);

            // Reset context after canvas resize
            ctx.font = `${fontWeight} ${textSize}px "${selectedFont}"`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

            // Generate points from the canvas pixels
            const points = [];
            const imageData = ctx.getImageData(0, 0, textCanvas.width, textCanvas.height).data;

            // Use the appropriate scale based on text type
            const baseScale = isTimeFormat ? textScale : endTextScale;

            // Calculate aspect ratio correction
            const canvasAspect = textCanvas.width / textCanvas.height;

            // Correct the aspect ratio to maintain original text proportions
            let xScale, yScale;

            if (canvasAspect < 1) {
                // Canvas is taller than wide, scale x to compensate
                xScale = baseScale / canvasAspect; // Make x wider
                yScale = baseScale * verticalScaleFactor; // Make y taller by the scale factor
            } else {
                // Canvas is wider than tall, scale y to compensate
                xScale = baseScale;
                yScale = (baseScale / canvasAspect) * verticalScaleFactor; // Make y taller
            }

            // Safe pixel sampling
            function samplePixel(x, y) {
                if (x < 0 || x >= textCanvas.width || y < 0 || y >= textCanvas.height) return 0;
                const index = (y * textCanvas.width + x) * 4 + 3;
                return index >= 0 && index < imageData.length ? imageData[index] : 0;
            }

            switch (STATE.config.behavior.ordering) {
                case 'vertical':
                    for (let x = 0; x < textCanvas.width; x += density) {
                        for (let y = 0; y < textCanvas.height; y += density) {
                            if (samplePixel(x, y) > 128) {
                                points.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * xScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * yScale * verticalOffset
                                });
                            }
                        }
                    }
                    break;

                case 'horizontal':
                    for (let y = 0; y < textCanvas.height; y += density) {
                        for (let x = 0; x < textCanvas.width; x += density) {
                            if (samplePixel(x, y) > 128) {
                                points.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * xScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * yScale * verticalOffset
                                });
                            }
                        }
                    }
                    break;

                case 'optimized':
                    const validPixels = [];
                    for (let x = 0; x < textCanvas.width; x += density) {
                        for (let y = 0; y < textCanvas.height; y += density) {
                            if (samplePixel(x, y) > 128) {
                                validPixels.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * xScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * yScale * verticalOffset
                                });
                            }
                        }
                    }

                    if (STATE.particles.previousPoints.size === 0) {
                        return validPixels;
                    }

                    const result = new Array(validPixels.length);
                    const usedPoints = new Set();
                    const unassignedIndices = new Set(Array.from({ length: validPixels.length }, (_, i) => i));

                    validPixels.forEach((point, i) => {
                        const key = `${point.x},${point.y}`;
                        const previousIndex = STATE.particles.previousPoints.get(key);

                        if (previousIndex !== undefined && previousIndex < validPixels.length) {
                            result[previousIndex] = point;
                            usedPoints.add(i);
                            unassignedIndices.delete(previousIndex);
                        }
                    });

                    const remainingPoints = validPixels.filter((_, i) => !usedPoints.has(i));
                    Array.from(unassignedIndices).forEach((index, i) => {
                        if (i < remainingPoints.length) {
                            result[index] = remainingPoints[i];
                        }
                    });

                    // Fill any undefined entries with default points
                    for (let i = 0; i < result.length; i++) {
                        if (!result[i]) {
                            result[i] = { x: 0, y: 0 };
                        }
                    }

                    return result;
            }

            return points;
        }

        function togglePause() {
            const pauseButton = document.getElementById('pauseButton');

            if (TIMER.paused) {
                // Resume timer
                TIMER.resume();
                STATE.timer.paused = false;
                pauseButton.classList.remove('play');
                pauseButton.classList.add('pause');

                // Resume animation
                STATE.timer.lastTime = performance.now() * 0.001;
                requestAnimationFrame(draw);
            } else {
                // Pause timer
                TIMER.pause();
                STATE.timer.paused = true;
                pauseButton.classList.remove('pause');
                pauseButton.classList.add('play');
            }
        }

        // Optimized rendering loop
        function draw(currentTime) {
            if (!STATE.timer.running) return;
            if (STATE.timer.paused) return;

            const drawStart = performance.now();
            currentTime *= 0.001;
            const deltaTime = Math.min(currentTime - STATE.timer.lastTime, 0.1);
            STATE.timer.lastTime = currentTime;

            const physicsStart = performance.now();
            const BATCH_SIZE = 1000;
            const particles = STATE.particles;
            const arrays = particles.arrays;
            const dampingRate = deltaTime * deltaTime;

            applyForces(deltaTime);

            for (let start = 0; start < particles.count; start += BATCH_SIZE) {
                const end = Math.min(start + BATCH_SIZE, particles.count);
                processParticleBatch(start, end, arrays, dampingRate, deltaTime);
            }

            STATE.stats.physicsTime = performance.now() - physicsStart;

            if (STATE.particles.activeCount < STATE.particles.count && !STATE.config.behavior.tickSyncRendering) {
                const mode = STATE.config.behavior.extraParticleMode;
                const points = [];
                const remainingPoints = STATE.particles.count - STATE.particles.activeCount;

                ParticleFunctions.applyToPoints(mode, points, remainingPoints);

                for (let i = STATE.particles.activeCount; i < STATE.particles.count; i++) {
                    const arrayIndex = i * 2;
                    const pointIndex = i - STATE.particles.activeCount;

                    if (points[pointIndex]) {
                        STATE.particles.arrays.setPoints[arrayIndex] = points[pointIndex].x;
                        STATE.particles.arrays.setPoints[arrayIndex + 1] = points[pointIndex].y;
                    }
                }
            }

            updateBuffers(arrays);
            render();

            STATE.stats.drawTime = performance.now() - drawStart;
            STATE.stats.frameCount++;

            if (currentTime - STATE.stats.lastFpsTime >= 1.0) {
                STATE.stats.fps = STATE.stats.frameCount;
                STATE.stats.frameCount = 0;
                STATE.stats.lastFpsTime = currentTime;
                STATE.stats.particleCount = particles.count;

                // Update stats display
                STATE.stats.element.textContent = `
                FPS: ${STATE.stats.fps}
                Particles: ${STATE.stats.particleCount}
                Draw Time: ${STATE.stats.drawTime.toFixed(2)}ms
                Physics Time: ${STATE.stats.physicsTime.toFixed(2)}ms
            `;
            }

            requestAnimationFrame(draw);
        }

        function processParticleBatch(start, end, arrays, dampingRate, deltaTime) {
            const particles = STATE.particles;
            for (let i = start; i < end; i++) {
                const idx = i * 2;
                const dx = arrays.setPoints[idx] - arrays.positions[idx];
                const dy = arrays.setPoints[idx + 1] - arrays.positions[idx + 1];

                arrays.velocities[idx] = arrays.velocities[idx] * arrays.dampings[i] * dampingRate +
                    dx * arrays.accelerations[i] + particles.externalForces[idx];
                arrays.velocities[idx + 1] = arrays.velocities[idx + 1] * arrays.dampings[i] * dampingRate +
                    dy * arrays.accelerations[i] + particles.externalForces[idx + 1];

                arrays.positions[idx] += arrays.velocities[idx] * deltaTime;
                arrays.positions[idx + 1] += arrays.velocities[idx + 1] * deltaTime;

                particles.externalForces[idx] = decayForce(particles.externalForces[idx], deltaTime);
                particles.externalForces[idx + 1] = decayForce(particles.externalForces[idx + 1], deltaTime);
            }
        }


        function render() {
            const gl = STATE.render.gl;

            gl.uniform2f(STATE.render.uniforms.resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(STATE.render.uniforms.glowIntensity, STATE.config.particles.appearance.glow.intensity);
            gl.uniform1f(STATE.render.uniforms.glowSize, STATE.config.particles.appearance.glow.size);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, STATE.particles.arrays.positions, gl.DYNAMIC_DRAW);

            if (STATE.particles.activeCount < STATE.particles.count) {
                gl.drawArrays(gl.POINTS, STATE.particles.activeCount, STATE.particles.count - STATE.particles.activeCount);
                gl.drawArrays(gl.POINTS, 0, STATE.particles.activeCount);
            } else {
                gl.drawArrays(gl.POINTS, 0, STATE.particles.activeCount);
            }
        }

        const TIMER = {
            endTime: 0,
            startTime: 0,
            msLeft: 0,
            isFirstTick: true,
            text: "",
            pauseTime: 0,
            timeoutId: null,
            paused: false,

            update() {
                if (this.paused) return;

                this.msLeft = this.endTime - (+new Date);
                const secondsLeft = Math.floor(this.msLeft / 1000);

                const secondsChanged = (this.previousSecondsLeft === undefined ||
                    secondsLeft !== this.previousSecondsLeft);

                if (secondsLeft <= 10 && secondsLeft >= 1) {
                    document.getElementById('tickSound').play();
                }

                if (this.msLeft < 1000) {
                    document.getElementById('timerComplete').play();
                    this.text = STATE.config.text.endText;
                } else {
                    const time = new Date(this.msLeft);
                    const mins = time.getUTCMinutes();
                    this.text = `${mins}:${twoDigits(time.getUTCSeconds())}`;
                    const delay = this.isFirstTick ? 1400 : 1000;
                    this.isFirstTick = false;
                    clearTimeout(this.timeoutId);
                    this.timeoutId = setTimeout(() => this.update(), delay);
                }

                const { realPointsLength, points } = getTextPoints(this.text, true);
                STATE.particles.activeCount = realPointsLength;

                if (secondsChanged || this.isFirstTick) {
                    this.lastPositionUpdate = performance.now();

                    for (let i = 0; i < STATE.particles.count; i++) {
                        STATE.particles.arrays.setPoints[i * 2] = points[i].x;
                        STATE.particles.arrays.setPoints[i * 2 + 1] = points[i].y;
                    }
                }
            },

            start(minutes, seconds) {
                this.endTime = (+new Date) + ((minutes * 60 + seconds) * 1000);
                this.startTime = (+new Date);
                this.isFirstTick = true;
                this.paused = false;
                STATE.timer.paused = false;
                this.update();
            },

            pause() {
                if (this.paused) return;

                this.paused = true;
                this.pauseTime = +new Date;

                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = null;
                }
            },

            resume() {
                if (!this.paused) return;

                const pauseDuration = (+new Date) - this.pauseTime;
                this.endTime += pauseDuration;

                this.paused = false;
                this.update();
            }
        };


        function setTime(minutes) {
            document.getElementById('minutes').value = minutes;
            document.getElementById('seconds').value = 0;

            initializeWithConfig(getConfigFromInputs(), minutes, 0);
            TIMER.start(minutes, 0);

            STATE.timer.paused = false;
            TIMER.paused = false;

            // Update button appearance
            const pauseButton = document.getElementById('pauseButton');
            pauseButton.classList.remove('play');
            pauseButton.classList.add('pause');
            pauseButton.style.display = 'flex'; // Use flex to center the icon

            STATE.menu.visible = false;
            document.getElementById('menu').style.display = 'none';
            STATE.timer.running = true;
            requestAnimationFrame(draw);
        }

        // Optimized initialization
        function init() {
            initGL();
            optimizedResize();
            STATE.canvas.rect = STATE.render.canvas.getBoundingClientRect();
            initUI();
            loadSavedFunctions();
            setupEventListeners();
            loadPresets();
            STATE.config = ConfigSchema.createDefault();

            loadLastUsedConfig();

            STATE.stats.element = document.createElement('div');
            Object.assign(STATE.stats.element.style, {
                position: 'fixed',
                width: '100vw',
                height: '100vh',
                margin: '0',
                padding: '20px',
                zIndex: '100',
                overflow: 'hidden'
            });
            document.body.appendChild(STATE.stats.element);

            const initialCode = ParticleFunctions.registry[document.getElementById('particleFunctionSelect').value];
            document.getElementById('particleFunctionEditor').value = formatCode(initialCode);
        }

        function loadSavedFunctions() {
            // Get all keys that start with particle_function_
            const functionKeys = Object.keys(localStorage).filter(key =>
                key.startsWith('particle_function_'));

            // Load each saved function
            functionKeys.forEach(key => {
                const functionName = key.replace('particle_function_', '');
                const functionBody = localStorage.getItem(key);

                if (functionBody) {
                    ParticleFunctions.register(functionName, functionBody);

                    // Add to the select dropdown if not already there
                    const select = document.getElementById('particleFunctionSelect');
                    if (!Array.from(select.options).some(opt => opt.value === functionName)) {
                        const option = document.createElement('option');
                        option.value = functionName;
                        option.textContent = functionName;
                        select.appendChild(option);
                    }

                    // Add to the behavior dropdown if not already there
                    const behaviorSelect = document.getElementById('behavior_extraParticleMode');
                    if (!Array.from(behaviorSelect.options).some(opt => opt.value === functionName)) {
                        const option = document.createElement('option');
                        option.value = functionName;
                        option.textContent = functionName;
                        behaviorSelect.appendChild(option);
                    }
                }
            });
        }

        function initUI() {
            const menu = document.getElementById('menu');

            // Add timer controls section
            const timerSection = document.createElement('div');
            timerSection.className = 'section';
            timerSection.innerHTML = `
                <button id="startTimer" style="padding: 10px 20px; margin-top: 20px;">Start Timer</button>
                <h3>Timer Settings</h3>
                <label>Minutes: <input type="number" id="minutes" min="0" value="1"></label>
                <label>Seconds: <input type="number" id="seconds" min="0" max="59" value="0"></label>
                <div style="margin-top: 10px;">
                    <button style="padding: 10px 20px;" onclick="setTime(5)">5 min</button>
                    <button style="padding: 10px 20px;" onclick="setTime(10)">10 min</button>
                    <button style="padding: 10px 20px;" onclick="setTime(20)">20 min</button>
                </div>
            `;
            menu.appendChild(timerSection);

            const particleFunctionSection = document.createElement('div');
            particleFunctionSection.className = 'section';
            particleFunctionSection.innerHTML = `
                <h3>Particle Function Editor</h3>
                <p style="font-size: 0.8em;">
                    Define how particles are positioned using JavaScript. Available variables:
                    <br>- angle: 0 to 2π for each particle
                    <br>- index: particle index
                    <br>- total: total particle count 
                    <br>- radius: configured radius
                    <br>- aspectRatio: screen aspect ratio
                    <br>- time: elapsed time in seconds
                    <br>- timer: timer object with progress information
                </p>
                <div style="display: flex; margin-bottom: 10px;">
                    <select id="particleFunctionSelect" style="flex: 2; margin-right: 10px;">
                        ${Object.keys(ParticleFunctions.registry).map(name =>
                `<option value="${name}">${name}</option>`
            ).join('')}
                    </select>
                    <input type="text" id="newFunctionName" placeholder="New function name" style="flex: 1;">
                    <button id="saveAsNewFunction" style="margin-left: 10px;">Save As New</button>
                </div>
                <textarea id="particleFunctionEditor" style="width: 100%; height: 150px; background: #333; color: white; font-family: monospace; padding: 10px; tab-size: 2; white-space: pre; overflow: auto;"></textarea>
                <div style="margin-top: 10px; display: flex; justify-content: space-between;">
                    <div>
                        <button id="updateFunction">Update Function</button>
                        <button id="applyFunction">Apply to Timer</button>
                    </div>
                    <div>
                        <button id="formatCode">Format Code</button>
                        <button id="insertTemplate">Insert Template</button>
                    </div>
                </div>
            `;
            menu.appendChild(particleFunctionSection);

            // Add preset style section
            const presetSection = document.createElement('div');
            presetSection.className = 'section';
            presetSection.innerHTML = `
                <h3>Particle Style</h3>
                <div style="display: flex; align-items: center; margin-bottom: 10px; max-width: 300px;">
                    <select id="presetStyle" style="width: auto; min-width: 150px; margin-right: 10px;">
                        <!-- Options will be added dynamically -->
                    </select>
                    <button id="deletePreset" style="background: #d44; padding: 5px 10px;">Delete</button>
                </div>
                <div id="presetInfo" style="font-size: 0.8em; font-style: italic; margin-bottom: 10px;">
                    Built-in presets cannot be deleted.
                </div>
            `;

            menu.appendChild(presetSection);

            const presetSelect = document.getElementById('presetStyle');

            Object.keys(PRESETS).forEach(presetName => {
                const option = document.createElement('option');
                option.value = presetName;

                const displayName = presetName
                    .replace(/([A-Z])/g, ' $1')
                    .replace(/^./, str => str.toUpperCase());

                option.textContent = displayName;
                presetSelect.appendChild(option);
            });


            const saveSection = document.createElement('div');
            saveSection.className = 'section';
            saveSection.innerHTML = `
                <h3>Save Configuration</h3>
                <label>Configuration Name: <input type="text" id="configName"></label>
                <button id="saveConfig">Save</button>
            `;

            menu.appendChild(saveSection);

            ConfigSchema.generateUI(menu);

            const paddingDiv = document.createElement('div');
            paddingDiv.style.paddingBottom = '80px';
            menu.appendChild(paddingDiv);
        }


        // Event handlers
        function setupEventListeners() {
            const canvas = STATE.render.canvas;

            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                STATE.menu.visible = true;
                document.getElementById('menu').style.display = 'block';
                document.getElementById('pauseButton').style.display = 'none';
            });

            document.getElementById('startTimer').addEventListener('click', () => {
                const minutes = parseInt(document.getElementById('minutes').value);
                const seconds = parseInt(document.getElementById('seconds').value);

                initializeWithConfig(getConfigFromInputs(), minutes, seconds);
                TIMER.start(minutes, seconds);

                // Reset pause state
                STATE.timer.paused = false;
                TIMER.paused = false;

                // Update button appearance
                const pauseButton = document.getElementById('pauseButton');
                pauseButton.classList.remove('play');
                pauseButton.classList.add('pause');
                pauseButton.style.display = 'flex';

                document.getElementById('menu').style.display = 'none';
                STATE.timer.running = true;
                STATE.menu.visible = false;
                requestAnimationFrame(draw);
            });

            document.getElementById('pauseButton').addEventListener('click', togglePause);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    STATE.menu.visible = false;
                    document.getElementById('menu').style.display = 'none';

                    if (STATE.timer.running && !TIMER.msLeft < 1000) {
                        document.getElementById('pauseButton').style.display = 'block';
                    }
                }

            });

            document.getElementById('fullscreenButton').addEventListener('click', () => {
                window.open('https://htmlpreview.github.io/?https://github.com/lexm2/particle-timer/blob/main/shadersOptimized.html', '_blank');
            });


            document.getElementById('colorPreset').addEventListener('change', (e) => {
                const colors = COLOR_PRESETS[e.target.value];
                const container = e.target.parentElement;
                updateColorPickers(colors, container);
                STATE.config.particles.appearance.colors = colors;
            });

            window.addEventListener('resize', optimizedResize);

            canvas.addEventListener('mousedown', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.down = true;
            });

            canvas.addEventListener('mouseup', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.down = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (STATE.menu.visible) return;
                const newMouseX = (e.clientX - STATE.canvas.rect.left) / STATE.canvas.rect.width * 2 - 1;
                const newMouseY = -((e.clientY - STATE.canvas.rect.top) / STATE.canvas.rect.height * 2 - 1);

                if (STATE.mouse.down) {
                    STATE.mouse.velocityX = newMouseX - STATE.mouse.x;
                    STATE.mouse.velocityY = newMouseY - STATE.mouse.y;
                }

                STATE.mouse.x = newMouseX;
                STATE.mouse.y = newMouseY;
            });

            canvas.addEventListener('click', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.clicked = true;
            });

            document.getElementById('presetStyle').addEventListener('change', (e) => {
                applyPreset(e.target.value);
            });

            document.getElementById('deletePreset').addEventListener('click', () => {
                const presetSelect = document.getElementById('presetStyle');
                const selectedPreset = presetSelect.value;

                if (Object.keys(PRESETS).includes(selectedPreset)) {
                    alert('Cannot delete built-in presets.');
                    return;
                }

                if (confirm(`Are you sure you want to delete the preset "${selectedPreset}"?`)) {
                    localStorage.removeItem('particle_timer_preset_' + selectedPreset);

                    STATE.presets.saved.delete(selectedPreset);

                    for (let i = 0; i < presetSelect.options.length; i++) {
                        if (presetSelect.options[i].value === selectedPreset) {
                            presetSelect.remove(i);
                            break;
                        }
                    }

                    presetSelect.selectedIndex = 0;
                    applyPreset(presetSelect.value);

                    console.log(`Deleted preset: ${selectedPreset}`);
                }
            });

            document.getElementById('saveConfig').addEventListener('click', () => {
                const configName = document.getElementById('configName').value;
                if (!configName) {
                    alert('Please enter a configuration name');
                    return;
                }

                const config = getConfigFromInputs();
                const storageName = 'particle_timer_preset_' + configName;

                saveLastUsedConfig(configName);

                STATE.presets.saved.set(configName, config);

                if (StorageUtils.set(storageName, config)) {
                    console.log(`Configuration "${configName}" saved successfully`);
                    // Optional: Show feedback to user
                    alert(`Configuration "${configName}" saved successfully`);
                } else {
                    alert('Failed to save configuration');
                }

                loadPresets();
                document.getElementById('configName').value = '';
            });

            const fontSelect = document.getElementById('text_font');
            if (fontSelect) {
                fontSelect.addEventListener('change', function () {
                    const fontPath = this.dataset.configPath;
                    const pathParts = fontPath.split('.');
                    let target = STATE.config;

                    for (let i = 0; i < pathParts.length - 1; i++) {
                        target = target[pathParts[i]];
                    }

                    target[pathParts[pathParts.length - 1]] = this.value;

                    if (STATE.timer.running) {
                        TIMER.update();
                    }
                });
            }

            const boldToggle = document.getElementById('text_isBold');
            if (boldToggle) {
                boldToggle.addEventListener('change', function () {
                    STATE.config.text.isBold = this.checked;
                    if (STATE.timer.running) {
                        TIMER.update();
                    }
                });
            }

            document.getElementById('particleFunctionSelect').addEventListener('change', function () {
                const functionName = this.value;
                let code = ParticleFunctions.registry[functionName];
                code = formatCode(code);

                document.getElementById('particleFunctionEditor').value = code;
            });


            document.getElementById('updateFunction').addEventListener('click', function () {
                const functionName = document.getElementById('particleFunctionSelect').value;
                let functionBody = document.getElementById('particleFunctionEditor').value;

                functionBody = trimCodeWhitespace(functionBody);

                ParticleFunctions.register(functionName, functionBody);

                // Save to localStorage
                localStorage.setItem(`particle_function_${functionName}`, functionBody);

                // If timer is running, update display
                if (STATE.timer.running) {
                    TIMER.update();
                }

                // Show feedback
                const button = this;
                const originalText = button.textContent;
                button.textContent = "Updated!";
                setTimeout(() => { button.textContent = originalText; }, 1000);
            });

            document.getElementById('saveAsNewFunction').addEventListener('click', function () {
                const newName = document.getElementById('newFunctionName').value.trim();
                if (!newName) {
                    alert("Please enter a name for the new function");
                    return;
                }

                let functionBody = document.getElementById('particleFunctionEditor').value;

                // Trim leading whitespace while preserving indentation structure
                functionBody = trimCodeWhitespace(functionBody);

                // Register the new function
                ParticleFunctions.register(newName, functionBody);

                // Save to localStorage
                localStorage.setItem(`particle_function_${newName}`, functionBody);

                // Update the select dropdown
                const option = document.createElement('option');
                option.value = newName;
                option.textContent = newName;
                document.getElementById('particleFunctionSelect').appendChild(option);
                document.getElementById('particleFunctionSelect').value = newName;

                // Update the behavior dropdown
                const behaviorSelect = document.getElementById('behavior_extraParticleMode');
                const newOption = document.createElement('option');
                newOption.value = newName;
                newOption.textContent = newName;
                behaviorSelect.appendChild(newOption);

                // Clear the name field
                document.getElementById('newFunctionName').value = '';

                // If timer is running, update display
                if (STATE.timer.running) {
                    TIMER.update();
                }
            });

            document.getElementById('formatCode').addEventListener('click', function () {
                const editor = document.getElementById('particleFunctionEditor');
                let code = editor.value;

                // Basic code formatting
                code = formatCode(code);

                editor.value = code;
            });

            document.getElementById('insertTemplate').addEventListener('click', function () {
                const template = `// Basic particle positioning template
                // Use angle, index, radius, and other variables to position particles
                // Return {x, y} coordinates for each particle

                const adjustedRadius = radius * (1 + 0.2 * Math.sin(time));

                return {
                x: Math.cos(angle) * adjustedRadius,
                y: Math.sin(angle) * adjustedRadius * aspectRatio
                };`;

                document.getElementById('particleFunctionEditor').value = template;
            });

            document.getElementById('applyFunction').addEventListener('click', function () {
                const functionName = document.getElementById('particleFunctionSelect').value;
                document.getElementById('behavior_extraParticleMode').value = functionName;
                STATE.config.behavior.extraParticleMode = functionName;

                if (STATE.timer.running) {
                    TIMER.update();
                }
            });

            // Initialize the function editor with the first function
            document.getElementById('particleFunctionEditor').value =
                ParticleFunctions.registry[document.getElementById('particleFunctionSelect').value];
        }

        function trimCodeWhitespace(code) {
            // Detect leading whitespace in the first non-empty line
            const lines = code.split('\n');
            let minIndent = Infinity;
            let firstNonEmptyLine = -1;

            // Find the common indentation level
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.trim() === '') continue;

                if (firstNonEmptyLine === -1) firstNonEmptyLine = i;

                const indent = line.match(/^[ \t]*/)[0].length;
                if (indent < minIndent) minIndent = indent;
            }

            // If we couldn't detect indentation, return the original code
            if (minIndent === Infinity || firstNonEmptyLine === -1) return code;

            // Remove the common indentation from all lines
            return lines.map(line => {
                if (line.trim() === '') return '';
                return line.substring(minIndent);
            }).join('\n');
        }

        function formatCode(code) {
            // Trim leading/trailing whitespace
            code = code.trim();

            // First, remove any common indentation
            code = trimCodeWhitespace(code);

            // Basic formatting for brackets, add newlines and indentation
            let formatted = '';
            let indent = 0;
            const lines = code.split('\n');

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();

                // Handle closing braces by reducing indent before adding them
                if (line.match(/^[}\])]/) && indent > 0) {
                    indent--;
                }

                // Add proper indentation
                if (line !== '') {
                    formatted += '  '.repeat(indent) + line + '\n';
                } else {
                    formatted += '\n';
                }

                // Count opening and closing braces to adjust indentation
                const openBraces = (line.match(/{|\[|\(/g) || []).length;
                const closeBraces = (line.match(/}|\]|\)/g) || []).length;

                // Special handling for lines that both open and close on the same line
                // but have a net opening count (e.g., "if (x) {")
                if (openBraces > closeBraces) {
                    indent++;
                }
            }

            return formatted;
        }


        function optimizedResize() {
            const pixelRatio = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;

            STATE.render.canvas.width = width * pixelRatio;
            STATE.render.canvas.height = height * pixelRatio;
            STATE.render.canvas.style.width = width + 'px';
            STATE.render.canvas.style.height = height + 'px';

            STATE.render.gl.viewport(0, 0, STATE.render.canvas.width, STATE.render.canvas.height);
            STATE.canvas.aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;
            STATE.canvas.rect = STATE.render.canvas.getBoundingClientRect();
        }

        init();

    </script>
</body>

</html>