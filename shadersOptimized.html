<!DOCTYPE html>
<html>

<head>
    <title>WebGL Particle Timer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
        }

        label {
            display: block;
            margin: 10px 0;
        }

        input,
        select {
            margin-left: 10px;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 3px;
        }

        button {
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }

        #pauseButton {
            transition: transform 0.3s ease !important;
            display: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #pauseButton:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }

        .pause-line {
            border-radius: 2px;
        }

        #pauseButton.play .pause-line.left {
            transform: translate(35%, 0) rotate(-45deg) scaleY(1.2);
        }

        #pauseButton.play .pause-line.right {
            transform: translate(35%, 0) rotate(45deg) scaleY(1.2);
        }

        #pauseButton.pause .pause-line.left {
            transform: none;
        }

        #pauseButton.pause .pause-line.right {
            transform: none;
        }

        #pauseButton.play {
            transform: rotate(-90deg);
        }

        #pauseButton:active {
            transform: scale(0.9);
        }
    </style>
</head>

<body>
    <div id="menu"
        style="position: fixed; width: 100vw; height: 100vh; background: rgba(0,0,0,0.9); color: white; padding: 20px 20px 80px 20px; font-family: Arial; z-index: 1000; overflow-y: auto; overflow-x: hidden;">
        <button id="fullscreenButton"
            style="position: absolute; top: 10px; right: 60px; padding: 10px 20px;">Fullscreen</button>
        <h2>Particle Timer Settings</h2>
    </div>
    <canvas id="glCanvas"></canvas>
    <div id="pauseButton"
        style="position: fixed; top: 20px; right: 20px; z-index: 1000; cursor: pointer; background-color: rgba(0,0,0,0.5); width: 50px; height: 50px; border-radius: 50%; display: none; justify-content: center; align-items: center; transition: background-color 0.3s;">
        <div id="pauseIcon" style="width: 50%; height: 50%; position: relative;">
            <div class="pause-line left"
                style="position: absolute; width: 30%; height: 100%; background-color: white; left: 0; transition: all 0.3s;">
            </div>
            <div class="pause-line right"
                style="position: absolute; width: 30%; height: 100%; background-color: white; right: 0; transition: all 0.3s;">
            </div>
        </div>
    </div>
    <audio id="tickSound" src="https://assets.mixkit.co/active_storage/sfx/2568/2568.wav"></audio>
    <audio id="timerComplete" src="https://assets.mixkit.co/active_storage/sfx/2865/2865.wav"></audio>

    <script type="x-shader/x-vertex" id="vertex-shader">
        attribute vec2 a_position;
        attribute vec3 a_color;
        attribute float a_size;
        varying vec3 v_color;
    
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            gl_PointSize = a_size;
            v_color = a_color;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragment-shader">
        precision mediump float;
        varying vec3 v_color;
        uniform float u_glow_intensity;
        uniform float u_glow_size;
    
        void main() {
            vec2 coord = gl_PointCoord * 2.0 - 1.0;
            float dist = length(coord);
            
            float core = 1.0 - step(0.5, dist);
            
            float glow = u_glow_intensity > 0.0 ? 
                u_glow_intensity * exp(-dist * (1.0 / u_glow_size)) * (1.0 - dist) : 
                0.0;
            
            float alpha = core + glow;
            gl_FragColor = vec4(v_color, alpha);
        }
    </script>




    <script>
        // Replace the existing COLOR_PRESETS object with this expanded version
        const COLOR_PRESETS = {
            // Original presets
            neonLights: [
                [1.0, 0.0, 1.0],  // Magenta
                [0.0, 1.0, 1.0],  // Cyan
                [1.0, 1.0, 0.0]   // Yellow
            ],
            pastelDream: [
                [0.95, 0.61, 0.73],  // Pink
                [0.56, 0.93, 0.56],  // Mint
                [0.68, 0.85, 0.90],  // Sky
                [0.97, 0.85, 0.45],  // Yellow
                [0.85, 0.75, 0.95]   // Lavender
            ],
            oceanBreeze: [
                [0.29, 0.31, 0.30],  // Dark teal
                [0.05, 0.60, 0.65],  // Turquoise
                [0.24, 0.64, 0.67],  // Sea blue
                [0.96, 0.80, 0.38],  // Sand
                [0.99, 0.54, 0.44]   // Coral
            ],
            sunset: [
                [0.98, 0.37, 0.05],  // Orange-red
                [0.98, 0.64, 0.18],  // Orange
                [0.91, 0.84, 0.42],  // Yellow
                [0.69, 0.19, 0.38],  // Deep purple
                [0.44, 0.28, 0.56]   // Violet
            ],
            cyberpunk: [
                [0.94, 0.21, 0.59],  // Hot pink
                [0.07, 0.91, 0.91],  // Bright cyan
                [0.98, 0.98, 0.06],  // Electric yellow
                [0.6, 0.0, 0.8],     // Purple
                [0.13, 0.05, 0.19]   // Dark purple
            ],
            forestGlade: [
                [0.13, 0.55, 0.13],  // Forest green
                [0.42, 0.56, 0.14],  // Olive
                [0.68, 0.85, 0.32],  // Light green
                [0.88, 0.87, 0.74],  // Beige
                [0.55, 0.27, 0.07]   // Brown
            ],
            retroWave: [
                [0.93, 0.0, 0.54],   // Hot pink
                [0.16, 0.84, 0.99],  // Bright blue
                [0.99, 0.42, 0.52],  // Salmon
                [0.47, 0.04, 0.65],  // Purple
                [0.11, 0.0, 0.31]    // Deep blue
            ],
            candyShop: [
                [0.97, 0.39, 0.53],  // Bubblegum
                [0.99, 0.71, 0.38],  // Orange
                [0.55, 0.93, 0.55],  // Mint
                [0.38, 0.69, 0.96],  // Sky blue
                [0.91, 0.44, 0.99]   // Lavender
            ],
            fireAndIce: [
                [0.99, 0.24, 0.0],   // Fire red
                [0.99, 0.56, 0.0],   // Orange
                [0.0, 0.66, 0.98],   // Ice blue
                [0.0, 0.47, 0.75],   // Blue
                [0.93, 0.9, 0.81]    // Off-white
            ],
            monochrome: [
                [0.0, 0.0, 0.0],     // Black
                [0.2, 0.2, 0.2],     // Dark gray
                [0.4, 0.4, 0.4],     // Gray
                [0.7, 0.7, 0.7],     // Light gray
                [1.0, 1.0, 1.0]      // White
            ],
            tropicalParadise: [
                [0.95, 0.36, 0.25],  // Coral
                [0.16, 0.73, 0.58],  // Teal
                [0.99, 0.85, 0.21],  // Sunshine
                [0.0, 0.6, 0.45],    // Palm
                [0.95, 0.61, 0.07]   // Mango
            ],
            galaxyDust: [
                [0.07, 0.03, 0.15],  // Deep space
                [0.17, 0.05, 0.35],  // Purple space
                [0.19, 0.28, 0.54],  // Cosmic blue
                [0.67, 0.55, 0.85],  // Lavender
                [0.93, 0.89, 0.99]   // Stardust
            ],
            autumnLeaves: [
                [0.55, 0.27, 0.07],  // Brown
                [0.82, 0.33, 0.0],   // Rust
                [0.91, 0.45, 0.0],   // Orange
                [0.99, 0.75, 0.0],   // Golden
                [0.6, 0.2, 0.0]      // Deep red
            ],
            winterFrost: [
                [0.88, 0.94, 0.99],  // Ice white
                [0.69, 0.85, 0.93],  // Pale blue
                [0.5, 0.67, 0.85],   // Cold blue
                [0.26, 0.45, 0.68],  // Winter blue
                [0.13, 0.21, 0.37]   // Deep blue
            ],
            rainbowVibrant: [
                [0.93, 0.11, 0.14],  // Red
                [0.99, 0.59, 0.0],   // Orange
                [0.99, 0.91, 0.0],   // Yellow
                [0.0, 0.75, 0.22],   // Green
                [0.0, 0.51, 0.98],   // Blue
                [0.45, 0.0, 0.88]    // Purple
            ],
            darkMode: [
                [0.13, 0.13, 0.13],  // Dark gray
                [0.2, 0.2, 0.2],     // Medium gray
                [0.33, 0.33, 0.33],  // Gray
                [0.93, 0.93, 0.93],  // Light gray
                [0.0, 0.48, 1.0]     // Accent blue
            ],
            mintChocolate: [
                [0.36, 0.82, 0.55],  // Mint
                [0.2, 0.63, 0.46],   // Dark mint
                [0.37, 0.22, 0.13],  // Chocolate
                [0.23, 0.12, 0.05],  // Dark chocolate
                [0.85, 0.99, 0.85]   // Light mint
            ],
            berryBliss: [
                [0.75, 0.0, 0.19],   // Raspberry
                [0.53, 0.0, 0.27],   // Cranberry
                [0.34, 0.0, 0.25],   // Blackberry
                [0.2, 0.0, 0.36],    // Dark purple
                [0.95, 0.68, 0.79]   // Light pink
            ],
            goldLuxury: [
                [0.83, 0.69, 0.22],  // Gold
                [0.52, 0.39, 0.0],   // Dark gold
                [0.95, 0.87, 0.51],  // Light gold
                [0.13, 0.13, 0.13],  // Black
                [0.93, 0.93, 0.93]   // White
            ],
            marineDeep: [
                [0.0, 0.05, 0.16],   // Deep marine
                [0.0, 0.11, 0.33],   // Dark blue
                [0.0, 0.22, 0.49],   // Navy
                [0.0, 0.46, 0.74],   // Ocean blue
                [0.39, 0.83, 0.96]   // Sky blue
            ],
            cottonCandy: [
                [0.99, 0.62, 0.77],  // Pink
                [0.99, 0.84, 0.92],  // Light pink
                [0.85, 0.65, 0.93],  // Lavender
                [0.69, 0.88, 0.9],   // Light blue
                [0.99, 0.93, 0.64]   // Light yellow
            ],
            electroNight: [
                [0.05, 0.05, 0.05],  // Almost black
                [0.33, 0.0, 0.5],    // Deep purple
                [0.0, 0.4, 0.6],     // Deep blue
                [0.0, 0.8, 0.8],     // Cyan
                [0.0, 1.0, 0.0]      // Neon green
            ]
        };

        // Optimized particle modes
        const ParticleFunctions = {
            registry: {},
            builtInFunctions: new Set(),

            register(name, functionBody) {
                this.registry[name] = functionBody;
            },

            registerBuiltIn(name, functionBody) {
                this.builtInFunctions.add(name);
                this.registry[name] = functionBody;
            },

            getFunction(name) {
                if (!this.registry[name]) {
                    console.warn(`Particle function "${name}" not found, falling back to circle pattern`);
                    return this.registry['circle'];
                }
                return this.registry[name];
            },

            applyToPoints(modeName, points, remainingPoints) {
                const radius = STATE.config.behavior.radius;
                const aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;
                const animationTime = performance.now() / 1000;

                const timerInfo = {
                    msLeft: TIMER.msLeft || 0,
                    endTime: TIMER.endTime || 0,
                    progress: 0,
                    totalDuration: 0
                };

                if (TIMER.endTime) {
                    timerInfo.totalDuration = TIMER.endTime - TIMER.startTime;
                    timerInfo.progress = Math.max(0, Math.min(1, TIMER.msLeft / timerInfo.totalDuration));
                }

                try {
                    const functionBody = this.getFunction(modeName);

                    const createPoint = new Function(
                        'angle', 'index', 'total', 'radius', 'aspectRatio',
                        'time', 'timer',
                        functionBody
                    );

                    for (let i = 0; i < remainingPoints; i++) {
                        const angle = i * (2 * Math.PI / remainingPoints);
                        const newPoint = createPoint(angle, i, remainingPoints, radius, aspectRatio, animationTime, timerInfo);
                        points.push(newPoint);
                    }
                } catch (error) {
                    console.error(`Error in particle function "${modeName}":`, error);
                    console.log(`Function parameters: radius=${radius}, aspectRatio=${aspectRatio}, timerInfo=`, timerInfo);
                    this.fallbackCircle(points, remainingPoints);
                }
            },

            fallbackCircle(points, remainingPoints) {
                const radius = STATE.config.behavior.radius;
                const aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;

                for (let i = 0; i < remainingPoints; i++) {
                    const angle = i * (2 * Math.PI / remainingPoints);
                    points.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius * aspectRatio
                    });
                }
            }
        };

        ParticleFunctions.registerBuiltIn('progressCircle', `
            // Get progress directly from the timer object or calculate it
            let progressPercentage;
            
            if (timer && typeof timer.progress === 'number') {
                // Use provided progress if available
                progressPercentage = timer.progress;
            } else if (typeof TIMER !== 'undefined' && TIMER.msLeft && TIMER.initialDuration) {
                // Calculate directly if we have the needed values
                progressPercentage = Math.max(0, Math.min(1, TIMER.msLeft / TIMER.initialDuration));
            } else {
                // Fallback to a simple calculation if all else fails
                const totalTimeEstimate = 60 * 1000; // Assume 1 minute timer
                progressPercentage = Math.max(0, Math.min(1, (TIMER.msLeft || 0) / totalTimeEstimate));
            }
            
            // Ensure we have a valid value between 0 and 1
            progressPercentage = Math.max(0.01, Math.min(1, progressPercentage || 0));
            
            // Calculate full circle angle
            const fullCircle = 2 * Math.PI;
            
            // Scale the angle to fit within the progress percentage
            // This redistributes all particles to fit within the available arc
            const scaledAngle = angle * progressPercentage;
            
            // Position particles using the scaled angle
            return {
                x: Math.cos(scaledAngle) * radius,
                y: Math.sin(scaledAngle) * radius * aspectRatio
            };
        `);


        ParticleFunctions.registerBuiltIn('circle', `
            return {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius * aspectRatio
            };
        `);

        ParticleFunctions.registerBuiltIn('center', `
            return { x: 0, y: 0 };
        `);

        ParticleFunctions.registerBuiltIn('wave', `
            const x = ((index / total) * 2 - 1) * radius;
            const waveAmplitude = radius * 0.5;
            const waveFrequency = 5;
            
            return {
                x: x,
                y: Math.sin(x * waveFrequency / radius) * waveAmplitude * aspectRatio
            };
        `);

        ParticleFunctions.registerBuiltIn('fountain', `
            const fountainBase = -0.8;
            
            return {
                x: (Math.random() * 2 - 1) * radius * 0.5,
                y: fountainBase * aspectRatio
            };
        `);

        ParticleFunctions.registerBuiltIn('offScreenCircle', `
            const largeRadius = radius * 3;
            
            return {
                x: Math.cos(angle) * largeRadius,
                y: Math.sin(angle) * largeRadius
            };
        `);

        // Add some dynamic, time-based functions
        ParticleFunctions.registerBuiltIn('pulsatingCircle', `
    // Create a pulse that repeats every second
    const pulsePhase = (time % 1);
    
    // Fast out, slow in easing function
    // This creates a quick expansion followed by a slower contraction
    const easeOutIn = (t) => {
        // Fast expansion (first 30% of the cycle)
        if (t < 0.3) {
            // Quadratic ease-out for quick expansion
            return 1 - (1 - t/0.3) * (1 - t/0.3);
        } 
        // Slow contraction (remaining 70% of the cycle)
        else {
            // Cubic ease-in for slower contraction
            const normalized = (t - 0.3) / 0.7;
            return 1 - normalized * normalized * normalized;
        }
    };
    
    // Calculate pulse size multiplier
    const baseSize = 0.7;  // Minimum size
    const pulseAmount = 0.6;  // Maximum additional size (more explosive)
    const sizeMultiplier = baseSize + pulseAmount * easeOutIn(pulsePhase);
    
    // Add a slight wave effect for more visual interest
    const waveEffect = 0.05 * Math.sin(angle * 3 + time * 2);
    
    // Calculate final position with the pulse effect
    return {
        x: Math.cos(angle) * radius * (sizeMultiplier + waveEffect),
        y: Math.sin(angle) * radius * aspectRatio * (sizeMultiplier + waveEffect)
    };
`);


        ParticleFunctions.registerBuiltIn('dynamicSpiral', `
            const distance = (index / total) * radius * (1 + 0.2 * Math.sin(time));
            const extraAngle = time * 0.5;
            
            return {
                x: Math.cos(angle + extraAngle) * distance,
                y: Math.sin(angle + extraAngle) * distance * aspectRatio
            };
        `);

        ParticleFunctions.registerBuiltIn('flower', `
            const petals = 5;
            const petalSize = 0.3 + 0.1 * Math.sin(time);
            const modifiedRadius = radius * (1 + petalSize * Math.sin(petals * angle));
            
            return {
                x: Math.cos(angle) * modifiedRadius,
                y: Math.sin(angle) * modifiedRadius * aspectRatio
            };
        `);

        ParticleFunctions.registerBuiltIn('orbit', `
            // Main center
            if (index === 0) return { x: 0, y: 0 };

            // Orbiting bodies
            const orbitCount = 3;
            const orbitIndex = index % orbitCount;
            const particlesPerOrbit = Math.floor(total / orbitCount);
            const particleInOrbitIndex = Math.floor(index / orbitCount);
            const orbitRadius = (orbitIndex + 1) * radius / orbitCount;
            const orbitAngle = (particleInOrbitIndex / particlesPerOrbit) * 2 * Math.PI + time * (0.5 / (orbitIndex + 1));

            return {
                x: Math.cos(orbitAngle) * orbitRadius,
                y: Math.sin(orbitAngle) * orbitRadius * aspectRatio
            };
        `);

        ParticleFunctions.registerBuiltIn('galaxySwirl', `
    // Distance from center affects speed and orbit size
    const distanceFromCenter = index / total * radius;
    
    // Particles move faster near the center (inverse square law like real galaxies)
    const orbitSpeed = 2 / (distanceFromCenter + 0.1);
    
    // Spiral arm effect
    const armCount = 3;
    const armOffset = (index % armCount) * (2 * Math.PI / armCount);
    const spiralTightness = 2;
    
    // Calculate position
    const orbitAngle = armOffset + (index * spiralTightness / total) + (time * orbitSpeed);
    const x = Math.cos(orbitAngle) * distanceFromCenter;
    const y = Math.sin(orbitAngle) * distanceFromCenter * aspectRatio;
    
    return { x, y };
`);

        ParticleFunctions.registerBuiltIn('quantumEntanglement', `
    // Create two focal points that particles oscillate between
    const focalDistance = radius * 0.7;
    const focus1 = { x: -focalDistance, y: 0 };
    const focus2 = { x: focalDistance, y: 0 };
    
    // Each particle oscillates at a slightly different frequency
    const particleFreq = 1 + (index / total) * 0.5;
    
    // Calculate oscillation (0 to 1) for this particle
    const oscillation = (Math.sin(time * particleFreq) + 1) / 2;
    
    // Apply some quantum "fuzziness" - particles get more uncertain in the middle
    const uncertainty = Math.sin(oscillation * Math.PI) * 0.3 * radius;
    const randomAngle = (index * 77.7 + time) % (2 * Math.PI); // Pseudo-random angle
    
    // Interpolate between the two foci based on oscillation
    const x = focus1.x + (focus2.x - focus1.x) * oscillation + Math.cos(randomAngle) * uncertainty;
    const y = (focus1.y + (focus2.y - focus1.y) * oscillation + Math.sin(randomAngle) * uncertainty) * aspectRatio;
    
    return { x, y };
`);

        ParticleFunctions.registerBuiltIn('dualOrbits', `
    // Determine which system this particle belongs to
    const isFirstSystem = index % 2 === 0;
    
    // System centers
    const system1X = -radius * 0.3;
    const system2X = radius * 0.3;
    
    // Orbit characteristics
    const orbitIndex = Math.floor(index / 2);
    const systemSize = total / 2;
    const orbitRadius = (orbitIndex / systemSize) * radius * 0.4;
    const orbitSpeed = 1 + (1 - orbitIndex / systemSize) * 2; // Smaller orbits move faster
    
    // Calculate position based on which system
    let x, y;
    if (isFirstSystem) {
        const angle = (orbitIndex / systemSize) * Math.PI * 4 + time * orbitSpeed;
        x = system1X + Math.cos(angle) * orbitRadius;
        y = Math.sin(angle) * orbitRadius;
    } else {
        const angle = (orbitIndex / systemSize) * Math.PI * 4 - time * orbitSpeed;
        x = system2X + Math.cos(angle) * orbitRadius;
        y = Math.sin(angle) * orbitRadius;
    }
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('dnaHelix', `
    // Helix parameters
    const helixRadius = radius * 0.3;
    const helixPitch = 2.5; // How stretched the helix is
    const helixSpeed = 0.5; // Rotation speed
    
    // Determine which strand (1 or 2) the particle belongs to
    const strand = index % 2 === 0 ? 1 : -1;
    
    // Position along the helix (0 to 1)
    const helixPos = (Math.floor(index / 2) / Math.floor(total / 2));
    
    // Height along the y-axis
    const y = (helixPos * 2 - 1) * radius;
    
    // Angle around the helix
    const helixAngle = helixPos * helixPitch * Math.PI + time * helixSpeed;
    
    // Calculate position - strand determines which side of the helix
    const x = Math.cos(helixAngle) * helixRadius * strand;
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('aurora', `
    // Wave parameters
    const waveAmplitude = radius * 0.4;
    const waveFrequency = 3; // Number of waves
    const waveSpeed = 0.8; // How fast the waves move
    
    // Distribute particles horizontally
    const x = ((index / total) * 2 - 1) * radius;
    
    // Create vertical waves
    const baseHeight = 0.1;
    const waveOffset = Math.sin(x * waveFrequency + time * waveSpeed) * waveAmplitude;
    
    // Add small random movements for a more natural effect
    const flicker = Math.sin(index * 0.3 + time * 3) * 0.07 * radius;
    
    // Calculate final position
    const y = baseHeight + waveOffset + flicker;
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('magneticField', `
    // Set up two magnetic poles
    const poleDistance = radius * 0.8;
    const northPole = { x: -poleDistance, y: 0 };
    const southPole = { x: poleDistance, y: 0 };
    
    // Assign each particle to a field line
    const fieldLineCount = Math.ceil(total / 4);
    const lineIndex = index % fieldLineCount;
    const linePosition = Math.floor(index / fieldLineCount) / 4; // 0 to 1
    
    // Each field line starts at a different angle from the north pole
    const startAngle = (lineIndex / fieldLineCount) * Math.PI;
    
    // Parametric equation for magnetic field line
    const t = linePosition + 0.1 * Math.sin(time + lineIndex); // Add some movement
    
    // Field strength weakens with distance from poles
    const fieldStrength = 0.8 + 0.2 * Math.sin(time * 0.5);
    
    // Calculate position
    let x, y;
    if (t < 0.5) {
        // Path from north to south pole
        const angle = startAngle + (1 - t * 2) * Math.PI; // Range from startAngle to startAngle+PI
        const distance = poleDistance * Math.sin(t * Math.PI) * fieldStrength;
        x = northPole.x + Math.cos(angle) * distance;
        y = Math.sin(angle) * distance;
    } else {
        // Path from south back to north pole
        const angle = startAngle + Math.PI + ((t - 0.5) * 2) * Math.PI; // Range from startAngle+PI to startAngle+2PI
        const distance = poleDistance * Math.sin((1 - t) * Math.PI) * fieldStrength;
        x = southPole.x + Math.cos(angle) * distance;
        y = Math.sin(angle) * distance;
    }
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('fractalTree', `
    // Tree parameters
    const iterations = 6; // Number of branching levels
    const branchAngle = Math.PI / 5; // Angle between branches
    
    // Calculate which branch this particle belongs to
    const branchIndex = Math.floor(index / (total / Math.pow(2, iterations)));
    
    // Convert branch index to a binary path (left/right decisions)
    let path = branchIndex.toString(2).padStart(iterations, '0');
    
    // Start at the base of the tree
    let x = 0;
    let y = -radius * 0.9; // Bottom of the screen
    let angle2 = 0; // Growing upward
    let branchLength = radius * 0.3; // Length of the trunk
    
    // Trace the path through the tree
    for (let i = 0; i < path.length; i++) {
        const isRight = path[i] === '1';
        
        // Branch grows at an angle from the parent branch
        angle2 += (isRight ? 1 : -1) * branchAngle;
        
        // Branches get shorter at each level
        branchLength *= 0.7;
        
        // Move to the end of this branch
        const growthFactor = Math.min(1, time % 5 / 3); // Tree grows over time
        const currentLength = branchLength * growthFactor;
        
        x += Math.sin(angle2) * currentLength;
        y += Math.cos(angle2) * currentLength;
    }
    
    // Add a small random movement to create a leaf rustle effect
    x += Math.sin(time * 3 + index) * 0.01 * radius;
    y += Math.cos(time * 2 + index) * 0.01 * radius;
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('quantumWaveFunction', `
    // Position atom center
    const atomX = 0;
    const atomY = 0;
    
    // Quantum parameters
    const n = 1 + Math.floor((index % 4) / 2); // Principal quantum number
    const l = Math.floor(index % 2);  // Angular momentum
    
    // Time-based phase
    const phase = time * 0.5;
    
    // Calculate probability wave
    const distance = 0.3 * radius * n;
    const waveFreq = 5 - n;
    
    // Each electron cloud has a different orbital shape
    const orbitAngle = (index / total) * Math.PI * 2 + phase;
    
    // Lissajous-like orbital patterns
    const lFreq1 = n + 0.5;
    const lFreq2 = l + 1;
    
    // Calculate final position
    const x = atomX + distance * Math.cos(orbitAngle * lFreq1) * Math.cos(phase);
    const y = atomY + distance * Math.sin(orbitAngle * lFreq2) * Math.sin(phase);
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.register('particleAccelerator', `
    // Parameters for the accelerator
    const ringRadius = radius * 0.8;
    const ringCenterX = radius * 0.1; // Slightly off-center
    const ringCenterY = -radius * 0.1;
    
    // Particle streams with different speeds
    const streamCount = 2;
    const streamIndex = index % streamCount;
    
    // Determine rotation direction and speed for each stream
    const direction = streamIndex === 0 ? 1 : -1;
    const baseSpeed = 1 + streamIndex * 0.2;
    
    // Position along the stream (0 to 1)
    const positionInStream = Math.floor(index / streamCount) / Math.floor(total / streamCount);
    
    // Calculate angle around the ring - rename "angle" to "ringAngle"
    const ringAngle = (positionInStream * Math.PI * 2) + (time * baseSpeed * direction);
    
    // Small radial oscillation
    const radialOffset = Math.sin(ringAngle * 8 + time * 3) * 0.03 * radius;
    
    // Calculate position on the ring
    const x = ringCenterX + (ringRadius + radialOffset) * Math.cos(ringAngle);
    const y = ringCenterY + (ringRadius + radialOffset) * Math.sin(ringAngle);
    
    // Periodic collision effect - particles briefly scatter
    const collisionTime = Math.floor(time / 2) * 2; // Collision every 2 seconds
    const timeSinceCollision = time - collisionTime;
    
    // During collision, particles briefly scatter
    if (timeSinceCollision < 0.3) {
        const scatterAmount = Math.sin(timeSinceCollision * Math.PI / 0.3) * 0.2 * radius;
        const scatterAngle = index * 1.618; // Golden ratio for nice distribution
        return {
            x: x + Math.cos(scatterAngle) * scatterAmount,
            y: (y + Math.sin(scatterAngle) * scatterAmount) * aspectRatio
        };
    }
    
    return { x, y: y * aspectRatio };
`);


        ParticleFunctions.register('circuitBoard', `
    // Circuit parameters
    const pathCount = 5; // Number of circuit paths
    const segmentCount = 4; // Segments per path
    
    // Determine which circuit path this particle is on
    const pathIndex = index % pathCount;
    const particleInPath = Math.floor(index / pathCount) / Math.floor(total / pathCount);
    
    // Circuit starting points (all off to the sides)
    const startX = -1;
    const startY = -0.7 + pathIndex * (radius * 0.4);
    
    // Predetermined circuit layout
    const segments = [
        // Each subarray defines segmentAngle and length for a segment
        [0, 0.3],    // Right
        [Math.PI/2, 0.2],  // Up
        [0, 0.4],    // Right
        [Math.PI*3/2, 0.3], // Down
        [0, 0.5],    // Right
    ];
    
    // Calculate which segment this particle is in
    const segmentLength = 1 / segments.length;
    const currentSegment = Math.min(segments.length - 1, 
                                Math.floor(particleInPath / segmentLength));
    const segmentProgress = (particleInPath % segmentLength) / segmentLength;
    
    // Start at the beginning of the circuit
    let x = startX;
    let y = startY;
    
    // Trace the path up to the current segment
    for (let i = 0; i < currentSegment; i++) {
        const [segmentAngle, length] = segments[i];
        x += Math.cos(segmentAngle) * length * radius * 2;
        y += Math.sin(segmentAngle) * length * radius * 2;
    }
    
    // Add the partial segment
    const [currentAngle, currentLength] = segments[currentSegment];
    x += Math.cos(currentAngle) * currentLength * radius * 2 * segmentProgress;
    y += Math.sin(currentAngle) * currentLength * radius * 2 * segmentProgress;
    
    // Add data pulse effect
    const pulseFreq = 3; // Pulses per circuit
    const pulseWidth = 0.1;
    const pulseSpeed = 1.5;
    
    const pulsePosition = (time * pulseSpeed) % 1;
    const distFromPulse = Math.abs(particleInPath - pulsePosition);
    const inPulse = distFromPulse < pulseWidth || distFromPulse > (1 - pulseWidth);
    
    // Make particles brighter when the pulse passes (handled by caller)
    
    // Add slight movement perpendicular to direction
    const perpAngle = currentAngle + Math.PI/2;
    const oscAmount = inPulse ? 0.02 : 0.01;
    x += Math.cos(perpAngle) * Math.sin(particleInPath * Math.PI * 8 + time * 3) * oscAmount * radius;
    y += Math.sin(perpAngle) * Math.sin(particleInPath * Math.PI * 8 + time * 3) * oscAmount * radius;
    
    return { x, y: y * aspectRatio };
`);


        ParticleFunctions.registerBuiltIn('fluidDynamics', `
    // Flow parameters
    const flowSpeed = 0.5;
    const flowDirection = 0; // Flowing left to right
    
    // Obstacle parameters
    const obstacleCount = 3;
    const obstacles = [];
    
    // Create fixed obstacle positions
    for (let i = 0; i < obstacleCount; i++) {
        obstacles.push({
            x: (i * 0.5 - 0.5) * radius,
            y: (Math.sin(i * 2.1) * 0.3) * radius,
            radius: (0.1 + i * 0.03) * radius
        });
    }
    
    // Distribute particles evenly in the flow
    const flowWidth = radius * 1.8;
    const gridSize = Math.ceil(Math.sqrt(total));
    const gridX = index % gridSize;
    const gridY = Math.floor(index / gridSize);
    
    // Base position in the flow
    let x = ((gridX / gridSize) * 2 - 1) * flowWidth;
    let y = ((gridY / gridSize) * 2 - 1) * radius * 0.7;
    
    // Move the whole flow based on time
    x = (x + time * flowSpeed) % (flowWidth * 2) - flowWidth;
    
    // Calculate fluid dynamics around obstacles
    for (let obstacle of obstacles) {
        const dx = x - obstacle.x;
        const dy = y - obstacle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < obstacle.radius * 3) {
            // Particles get displaced around the obstacle
            const angle = Math.atan2(dy, dx);
            const influence = Math.max(0, 1 - distance / (obstacle.radius * 3));
            
            // Displacement strength increases as particles get closer
            const displacement = obstacle.radius * influence * influence * 2;
            
            // Apply displacement perpendicular to the line to the obstacle
            // This creates a swirling effect around the obstacle
            x += Math.sin(angle) * displacement;
            y -= Math.cos(angle) * displacement;
        }
    }
    
    // Add small random motion for fluid turbulence
    x += Math.sin(index * 0.1 + time * 2) * 0.015 * radius;
    y += Math.cos(index * 0.1 + time * 3) * 0.015 * radius;
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('gravitationalSlingshot', `

    const xOffset = 0.4;
    const yOffset = -0.1;
    // Define gravitational bodies
    const bodies = [
        { x: -radius * 1, y: -radius * 0.3, mass: 1.0 },
        { x: radius * 0.6, y: radius * 0.4, mass: 0.7 }
    ];
    
    // Particle orbit parameters
    const orbitIndex = index % 8; // Different orbital groups
    const orbitOffset = (orbitIndex / 8) * Math.PI * 2;
    const particleInOrbit = Math.floor(index / 8) / Math.floor(total / 8);
    
    // Time-based phase
    const basePhase = time * 0.5 + orbitOffset;
    
    // Calculate the gravitational dance
    let x = 0;
    let y = 0;
    
    // Different orbit shapes for different groups
    const a = 0.8 + (orbitIndex % 3) * 0.2; // Orbit eccentricity
    const b = 1.0 - (orbitIndex % 2) * 0.3;
    
    // Base elliptical orbit
    const orbitProgress = (basePhase + particleInOrbit * Math.PI * 2) % (Math.PI * 2);
    x = Math.cos(orbitProgress) * a * radius * 0.5;
    y = Math.sin(orbitProgress) * b * radius * 0.5;
    
    // Apply gravitational influences from the bodies
    for (let body of bodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Skip if too close to prevent extreme acceleration
        if (distance < 0.1 * radius) continue;
        
        // Calculate gravitational influence
        const force = body.mass / (distance * distance) * 0.1 * radius;
        
        // Apply gravitational force
        x -= (dx / distance) * force;
        y -= (dy / distance) * force;
    }
    
    // Shift everything to keep particles away from center
    x += radius * 0.1;
    y -= radius * 0.2;
    
    return { x: y * aspectRatio + xOffset, y: x + yOffset};
`);

        ParticleFunctions.registerBuiltIn('particleDiffraction', `
    // Parameters for the diffraction pattern
    const sourceX = -radius * 0.8; // Source off to the left
    const slitY = radius * 0.4; // Slit position
    const slitGap = radius * 0.1; // Space between slits
    const slitCount = 3; // Number of slits
    
    // Determine which "beam" this particle belongs to
    const beamIndex = index % total;
    const beamProgress = (beamIndex / total) * 2 * Math.PI;
    
    // Calculate which slit this particle goes through
    const slitIndex = beamIndex % slitCount;
    const slitOffset = (slitIndex - (slitCount - 1) / 2) * slitGap;
    
    // Wave parameters
    const waveSpeed = 0.7;
    const wavelength = 0.3;
    
    // Distance from the source (0 to 1)
    const distanceProgress = (1 + Math.sin(beamProgress)) / 2;
    
    // Calculate position based on wave diffraction
    let x, y;
    
    if (distanceProgress < 0.5) {
        // Before the slit, particles move in straight lines
        const preSlitProgress = distanceProgress * 2;
        x = sourceX + (radius * 0.8) * preSlitProgress;
        y = slitOffset * preSlitProgress;
    } else {
        // After the slit, particles create interference pattern
        const postSlitProgress = (distanceProgress - 0.5) * 2;
        
        // Distance from slit
        const distFromSlit = postSlitProgress * radius;
        
        // Wave phase angle - particles from different slits have different phases
        const phaseOffset = slitIndex * Math.PI * 2 / slitCount;
        const wavePhase = time * waveSpeed + phaseOffset;
        
        // Diffraction angle increases with distance
        const diffractionAngle = Math.sin(wavePhase) * Math.min(1, postSlitProgress * 3) * 0.3;
        
        x = 0 + distFromSlit * Math.cos(diffractionAngle);
        y = slitOffset + distFromSlit * Math.sin(diffractionAngle);
    }
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('neuralNetwork', `
    // Neural network parameters
    const layers = [4, 6, 5, 2]; // Neurons per layer
    const layerCount = layers.length;
    const layerSpacing = radius * 1.6 / layerCount;
    
    // Determine which path this particle travels
    const pathIndex = index % 20; // Different connection paths
    const particleProgress = (Math.floor(index / 20) / Math.floor(total / 20) + time * 0.1) % 1;
    
    // Source and target neurons
    const sourceLayer = Math.floor(pathIndex % (layerCount - 1));
    const sourceNeuron = pathIndex % layers[sourceLayer];
    const targetLayer = sourceLayer + 1;
    const targetNeuron = (pathIndex + Math.floor(pathIndex / 3)) % layers[targetLayer];
    
    // Calculate positions of the neurons
    const getLayerX = (layer) => -radius * 0.7 + layer * layerSpacing;
    const getNeuronY = (layer, neuron) => {
        const neuronCount = layers[layer];
        return ((neuron / (neuronCount - 1)) * 2 - 1) * radius * 0.5;
    };
    
    const sourceX = getLayerX(sourceLayer);
    const sourceY = getNeuronY(sourceLayer, sourceNeuron);
    const targetX = getLayerX(targetLayer);
    const targetY = getNeuronY(targetLayer, targetNeuron);
    
    // Add a curved path between neurons
    const pathCurvature = 0.2;
    const midX = (sourceX + targetX) / 2;
    const controlX = midX;
    const controlY = (sourceY + targetY) / 2 + (Math.sin(pathIndex * 0.7) * pathCurvature * radius);
    
    // Bezier curve interpolation
    const t = particleProgress;
    const u = 1 - t;
    const x = u*u*sourceX + 2*u*t*controlX + t*t*targetX;
    const y = u*u*sourceY + 2*u*t*controlY + t*t*targetY;
    
    // Pulse effect
    const pulsePhase = (pathIndex * 0.1 + time) % 1;
    const isPulse = Math.abs(particleProgress - pulsePhase) < 0.05;
    
    // Pulse causes particles to move slightly away from the path
    if (isPulse) {
        const normal = Math.atan2(targetY - sourceY, targetX - sourceX) + Math.PI/2;
        return {
            x: x + Math.cos(normal) * 0.03 * radius,
            y: (y + Math.sin(normal) * 0.03 * radius) * aspectRatio
        };
    }
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('maxwellsDemon', `
    // Two-chamber system
    const chamberWidth = radius * 0.8;
    const chamberHeight = radius * 0.7;
    const wallX = 0; // Central dividing wall
    
    // Demon's gate
    const gateY = 0;
    const gateSize = radius * 0.1;
    const gateOpen = (Math.sin(time) + 1) / 2 > 0.7; // Gate opens periodically
    
    // Determine which chamber this particle belongs to
    const chamberIndex = index % 2; // 0 = left, 1 = right
    const particleInChamber = Math.floor(index / 2) / Math.floor(total / 2);
    
    // Left chamber has slower particles (cold), right has faster ones (hot)
    const speedFactor = chamberIndex === 0 ? 1.0 : 2.0;
    
    // Calculate particle initial position in the chamber
    let startX = (chamberIndex === 0 ? -1 : 1) * (chamberWidth / 2);
    let startY = (particleInChamber * 2 - 1) * chamberHeight;
    
    // Calculate movement angle based on index
    const particleAngle = index * 0.1 + time * speedFactor;
    
    // Movement delta
    const moveDistance = 0.1 * radius * speedFactor;
    let deltaX = Math.cos(particleAngle) * moveDistance;
    let deltaY = Math.sin(particleAngle) * moveDistance;
    
    // Potential position
    let newX = startX + deltaX;
    let newY = startY + deltaY;
    
    // Handle wall collisions
    if (newX > chamberWidth || newX < -chamberWidth) {
        deltaX = -deltaX; // Bounce off side walls
        newX = startX + deltaX;
    }
    
    if (newY > chamberHeight || newY < -chamberHeight) {
        deltaY = -deltaY; // Bounce off top/bottom
        newY = startY + deltaY;
    }
    
    // Handle central wall collision, except at the gate
    const nearGate = Math.abs(newY - gateY) < gateSize;
    if (Math.abs(newX - wallX) < 0.02 * radius && !nearGate) {
        deltaX = -deltaX; // Bounce off central wall
        newX = startX + deltaX;
    }
    
    // Demon's gate logic - allow certain particles through the gate
    if (nearGate && Math.abs(newX - wallX) < 0.05 * radius) {
        if (gateOpen) {
            // When gate is open, let particles through
            // Particles can change chambers
        } else {
            // Gate is closed, bounce off
            deltaX = -deltaX;
            newX = startX + deltaX;
        }
    }
    
    return { x: newX, y: newY * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('dataStreams', `
    // Data stream parameters
    const streamCount = 5;
    const streamSpacing = radius * 0.3;
    const streamSpeed = 0.7;
    
    // Packet parameters
    const packetSize = 0.05;
    const packetSpacing = 0.2;
    
    // Determine which stream this particle belongs to
    const streamIndex = index % streamCount;
    const particleInStream = Math.floor(index / streamCount) / Math.floor(total / streamCount);
    
    // Generate a stream path with some variability
    const streamY = (streamIndex - (streamCount - 1) / 2) * streamSpacing;
    
    // Calculate stream curve using sine waves with different frequencies
    const streamAmplitude = 0.1 * radius;
    const streamFreq1 = 1 + streamIndex * 0.2;
    const streamFreq2 = 2.5 - streamIndex * 0.15;
    
    // Stream position along x-axis
    const baseX = -radius + (particleInStream + time * streamSpeed) % 2 * radius * 2;
    
    // Calculate position on the curved stream
    const streamCurve = Math.sin(baseX * 0.5 * streamFreq1 + time) * 
                      Math.cos(baseX * 0.3 * streamFreq2) * 
                      streamAmplitude;
    
    // Group particles into data packets
    const packetPhase = (particleInStream + time * streamSpeed) % 1;
    const packetProgress = packetPhase % packetSpacing;
    const inPacket = packetProgress < packetSize;
    
    // Position on stream
    let x = baseX;
    let y = streamY + streamCurve;
    
    // When in a packet, particles cluster together
    if (inPacket) {
        const packetOffset = (index * 53.37) % (2 * Math.PI); // Semi-random offset
        const clusterRadius = 0.02 * radius;
        
        x += Math.cos(packetOffset) * clusterRadius;
        y += Math.sin(packetOffset) * clusterRadius;
    }
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('brownianMotion', `
    // Containment area
    const areaX = -radius * 0;
    const areaY = radius * 0;
    const areaWidth = radius * 0.9;
    const areaHeight = radius * 0.7;
    
    // Get a deterministic but seemingly random position using noise
    const noise = (x, y) => {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        return Math.sin(X * 12.9898 + Y * 78.233) * 43758.5453 % 1;
    };
    
    // Generate position that changes over time but is consistent per particle
    const noiseScale = 0.5;
    const timeScale = 1.5;
    
    // Generate noise offsets in 4D space-time
    const nx = noise(index * noiseScale, time * timeScale);
    const ny = noise(index * noiseScale + 100, time * timeScale);
    
    // Convert noise to position within the containment area
    const x = areaX + areaWidth * (nx * 0.8 + 0.1);
    const y = areaY + areaHeight * (ny * 0.8 + 0.1);
    
    // Occasional particle collisions cause sudden direction changes
    const collisionChance = (noise(index, Math.floor(time * 4)) > 0.97);
    
    if (collisionChance) {
        // Simulate collision with another particle
        const collisionAngle = noise(index, time * 10) * Math.PI * 2;
        const collisionForce = 0.06 * radius;
        
        return {
            x: x + Math.cos(collisionAngle) * collisionForce,
            y: (y + Math.sin(collisionAngle) * collisionForce) * aspectRatio
        };
    }
    
    return { x, y: y * aspectRatio };
`);

        ParticleFunctions.registerBuiltIn('spikeGrowth', `
    // Rain parameters
    const columnCount = 20;  // Increased number of columns
    const columnSpacing = radius * 1.8 / columnCount;
    
    // Determine which column this particle belongs to
    const columnIndex = index % columnCount;
    const particleInColumn = Math.floor(index / columnCount) / Math.floor(total / columnCount);
    
    // Column starting positions - spread across the screen
    const startX = -radius * 0.8 + columnIndex * columnSpacing;
    
    // Deterministic random values for this column/particle
    const randomSeed = columnIndex * 43758.5453 + 12345.67;
    const randomValue = Math.sin(randomSeed) * 0.5 + 0.5;  // 0-1 range
    
    // Different columns have different speeds and lengths
    const fallSpeed = 0.2 + randomValue * 0.5;
    const columnLength = 0.3 + randomValue * 0.5;  // How much of the column is filled with particles
    
    // Offset each column's start time
    const columnOffset = (columnIndex * 13.7) % 1;
    const columnTime = (time + columnOffset) % 3;  // Cycle every 3 seconds
    
    // Calculate position in the spike
    let rainPhase = (particleInColumn * columnLength + columnTime * fallSpeed) % 1;
    
    // Fade out at different heights - randomized stopping points
    const fadeOutHeight = -0.7 + randomValue * 1.3;  // Between -0.7 and 0.6
    
    // When the particle gets below its stopping height, reset it off-screen
    if (-rainPhase * 2 + 1 < fadeOutHeight) {
        // Instead of continuing downward, move back to top off-screen
        rainPhase = -0.2 - randomValue * 0.2;
    }
    
    // Vertical position - falling from top to bottom
    let y = rainPhase * 2 - 1;  // Map 0-1 to +1 to -1
    
    // Add subtle variations to each column
    const curvature = (Math.sin(columnIndex * 0.4) * 0.1) * Math.sin(rainPhase * Math.PI);
    
    // Group particles into "character" clusters with varying density
    const charHeight = 0.02 + randomValue * 0.03;
    const charIndex = Math.floor(rainPhase / charHeight);
    
    // Calculate final position
    let x = startX + curvature * radius;
    
    // Add slight horizontal drift based on position and time
    const drift = Math.sin(y * 3 + time + columnIndex) * 0.01 * radius;
    
    // Leading character glows brighter (handled elsewhere)
    const isLeadingChar = rainPhase % columnLength < charHeight;
    
    // Occasionally skip some character positions for more natural look
    const skipChar = (charIndex * columnIndex) % 7 === 0;
    if (skipChar) {
        y -= charHeight * 1.5;  // Move this particle down to create a gap
    }
    
    return { x: x + drift, y: y * aspectRatio };
`);


        ParticleFunctions.registerBuiltIn('superconductingFlux', `
    // Superconductor parameters
    const ringRadius = radius * 0.7;
    const ringCenterX = 0; // Offset from center
    const ringCenterY = 0;
    const fluxDensity = 5; // Number of flux lines
    
    // Determine which flux line this particle belongs to
    const fluxIndex = index % fluxDensity;
    const particleInFlux = Math.floor(index / fluxDensity) / Math.floor(total / fluxDensity);
    
    // Calculate base position on the ring
    const ringPhase = fluxIndex / fluxDensity * Math.PI * 2;
    const ringProgress = (particleInFlux + time * 0.2) % 1;
    const ringAngle = ringPhase + ringProgress * Math.PI * 2;
    
    // Calculate magnetic field strength (oscillating)
    const magneticField = Math.sin(time * 0.5) * 0.5 + 0.5;
    
    // In a superconductor, magnetic flux gets quantized into vortices
    const vortexEffect = Math.sin(ringProgress * Math.PI * 10 + time * 3) * 
                         0.05 * radius * magneticField;
    
    // Calculate position on the ring
    const x = ringCenterX + Math.cos(ringAngle) * (ringRadius + vortexEffect);
    const y = ringCenterY + Math.sin(ringAngle) * (ringRadius + vortexEffect);
    
    // Particles also spiral around the flux lines
    const spiralRadius = 0.02 * radius;
    const spiralFrequency = 20;
    const spiralPhase = ringProgress * spiralFrequency + time * 5;
    const spiralX = Math.cos(spiralPhase) * spiralRadius;
    const spiralY = Math.sin(spiralPhase) * spiralRadius;
    
    return { x: x + spiralX, y: (y + spiralY) * aspectRatio };
`);

        // Particle Configuration System
        const ConfigSchema = {
            fields: {
                particles: {
                    position: {
                        min: { type: 'number', min: -2, max: 0, step: 0.1, default: -0.7 },
                        spread: { type: 'number', min: 0, max: 3, step: 0.1, default: 1.2 }
                    },
                    physics: {
                        acceleration: {
                            base: { type: 'number', min: 0, max: 20, step: 0.5, default: 3 },
                            variation: { type: 'number', min: 0, max: 10, step: 0.5, default: 3 }
                        },
                        damping: {
                            base: { type: 'number', min: 0.8, max: 0.999, step: 0.001, default: 0.95 },
                            variation: { type: 'number', min: 0, max: 0.1, step: 0.001, default: 0.04 }
                        }
                    },
                    appearance: {
                        size: {
                            base: { type: 'number', min: 1, max: 20, default: 15 },
                            variation: { type: 'number', min: 0, max: 75, default: 10 }
                        },
                        colors: {
                            type: 'colorArray',
                            presets: COLOR_PRESETS,
                            default: COLOR_PRESETS.oceanBreeze
                        },
                        glow: {
                            intensity: { type: 'number', min: 0.1, max: 10, step: 0.1, default: 0.3 },
                            size: { type: 'number', min: 0.1, max: 10, step: 0.1, default: 2.0 }
                        }
                    },
                    mouseBehavior: {
                        pushForce: { type: 'number', min: 0, max: 5000, default: 1500 },
                        pushRadius: { type: 'number', min: 0, max: 500, default: 100 }
                    },
                },
                text: {
                    size: { type: 'number', min: 100, max: 400, default: 30 },
                    scale: { type: 'number', min: 0.1, max: 2, step: 0.1, default: 0.6 },
                    verticalOffset: { type: 'number', min: -10, max: 10, step: 0.01, default: 1 },
                    endTextScale: { type: 'number', min: 0.1, max: 2, step: 0.1, default: 1 },
                    density: { type: 'number', min: 1, max: 5, default: 1 },
                    endText: { type: 'string', default: 'Time\'s up!' },
                    font: {
                        type: 'select',
                        options: [
                            "Arial", "Courier New", "Georgia", "Times New Roman", "Verdana",
                            "Helvetica", "Impact", "Tahoma", "Trebuchet MS", "Comic Sans MS",
                            "Arial Black", "Lucida Console", "Lucida Sans Unicode", "Palatino Linotype",
                            "Book Antiqua", "Garamond", "MS Sans Serif", "MS Serif"
                        ],
                        default: "Courier New"
                    },
                    isBold: { type: 'boolean', default: true }

                },
                behavior: {
                    ordering: {
                        type: 'select',
                        options: ['vertical', 'horizontal', 'optimized'],
                        default: 'vertical'
                    },
                    radius: { type: 'number', min: 0.5, max: 3, step: 0.1, default: 0.8 },
                    extraParticleMode: {
                        type: 'select',
                        options: Object.keys(ParticleFunctions.registry),
                        default: 'progressCircle'
                    },
                    tickSyncRendering: { type: 'boolean', default: false }
                }
            },

            createDefault() {
                return this.createFromSchema(this.fields);
            },

            createFromSchema(schema) {
                const result = {};
                Object.entries(schema).forEach(([key, value]) => {
                    if (value.type) {
                        result[key] = value.default;
                    } else {
                        result[key] = this.createFromSchema(value);
                    }
                });
                return result;
            },

            generateUI(container) {
                this.buildUIFromSchema(this.fields, container);
            },

            buildUIFromSchema(schema, container, path = '') {
                Object.entries(schema).forEach(([key, value]) => {
                    const currentPath = path ? `${path}.${key}` : key;

                    if (value.type) {
                        container.appendChild(this.createControl(key, value, currentPath));
                    } else {
                        const section = document.createElement('div');
                        section.className = 'section';
                        section.innerHTML = `<h3>${key.charAt(0).toUpperCase() + key.slice(1)}</h3>`;
                        this.buildUIFromSchema(value, section, currentPath);
                        container.appendChild(section);
                    }
                });
            },

            createControl(key, config, path) {
                const label = document.createElement('label');
                label.textContent = key.charAt(0).toUpperCase() + key.slice(1) + ': ';

                const input = this.createInputByType(config);
                input.id = path.replace(/\./g, '_');
                input.dataset.configPath = path;

                label.appendChild(input);
                return label;
            },

            createInputByType(config) {
                let container, select, input, opt;

                switch (config.type) {
                    case 'colorArray':
                        container = document.createElement('div');
                        container.id = 'colorPickers';

                        select = document.createElement('select');
                        select.id = 'colorPreset';
                        Object.keys(COLOR_PRESETS).forEach(presetName => {
                            opt = document.createElement('option');
                            opt.value = presetName;
                            opt.textContent = presetName;
                            select.appendChild(opt);
                        });
                        container.appendChild(select);

                        config.default.forEach(color => {
                            input = document.createElement('input');
                            input.type = 'color';
                            input.className = 'particleColor';
                            input.value = `#${color.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('')}`;
                            container.appendChild(input);
                        });

                        return container;

                    case 'number':
                        input = document.createElement('input');
                        input.type = 'number';
                        input.min = config.min;
                        input.max = config.max;
                        input.step = config.step || 1;
                        input.value = config.default;
                        return input;

                    case 'select':
                        select = document.createElement('select');


                        if (config.options[0] === "Arial") {
                            config.options.forEach(option => {
                                opt = document.createElement('option');
                                opt.value = option;
                                opt.textContent = option;
                                opt.style.fontFamily = option;
                                select.appendChild(opt);
                            });
                        } else {
                            // Regular select handling
                            config.options.forEach(option => {
                                opt = document.createElement('option');
                                opt.value = option;
                                opt.textContent = option;
                                select.appendChild(opt);
                            });
                        }

                        select.value = config.default;
                        return select;
                    case 'string':
                        input = document.createElement('input');
                        input.type = 'text';
                        input.value = config.default;
                        return input;
                    case 'boolean':
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = config.default;
                        return input;
                }
            }
        };

        function detectAvailableFonts(fontArray) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const referenceFont = 'monospace';
            const testString = 'mmmmmmmmmmlli';

            ctx.font = `16px ${referenceFont}`;
            const referenceFontWidth = ctx.measureText(testString).width;

            const availableFonts = fontArray.filter(font => {
                ctx.font = `16px "${font}", ${referenceFont}`;
                const testWidth = ctx.measureText(testString).width;

                return testWidth !== referenceFontWidth;
            });

            if (!availableFonts.includes('Courier New')) {
                availableFonts.unshift('Courier New');
            }

            return availableFonts;
        }

        function updateColorPickers(colors, container) {
            Array.from(container.querySelectorAll('.particleColor')).forEach(picker => picker.remove());

            colors.forEach(color => {
                const input = document.createElement('input');
                input.type = 'color';
                input.className = 'particleColor';
                const hexColor = `#${color.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('')}`;
                input.value = hexColor;
                container.appendChild(input);
            });
        }

        // Core state management
        const STATE = {
            config: null,
            presets: {
                current: null,
                saved: new Map(),
            },
            mouse: {
                x: 0,
                y: 0,
                velocityX: 0,
                velocityY: 0,
                clicked: false,
                down: false
            },
            particles: {
                arrays: null,
                count: 0,
                activeCount: 0,
                previousPoints: new Map(),
                externalForces: null
            },
            render: {
                canvas: null,
                gl: null,
                program: null,
                buffers: {
                    position: null,
                    size: null,
                    color: null
                },
                attributes: {
                    position: null,
                    size: null,
                    color: null
                }
            },
            stats: {
                frameCount: 0,
                lastFpsTime: 0,
                fps: 0,
                element: null
            },
            timer: {
                running: false,
                paused: false,
                lastTime: 0
            },
            canvas: {
                rect: null,
                aspectRatio: 1
            },
            menu: {
                visible: true
            }
        };

        const PRESETS = {
            minimal: {
                particles: {
                    position: {
                        min: -0.7,
                        spread: 1.2
                    },
                    physics: {
                        acceleration: {
                            base: 3,
                            variation: 3
                        },
                        damping: {
                            base: 0.95,
                            variation: 0.04
                        }
                    },
                    appearance: {
                        size: {
                            base: 5,
                            variation: 10
                        },
                        colors: COLOR_PRESETS.oceanBreeze,
                        glow: {
                            intensity: 0.3,
                            size: 1.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 1500,
                        pushRadius: 100
                    },
                },
                text: {
                    size: 30,
                    scale: 0.6,
                    density: 1
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "progressCircle",
                    radius: 0.6
                }
            },

            neon: {
                particles: {
                    position: {
                        min: -0.9,
                        spread: 1.8
                    },
                    physics: {
                        acceleration: {
                            base: 5,
                            variation: 5.0
                        },
                        damping: {
                            base: 0.99,
                            variation: 0.005
                        }
                    },
                    appearance: {
                        size: {
                            base: 1,
                            variation: 2.0
                        },
                        colors: COLOR_PRESETS.neonLights,

                        glow: {
                            intensity: 1,
                            size: 1.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 1000,
                        pushRadius: 100
                    },
                },
                text: {
                    size: 280,
                    scale: 1,
                    density: 2
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "orbit",
                    radius: 3
                }
            },
            sunset: {
                particles: {
                    appearance: {
                        size: {
                            base: 8,
                            variation: 12
                        },
                        colors: COLOR_PRESETS.sunset,
                        glow: {
                            intensity: 0.6,
                            size: 2.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 4.5,
                            variation: 2
                        },
                        damping: {
                            base: 0.97,
                            variation: 0.02
                        }
                    }
                },
                text: {
                    size: 50,
                    scale: 0.7,
                    font: "Impact",
                    font: "Georgia",
                    isBold: true
                },
                behavior: {
                    ordering: "optimized", // Methodical effect
                    extraParticleMode: "wave",
                    radius: 1.2
                }
            },
            cyberpunk: {
                particles: {
                    position: {
                        min: -5,
                        spread: 8
                    },
                    appearance: {
                        size: {
                            base: 4,
                            variation: 15
                        },
                        colors: COLOR_PRESETS.cyberpunk,
                        glow: {
                            intensity: 1.8,
                            size: 3.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 10,
                            variation: 4
                        }
                    },
                    mouseBehavior: {
                        pushForce: 2500,
                        pushRadius: 150
                    }
                },
                text: {
                    size: 50,
                    scale: 0.7,
                    density: 1,
                    font: "Impact",
                },
                behavior: {
                    extraParticleMode: "pulsatingCircle",
                    ordering: "horizontal",
                    radius: 1
                }
            },

            forestGlade: {
                particles: {
                    appearance: {
                        size: {
                            base: 6,
                            variation: 8
                        },
                        colors: COLOR_PRESETS.forestGlade,
                        glow: {
                            intensity: 0.2,
                            size: 1.2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 3,
                            variation: 3
                        },
                        damping: {
                            base: 0.98,
                            variation: 0.01
                        }
                    },
                    mouseBehavior: {
                        pushForce: 2500,
                        pushRadius: 150
                    }
                },
                text: {
                    size: 40,
                    scale: 0.65,
                    density: 1,
                    font: "Garamond",
                    isBold: false
                },
                behavior: {
                    ordering: "optimized", // Methodical effect
                    extraParticleMode: "circle"
                }
            },

            retroWave: {
                particles: {
                    appearance: {
                        size: {
                            base: 3,
                            variation: 6
                        },
                        colors: COLOR_PRESETS.retroWave,
                        glow: {
                            intensity: 1.2,
                            size: 2.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 2500,
                        pushRadius: 150
                    },
                    physics: {
                        acceleration: {
                            base: 5,
                            variation: 5,
                        },
                    },
                },
                text: {
                    size: 60,
                    scale: 0.8,
                    font: "Arial Black",
                    isBold: true
                },
                behavior: {
                    ordering: "horizontal",
                    extraParticleMode: "wave",
                    radius: 2
                }
            },

            candyShop: {
                particles: {
                    appearance: {
                        size: {
                            base: 7,
                            variation: 10
                        },
                        colors: COLOR_PRESETS.candyShop,
                        glow: {
                            intensity: 0.4,
                            size: 1.8
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 3.5,
                            variation: 2.5
                        }
                    },
                    mouseBehavior: {
                        pushForce: 2500,
                        pushRadius: 150
                    },
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Comic Sans MS",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "progressCircle",
                    radius: 0.7
                }
            },

            fireAndIce: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 15
                        },
                        colors: COLOR_PRESETS.fireAndIce,
                        glow: {
                            intensity: 0.7,
                            size: 2.2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 4,
                            variation: 3
                        }
                    }
                },
                text: {
                    size: 50,
                    scale: 0.75,
                    density: 1,
                    font: "Trebuchet MS",
                    isBold: true
                },
                behavior: {
                    ordering: "horizontal", // Glitch effect for fire/ice contrast
                    extraParticleMode: "fountain"
                }
            },

            monochrome: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 3
                        },
                        colors: COLOR_PRESETS.monochrome,
                        glow: {
                            intensity: 2,
                            size: 2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2.5,
                            variation: 1.0
                        },
                        damping: {
                            base: 0.97,
                            variation: 0.01
                        }
                    }
                },
                text: {
                    size: 60,
                    scale: 1,
                    density: 1,
                    font: "Courier New",
                    isBold: false
                },
                behavior: {
                    ordering: "optimized",
                    extraParticleMode: "superconductingFlux",
                    radius: 1.5
                }
            },

            tropicalParadise: {
                particles: {
                    appearance: {
                        size: {
                            base: 8,
                            variation: 12
                        },
                        colors: COLOR_PRESETS.tropicalParadise,
                        glow: {
                            intensity: 0.5,
                            size: 2.0
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Verdana",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "particleDiffraction",
                    radius: 1.2
                }
            },

            galaxyDust: {
                particles: {
                    position: {
                        spread: 1.5
                    },
                    appearance: {
                        size: {
                            base: 2,
                            variation: 18
                        },
                        colors: COLOR_PRESETS.galaxyDust,
                        glow: {
                            intensity: 1.5,
                            size: 3.0
                        }
                    },
                    physics: {
                        damping: {
                            base: 0.99,
                            variation: 0.005
                        }
                    }
                },
                text: {
                    size: 55,
                    scale: 0.8,
                    font: "Palatino Linotype",
                    isBold: true
                },
                behavior: {
                    ordering: "optimized", // Methodical for space-like precision
                    extraParticleMode: "orbit",
                    radius: 1.5
                }
            },

            autumnLeaves: {
                particles: {
                    appearance: {
                        size: {
                            base: 15,
                            variation: 8
                        },
                        colors: COLOR_PRESETS.autumnLeaves,
                        glow: {
                            intensity: 0.3,
                            size: 1.5
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2,
                            variation: 8
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Book Antiqua",
                    isBold: false
                },
                behavior: {
                    ordering: "horizontal", // Glitch-like for falling leaves effect
                    extraParticleMode: "gravitationalSlingshot",
                    radius: 1.1
                }
            },

            winterFrost: {
                particles: {
                    appearance: {
                        size: {
                            base: 4,
                            variation: 6
                        },
                        colors: COLOR_PRESETS.winterFrost,
                        glow: {
                            intensity: 0.8,
                            size: 2.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 2.7,
                            variation: 1.5
                        },
                        damping: {
                            base: 0,
                            variation: 0
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Tahoma",
                    isBold: false
                },
                behavior: {
                    ordering: "optimized", // Methodical for snowflake precision
                    extraParticleMode: "circle",
                    radius: 0.8
                }
            },

            rainbowVibrant: {
                particles: {
                    appearance: {
                        size: {
                            base: 7,
                            variation: 10
                        },
                        colors: COLOR_PRESETS.rainbowVibrant,
                        glow: {
                            intensity: 0.6,
                            size: 1.8
                        }
                    }
                },
                text: {
                    size: 50,
                    scale: 0.75,
                    density: 1,
                    font: "Lucida Sans Unicode",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "quantumWaveFunction",
                    radius: 2
                }
            },

            darkMode: {
                particles: {
                    appearance: {
                        size: {
                            variation: 0
                        },
                        colors: COLOR_PRESETS.darkMode,
                        glow: {
                            intensity: 1,
                            size: 2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 7,
                            variation: 5.0
                        },
                    },
                },
                text: {
                    size: 50,
                    scale: 1,
                    font: "MS Sans Serif",
                    isBold: true
                },
                behavior: {
                    ordering: "optimized",
                    extraParticleMode: "offScreenCircle",
                }
            },

            mintChocolate: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 7
                        },
                        colors: COLOR_PRESETS.mintChocolate,
                        glow: {
                            intensity: 0.3,
                            size: 1.6
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Lucida Console",
                    isBold: false
                },
                behavior: {
                    ordering: "horizontal",
                    extraParticleMode: "fountain"
                }
            },

            berryBliss: {
                particles: {
                    appearance: {
                        size: {
                            base: 6,
                            variation: 9
                        },
                        colors: COLOR_PRESETS.berryBliss,
                        glow: {
                            intensity: 0.7,
                            size: 2.0
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Times New Roman",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical", // Glitch effect
                    extraParticleMode: "brownianMotion",
                    radius: 2
                }
            },

            goldLuxury: {
                particles: {
                    appearance: {
                        size: {
                            base: 4,
                            variation: 6
                        },
                        colors: COLOR_PRESETS.goldLuxury,
                        glow: {
                            intensity: 1.1,
                            size: 2.2
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 3,
                            variation: 1.5
                        },
                        damping: {
                            base: 0.5,
                            variation: 1
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Garamond",
                    isBold: true
                },
                behavior: {
                    ordering: "optimized",
                    extraParticleMode: "progressCircle",
                    radius: 0.9
                }
            },

            marineDeep: {
                particles: {
                    appearance: {
                        size: {
                            base: 5,
                            variation: 8
                        },
                        colors: COLOR_PRESETS.marineDeep,
                        glow: {
                            intensity: 0.9,
                            size: 2.4
                        }
                    },
                    physics: {
                        damping: {
                            base: 0.98,
                            variation: 0.01
                        }
                    }
                },
                text: {
                    size: 45,
                    scale: 0.7,
                    density: 1,
                    font: "Helvetica",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "fluidDynamics",
                    radius: 1.1
                }
            },

            cottonCandy: {
                particles: {
                    appearance: {
                        size: {
                            base: 7,
                            variation: 9
                        },
                        colors: COLOR_PRESETS.cottonCandy,
                        glow: {
                            intensity: 0.4,
                            size: 1.7
                        }
                    }
                },
                text: {
                    size: 40,
                    scale: 0.65,
                    density: 1,
                    font: "Comic Sans MS",
                    isBold: true
                },
                behavior: {
                    ordering: "vertical",
                    extraParticleMode: "magneticField",
                    radius: 0.9
                }
            },

            electroNight: {
                particles: {
                    appearance: {
                        size: {
                            base: 3,
                            variation: 12
                        },
                        colors: COLOR_PRESETS.electroNight,
                        glow: {
                            intensity: 2.0,
                            size: 3.0
                        }
                    },
                    physics: {
                        acceleration: {
                            base: 4,
                            variation: 3
                        }
                    }
                },
                text: {
                    size: 55,
                    scale: 0.8,
                    density: 1,
                    font: "Arial Black",
                    isBold: true
                },
                behavior: {
                    ordering: "horizontal", // Glitch effect for electro theme
                    extraParticleMode: "galaxySwirl",
                    radius: 2
                }
            }
        };



        function applyPreset(presetName) {
            let preset = PRESETS[presetName];

            if (!preset && STATE.presets.saved.has(presetName)) {
                preset = STATE.presets.saved.get(presetName);
            }

            // If still no preset found, return
            if (!preset) {
                console.warn(`No preset found with name: ${presetName}`);
                return;
            }

            console.log(`Applying preset: ${presetName}`, preset);

            const defaultConfig = ConfigSchema.createDefault();

            saveLastUsedConfig(presetName);

            // Set the current config to the selected preset
            STATE.config = deepMerge(defaultConfig, preset);

            // Update all UI elements with the preset values
            document.querySelectorAll('[data-config-path]').forEach(input => {
                const path = input.dataset.configPath.split('.');
                let value = preset;

                // Navigate down the object path
                for (const key of path) {
                    if (value === undefined || value === null) {
                        console.warn(`Invalid path for ${input.dataset.configPath}, missing: ${key}`);
                        return;
                    }
                    value = value[key];
                }

                if (value === undefined || value === null) {
                    console.warn(`No value found for path: ${input.dataset.configPath}`);
                    return;
                }

                // Special handling for color inputs
                if (input.type === 'color') {
                    input.value = rgbToHex(value);
                } else if (input.type === 'select-one') {
                    input.value = value;
                } else if (input.type === 'number') {
                    input.value = value;
                } else if (input.className === 'particleColor') {
                    // Skip individual color pickers as they'll be handled below
                } else {
                    input.value = value;
                }
            });

            const colorPresetSelect = document.getElementById('colorPreset');
            if (preset.particles && preset.particles.appearance && preset.particles.appearance.colors) {
                const colors = preset.particles.appearance.colors;
                const container = colorPresetSelect.parentElement;

                // Try to find if this matches a built-in color preset
                const matchingPreset = Object.entries(COLOR_PRESETS).find(([_, presetColors]) =>
                    JSON.stringify(presetColors) === JSON.stringify(colors)
                );

                if (matchingPreset) {
                    colorPresetSelect.value = matchingPreset[0];
                }

                // Update the actual color pickers
                updateColorPickers(colors, container);
            }

            console.log("Preset applied successfully");
        }

        function deepMerge(target, source) {
            const result = { ...target };

            Object.keys(source).forEach(key => {
                if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                    if (target[key] && typeof target[key] === 'object') {
                        result[key] = deepMerge(target[key], source[key]);
                    } else {
                        result[key] = { ...source[key] };
                    }
                } else {
                    result[key] = source[key];
                }
            });

            return result;
        }

        function rgbToHex(rgbArray) {
            if (!Array.isArray(rgbArray) || rgbArray.length < 3) {
                console.warn("Invalid RGB array:", rgbArray);
                return "#FFFFFF";
            }

            return '#' + rgbArray.map(component => {
                const hex = Math.round(component * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        const StorageUtils = {
            set: function (name, value) {
                try {
                    const serialized = JSON.stringify(value);
                    localStorage.setItem(name, serialized);
                    return true;
                } catch (e) {
                    console.error('Error saving to localStorage:', e);
                    return false;
                }
            },

            get: function (name) {
                try {
                    const serialized = localStorage.getItem(name);
                    if (serialized === null) return null;
                    return JSON.parse(serialized);
                } catch (e) {
                    console.error('Error retrieving from localStorage:', e);
                    return null;
                }
            },

            delete: function (name) {
                localStorage.removeItem(name);
            },

            getAllKeys: function () {
                return Object.keys(localStorage).filter(key =>
                    key.startsWith('particle_timer_preset_'));
            }
        };

        function saveLastUsedConfig(configName) {
            try {
                localStorage.setItem('particle_timer_last_config', configName);
                console.log(`Saved "${configName}" as last used config`);
            } catch (e) {
                console.error('Error saving last used config:', e);
            }
        }

        function loadLastUsedConfig() {
            try {
                const lastConfig = localStorage.getItem('particle_timer_last_config');
                if (lastConfig) {
                    console.log(`Found last used config: "${lastConfig}"`);

                    setTimeout(() => {
                        const presetSelect = document.getElementById('presetStyle');

                        let configExists = false;
                        for (let i = 0; i < presetSelect.options.length; i++) {
                            if (presetSelect.options[i].value === lastConfig) {
                                presetSelect.selectedIndex = i;
                                configExists = true;
                                break;
                            }
                        }

                        if (configExists) {
                            console.log(`Applying last used config: "${lastConfig}"`);
                            applyPreset(lastConfig);
                        } else {
                            console.log(`Last config "${lastConfig}" not found, using default`);
                        }
                    }, 100);
                }
            } catch (e) {
                console.error('Error loading last used config:', e);
            }
        }

        function loadPresets() {
            // Load default presets into state
            Object.entries(PRESETS).forEach(([name, config]) => {
                STATE.presets.saved.set(name, config);
            });

            console.log('Loading saved presets...');

            // Get all preset keys from localStorage
            const presetKeys = StorageUtils.getAllKeys();

            presetKeys.forEach(fullKey => {
                try {
                    const config = StorageUtils.get(fullKey);
                    if (!config) return;

                    // Remove the prefix to get the actual name
                    const name = fullKey.replace('particle_timer_preset_', '');

                    STATE.presets.saved.set(name, config);

                    // Add to preset selector if it doesn't exist
                    const presetSelect = document.getElementById('presetStyle');
                    if (presetSelect && !Array.from(presetSelect.options).some(opt => opt.value === name)) {
                        const opt = document.createElement('option');
                        opt.value = name;
                        opt.textContent = name;
                        presetSelect.appendChild(opt);
                        console.log(`Added ${name} to preset selector`);
                    }

                    console.log(`Successfully loaded saved preset: ${name}`);
                } catch (e) {
                    console.warn('Error loading preset:', fullKey, e);
                }
            });

            console.log('Available presets after loading:', Array.from(STATE.presets.saved.keys()));
        }


        function initializeWithConfig(newConfig, minutes, seconds) {
            Object.assign(STATE.config, newConfig);

            const maxPoints = Math.max(
                getTextPoints(findLargestAreaTime(minutes, seconds), false).realPointsLength,
                getTextPoints(STATE.config.text.endText, false).realPointsLength
            );

            STATE.particles.count = maxPoints;
            STATE.particles.arrays = createParticleArrays(maxPoints);
            STATE.particles.externalForces = new Float32Array(maxPoints * 2);

            initializeParticles(STATE.particles.arrays, 0, maxPoints);
            updateBuffers(STATE.particles.arrays);
        }

        function findLargestAreaTime(minutes, seconds) {
            const digitScores = {};
            for (let i = 0; i <= 9; i++) {
                digitScores[i] = getTextPoints(i.toString(), false).realPointsLength;
            }

            let maxScore = 0;
            let maxAreaTime = null;

            for (let m = minutes; m >= 0; m--) {
                const maxSecs = m === minutes ? seconds : 59;
                const minSecs = m === 0 ? 1 : 0;

                for (let s = maxSecs; s >= minSecs; s--) {
                    const timeDigits = `${m}${s.toString().padStart(2, '0')}`.split('').map(Number);
                    const score = timeDigits.reduce((sum, digit) => sum + digitScores[digit], 0);

                    if (score > maxScore) {
                        maxScore = score;
                        maxAreaTime = `${m}:${s.toString().padStart(2, '0')}`;
                    }
                }
            }

            return maxAreaTime;
        }

        function getConfigFromInputs() {
            const config = ConfigSchema.createDefault();

            document.querySelectorAll('[data-config-path]').forEach(input => {
                const path = input.dataset.configPath.split('.');
                let target = config;

                // Navigate to the correct nested object
                for (let i = 0; i < path.length - 1; i++) {
                    if (!target[path[i]]) {
                        console.warn(`Path segment ${path[i]} not found in config object`);
                        return;
                    }
                    target = target[path[i]];
                }

                const key = path[path.length - 1];
                if (!target.hasOwnProperty(key)) {
                    console.warn(`Key ${key} not found in config object at path ${path.slice(0, -1).join('.')}`);
                    return;
                }

                if (key === 'colors') {
                    target[key] = Array.from(document.querySelectorAll('.particleColor')).map(cp => {
                        const hex = cp.value;
                        return [
                            parseInt(hex.slice(1, 3), 16) / 255,
                            parseInt(hex.slice(3, 5), 16) / 255,
                            parseInt(hex.slice(5, 7), 16) / 255
                        ];
                    });
                } else if (input.type === 'checkbox') {
                    target[key] = input.checked;
                } else if (input.type === 'number') {
                    target[key] = parseFloat(input.value);
                } else {
                    target[key] = input.value;
                }
            });

            return config;
        }


        // Helper functions
        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function twoDigits(n) {
            return (n < 10 ? '0' : '') + n;
        }


        // Initialize WebGL
        function initGL() {
            STATE.render.canvas = document.getElementById('glCanvas');
            STATE.render.gl = STATE.render.canvas.getContext('webgl', {
                antialias: false,
                depth: false,
                alpha: false,
                preserveDrawingBuffer: false
            });

            const gl = STATE.render.gl;

            // Compile shaders
            const vertexShader = compileShader(gl, gl.VERTEX_SHADER,
                document.getElementById('vertex-shader').textContent);
            const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER,
                document.getElementById('fragment-shader').textContent);

            // Create and link program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            STATE.render.program = program;
            STATE.render.uniforms = {
                glowIntensity: gl.getUniformLocation(program, 'u_glow_intensity')
            };
            STATE.render.uniforms.resolution = gl.getUniformLocation(program, 'u_resolution')
            STATE.render.uniforms.glowSize = gl.getUniformLocation(program, 'u_glow_size');

            // Initialize buffers
            STATE.render.buffers.position = gl.createBuffer();
            STATE.render.buffers.size = gl.createBuffer();
            STATE.render.buffers.color = gl.createBuffer();

            // Cache attribute locations
            STATE.render.attributes.position = gl.getAttribLocation(program, 'a_position');
            STATE.render.attributes.size = gl.getAttribLocation(program, 'a_size');
            STATE.render.attributes.color = gl.getAttribLocation(program, 'a_color');

            // Enable attributes
            gl.enableVertexAttribArray(STATE.render.attributes.position);
            gl.enableVertexAttribArray(STATE.render.attributes.size);
            gl.enableVertexAttribArray(STATE.render.attributes.color);

            // Set up vertex attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.position);
            gl.vertexAttribPointer(STATE.render.attributes.position, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.size);
            gl.vertexAttribPointer(STATE.render.attributes.size, 1, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.color);
            gl.vertexAttribPointer(STATE.render.attributes.color, 3, gl.FLOAT, false, 0, 0);

            // Set up blending
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }


        // Optimized particle array creation
        function createParticleArrays(count) {
            return {
                positions: new Float32Array(count * 2),
                velocities: new Float32Array(count * 2),
                setPoints: new Float32Array(count * 2),
                accelerations: new Float32Array(count),
                dampings: new Float32Array(count),
                particleSizes: new Float32Array(count),
                particleColors: new Float32Array(count * 3)
            };
        }

        // Optimized particle initialization
        function initializeParticles(arrays, startIndex, endIndex) {
            const config = STATE.config;
            for (let i = startIndex; i < endIndex; i++) {
                const posIndex = i * 2;
                const colorIndex = i * 3;

                arrays.positions[posIndex] = Math.random() * config.particles.position.spread + config.particles.position.min;
                arrays.positions[posIndex + 1] = Math.random() * config.particles.position.spread + config.particles.position.min;

                arrays.velocities[posIndex] = 0;
                arrays.velocities[posIndex + 1] = 0;

                arrays.setPoints[posIndex] = 0;
                arrays.setPoints[posIndex + 1] = 0;

                arrays.accelerations[i] = Math.max(
                    config.particles.physics.acceleration.base +
                    Math.random() * config.particles.physics.acceleration.variation,
                    0.0001
                );

                arrays.dampings[i]
                config.particles.physics.damping.base +
                    Math.random() * config.particles.physics.damping.variation;

                arrays.particleSizes[i] = config.particles.appearance.size.base +
                    Math.random() * config.particles.appearance.size.variation;

                const randomColor = config.particles.appearance.colors[
                    Math.floor(Math.random() * config.particles.appearance.colors.length)
                ];
                arrays.particleColors[colorIndex] = randomColor[0];
                arrays.particleColors[colorIndex + 1] = randomColor[1];
                arrays.particleColors[colorIndex + 2] = randomColor[2];
            }
        }

        // Optimized buffer updates
        function updateBuffers(arrays) {
            const gl = STATE.render.gl;
            const buffers = STATE.render.buffers;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.positions, gl.DYNAMIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.size);
            gl.bufferData(gl.ARRAY_BUFFER, arrays.particleSizes, gl.STATIC_DRAW);

            const colorArray = new Float32Array(arrays.particleColors);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
            gl.bufferData(gl.ARRAY_BUFFER, colorArray, gl.STATIC_DRAW);
        }


        // Optimized force application and physics
        function applyForces(deltaTime) {
            const mouse = STATE.mouse;
            const particles = STATE.particles;
            const canvas = STATE.render.canvas;

            const mousePixelX = STATE.mouse.x * canvas.width / 2;
            const mousePixelY = STATE.mouse.y * canvas.height / 2;

            const pushForce = STATE.config.particles.mouseBehavior.pushForce ? STATE.config.particles.mouseBehavior.pushForce : 0;
            const pushRadius = STATE.config.particles.mouseBehavior.pushRadius; // In pixels

            if (mouse.down) {
                for (let i = 0; i < particles.count; i++) {
                    const particleX = particles.arrays.positions[i * 2] * canvas.width / 2;
                    const particleY = particles.arrays.positions[i * 2 + 1] * canvas.height / 2;

                    const dx = particleX - mousePixelX;
                    const dy = particleY - mousePixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius) {
                        const normalX = dx / distance;
                        const normalY = dy / distance;

                        // Direct outward force
                        const forceX = normalX * pushForce ** 2;
                        const forceY = normalY * pushForce ** 2;

                        const forceMagnitude = (1 - distance / pushRadius);
                        particles.externalForces[i * 2] = forceX * forceMagnitude / canvas.width;
                        particles.externalForces[i * 2 + 1] = forceY * forceMagnitude / canvas.height;
                    }
                }
            }

            if (STATE.mouse.clicked) {
                for (let i = 0; i < particles.count; i++) {
                    const particleX = particles.arrays.positions[i * 2] * canvas.width / 2;
                    const particleY = particles.arrays.positions[i * 2 + 1] * canvas.height / 2;

                    const dx = particleX - mousePixelX;
                    const dy = particleY - mousePixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius) {
                        const force = (1 - distance / pushRadius) * pushForce;
                        const normalizedDx = dx / canvas.width;
                        const normalizedDy = dy / canvas.height;
                        particles.externalForces[i * 2] = normalizedDx * force;
                        particles.externalForces[i * 2 + 1] = -normalizedDy * force;
                    }
                }
                STATE.mouse.clicked = false;
            }
        }

        function decayForce(force, deltaTime) {
            return Math.abs(force) > 0.01 ? force * Math.exp(-deltaTime * 5) : 0;
        }


        function getTextPoints(text, addExtraPoints = true) {
            const points = getOrderedPoints(text);
            const realPointsLength = points.length;

            if (addExtraPoints) {
                const mode = STATE.config.behavior.extraParticleMode;
                const remainingPoints = STATE.particles.count - points.length;

                if (remainingPoints > 0) {
                    ParticleFunctions.applyToPoints(mode, points, remainingPoints);
                }
            }

            STATE.particles.previousPoints.clear();
            points.forEach((point, index) => {
                const key = `${point.x},${point.y}`;
                STATE.particles.previousPoints.set(key, index);
            });

            return { realPointsLength, points };
        }

        function getOrderedPoints(text) {
            const density = STATE.config.text.density;
            const textSize = STATE.config.text.size;
            const textScale = STATE.config.text.scale;
            const endTextScale = STATE.config.text.endTextScale;
            const selectedFont = STATE.config.text.font;
            const isBold = STATE.config.text.isBold;
            const fontWeight = isBold ? 'bold' : 'normal';
            const verticalOffset = STATE.config.text.verticalOffset || 1.0;

            // Additional vertical scaling factor to make text taller
            const verticalScaleFactor = 1.5;

            const textCanvas = document.createElement('canvas');
            const ctx = textCanvas.getContext('2d');

            // Set font for text measurements
            ctx.font = `${fontWeight} ${textSize}px "${selectedFont}"`;

            const isTimeFormat = /^\d+:\d+$/.test(text);

            // Get text metrics for proper sizing
            const textMetrics = ctx.measureText(text);

            // Calculate canvas dimensions with padding
            let canvasWidth, canvasHeight;

            if (isTimeFormat) {
                // For time format, use a consistent width
                const maxWidth = ctx.measureText("9:99").width;
                canvasWidth = maxWidth * 1.2; // 20% padding
                canvasHeight = textSize * 1.5;
            } else {
                // For end text, use its natural width
                canvasWidth = textMetrics.width * 1.2; // 20% padding
                canvasHeight = textSize * 1.5;
            }

            // Set canvas dimensions
            textCanvas.width = Math.ceil(canvasWidth);
            textCanvas.height = Math.ceil(canvasHeight);

            // Reset context after canvas resize
            ctx.font = `${fontWeight} ${textSize}px "${selectedFont}"`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

            // Generate points from the canvas pixels
            const points = [];
            const imageData = ctx.getImageData(0, 0, textCanvas.width, textCanvas.height).data;

            // Use the appropriate scale based on text type
            const baseScale = isTimeFormat ? textScale : endTextScale;

            // Calculate aspect ratio correction
            const canvasAspect = textCanvas.width / textCanvas.height;

            // Correct the aspect ratio to maintain original text proportions
            let xScale, yScale;

            if (canvasAspect < 1) {
                // Canvas is taller than wide, scale x to compensate
                xScale = baseScale / canvasAspect; // Make x wider
                yScale = baseScale * verticalScaleFactor; // Make y taller by the scale factor
            } else {
                // Canvas is wider than tall, scale y to compensate
                xScale = baseScale;
                yScale = (baseScale / canvasAspect) * verticalScaleFactor; // Make y taller
            }

            // Safe pixel sampling
            function samplePixel(x, y) {
                if (x < 0 || x >= textCanvas.width || y < 0 || y >= textCanvas.height) return 0;
                const index = (y * textCanvas.width + x) * 4 + 3;
                return index >= 0 && index < imageData.length ? imageData[index] : 0;
            }

            switch (STATE.config.behavior.ordering) {
                case 'vertical':
                    for (let x = 0; x < textCanvas.width; x += density) {
                        for (let y = 0; y < textCanvas.height; y += density) {
                            if (samplePixel(x, y) > 128) {
                                points.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * xScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * yScale * verticalOffset
                                });
                            }
                        }
                    }
                    break;

                case 'horizontal':
                    for (let y = 0; y < textCanvas.height; y += density) {
                        for (let x = 0; x < textCanvas.width; x += density) {
                            if (samplePixel(x, y) > 128) {
                                points.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * xScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * yScale * verticalOffset
                                });
                            }
                        }
                    }
                    break;

                case 'optimized':
                    const validPixels = [];
                    for (let x = 0; x < textCanvas.width; x += density) {
                        for (let y = 0; y < textCanvas.height; y += density) {
                            if (samplePixel(x, y) > 128) {
                                validPixels.push({
                                    x: ((x / textCanvas.width) * 2 - 1) * xScale,
                                    y: (-(y / textCanvas.height) * 2 + 1) * yScale * verticalOffset
                                });
                            }
                        }
                    }

                    if (STATE.particles.previousPoints.size === 0) {
                        return validPixels;
                    }

                    const result = new Array(validPixels.length);
                    const usedPoints = new Set();
                    const unassignedIndices = new Set(Array.from({ length: validPixels.length }, (_, i) => i));

                    validPixels.forEach((point, i) => {
                        const key = `${point.x},${point.y}`;
                        const previousIndex = STATE.particles.previousPoints.get(key);

                        if (previousIndex !== undefined && previousIndex < validPixels.length) {
                            result[previousIndex] = point;
                            usedPoints.add(i);
                            unassignedIndices.delete(previousIndex);
                        }
                    });

                    const remainingPoints = validPixels.filter((_, i) => !usedPoints.has(i));
                    Array.from(unassignedIndices).forEach((index, i) => {
                        if (i < remainingPoints.length) {
                            result[index] = remainingPoints[i];
                        }
                    });

                    // Fill any undefined entries with default points
                    for (let i = 0; i < result.length; i++) {
                        if (!result[i]) {
                            result[i] = { x: 0, y: 0 };
                        }
                    }

                    return result;
            }

            return points;
        }

        function togglePause() {
            const pauseButton = document.getElementById('pauseButton');

            if (TIMER.paused) {
                // Resume timer
                TIMER.resume();
                STATE.timer.paused = false;
                pauseButton.classList.remove('play');
                pauseButton.classList.add('pause');

                // Resume animation
                STATE.timer.lastTime = performance.now() * 0.001;
                requestAnimationFrame(draw);
            } else {
                // Pause timer
                TIMER.pause();
                STATE.timer.paused = true;
                pauseButton.classList.remove('pause');
                pauseButton.classList.add('play');
            }
        }

        // Optimized rendering loop
        function draw(currentTime) {
            if (!STATE.timer.running) return;
            if (STATE.timer.paused) return;

            const drawStart = performance.now();
            currentTime *= 0.001;
            const deltaTime = Math.min(currentTime - STATE.timer.lastTime, 0.1);
            STATE.timer.lastTime = currentTime;

            const physicsStart = performance.now();
            const BATCH_SIZE = 1000;
            const particles = STATE.particles;
            const arrays = particles.arrays;
            const dampingRate = deltaTime * deltaTime;

            applyForces(deltaTime);

            for (let start = 0; start < particles.count; start += BATCH_SIZE) {
                const end = Math.min(start + BATCH_SIZE, particles.count);
                processParticleBatch(start, end, arrays, dampingRate, deltaTime);
            }

            STATE.stats.physicsTime = performance.now() - physicsStart;

            if (STATE.particles.activeCount < STATE.particles.count && !STATE.config.behavior.tickSyncRendering) {
                const mode = STATE.config.behavior.extraParticleMode;
                const points = [];
                const remainingPoints = STATE.particles.count - STATE.particles.activeCount;

                ParticleFunctions.applyToPoints(mode, points, remainingPoints);

                for (let i = STATE.particles.activeCount; i < STATE.particles.count; i++) {
                    const arrayIndex = i * 2;
                    const pointIndex = i - STATE.particles.activeCount;

                    if (points[pointIndex]) {
                        STATE.particles.arrays.setPoints[arrayIndex] = points[pointIndex].x;
                        STATE.particles.arrays.setPoints[arrayIndex + 1] = points[pointIndex].y;
                    }
                }
            }

            updateBuffers(arrays);
            render();

            STATE.stats.drawTime = performance.now() - drawStart;
            STATE.stats.frameCount++;

            if (currentTime - STATE.stats.lastFpsTime >= 1.0) {
                STATE.stats.fps = STATE.stats.frameCount;
                STATE.stats.frameCount = 0;
                STATE.stats.lastFpsTime = currentTime;
                STATE.stats.particleCount = particles.count;

                // Update stats display
                STATE.stats.element.textContent = `
                FPS: ${STATE.stats.fps}
                Particles: ${STATE.stats.particleCount}
                Draw Time: ${STATE.stats.drawTime.toFixed(2)}ms
                Physics Time: ${STATE.stats.physicsTime.toFixed(2)}ms
            `;
            }

            requestAnimationFrame(draw);
        }

        function processParticleBatch(start, end, arrays, dampingRate, deltaTime) {
            const particles = STATE.particles;
            for (let i = start; i < end; i++) {
                const idx = i * 2;
                const dx = arrays.setPoints[idx] - arrays.positions[idx];
                const dy = arrays.setPoints[idx + 1] - arrays.positions[idx + 1];

                arrays.velocities[idx] = arrays.velocities[idx] * arrays.dampings[i] * dampingRate +
                    dx * arrays.accelerations[i] + particles.externalForces[idx];
                arrays.velocities[idx + 1] = arrays.velocities[idx + 1] * arrays.dampings[i] * dampingRate +
                    dy * arrays.accelerations[i] + particles.externalForces[idx + 1];

                arrays.positions[idx] += arrays.velocities[idx] * deltaTime;
                arrays.positions[idx + 1] += arrays.velocities[idx + 1] * deltaTime;

                particles.externalForces[idx] = decayForce(particles.externalForces[idx], deltaTime);
                particles.externalForces[idx + 1] = decayForce(particles.externalForces[idx + 1], deltaTime);
            }
        }


        function render() {
            const gl = STATE.render.gl;

            gl.uniform2f(STATE.render.uniforms.resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(STATE.render.uniforms.glowIntensity, STATE.config.particles.appearance.glow.intensity);
            gl.uniform1f(STATE.render.uniforms.glowSize, STATE.config.particles.appearance.glow.size);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, STATE.render.buffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, STATE.particles.arrays.positions, gl.DYNAMIC_DRAW);

            if (STATE.particles.activeCount < STATE.particles.count) {
                gl.drawArrays(gl.POINTS, STATE.particles.activeCount, STATE.particles.count - STATE.particles.activeCount);
                gl.drawArrays(gl.POINTS, 0, STATE.particles.activeCount);
            } else {
                gl.drawArrays(gl.POINTS, 0, STATE.particles.activeCount);
            }
        }

        function cleanup() {
            const gl = STATE.render.gl;
            gl.deleteBuffer(STATE.render.buffers.position);
            gl.deleteBuffer(STATE.render.buffers.size);
            gl.deleteBuffer(STATE.render.buffers.color);
            gl.deleteProgram(STATE.render.program);
            initGL();
        }

        const TIMER = {
            endTime: 0,
            startTime: 0,
            msLeft: 0,
            isFirstTick: true,
            text: "",
            pauseTime: 0,
            timeoutId: null,
            paused: false,

            update() {
                if (this.paused) return;

                this.msLeft = this.endTime - (+new Date);
                const secondsLeft = Math.floor(this.msLeft / 1000);

                const secondsChanged = (this.previousSecondsLeft === undefined ||
                    secondsLeft !== this.previousSecondsLeft);

                if (secondsLeft <= 10 && secondsLeft >= 1) {
                    document.getElementById('tickSound').play();
                }

                if (this.msLeft < 1000) {
                    document.getElementById('timerComplete').play();
                    this.text = STATE.config.text.endText;
                } else {
                    const time = new Date(this.msLeft);
                    const mins = time.getUTCMinutes();
                    this.text = `${mins}:${twoDigits(time.getUTCSeconds())}`;
                    const delay = this.isFirstTick ? 1400 : 1000;
                    this.isFirstTick = false;
                    clearTimeout(this.timeoutId);
                    this.timeoutId = setTimeout(() => this.update(), delay);
                }

                const { realPointsLength, points } = getTextPoints(this.text, true);
                STATE.particles.activeCount = realPointsLength;

                if (secondsChanged || this.isFirstTick) {
                    this.lastPositionUpdate = performance.now();

                    for (let i = 0; i < STATE.particles.count; i++) {
                        STATE.particles.arrays.setPoints[i * 2] = points[i].x;
                        STATE.particles.arrays.setPoints[i * 2 + 1] = points[i].y;
                    }
                }
            },

            start(minutes, seconds) {
                this.endTime = (+new Date) + ((minutes * 60 + seconds) * 1000);
                this.startTime = (+new Date);
                this.isFirstTick = true;
                this.paused = false;
                STATE.timer.paused = false;
                this.update();
            },

            pause() {
                if (this.paused) return;

                this.paused = true;
                this.pauseTime = +new Date;

                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = null;
                }
            },

            resume() {
                if (!this.paused) return;

                const pauseDuration = (+new Date) - this.pauseTime;
                this.endTime += pauseDuration;

                this.paused = false;
                this.update();
            }
        };


        function setTime(minutes) {
            document.getElementById('minutes').value = minutes;
            document.getElementById('seconds').value = 0;

            initializeWithConfig(getConfigFromInputs(), minutes, 0);
            TIMER.start(minutes, 0);

            STATE.timer.paused = false;
            TIMER.paused = false;

            // Update button appearance
            const pauseButton = document.getElementById('pauseButton');
            pauseButton.classList.remove('play');
            pauseButton.classList.add('pause');
            pauseButton.style.display = 'flex'; // Use flex to center the icon

            STATE.menu.visible = false;
            document.getElementById('menu').style.display = 'none';
            STATE.timer.running = true;
            requestAnimationFrame(draw);
        }

        // Optimized initialization
        function init() {
            initGL();
            optimizedResize();
            STATE.canvas.rect = STATE.render.canvas.getBoundingClientRect();
            initUI();
            loadSavedFunctions();
            setupEventListeners();
            loadPresets();
            STATE.config = ConfigSchema.createDefault();

            loadLastUsedConfig();

            STATE.stats.element = document.createElement('div');
            Object.assign(STATE.stats.element.style, {
                position: 'fixed',
                width: '100vw',
                height: '100vh',
                margin: '0',
                padding: '20px',
                zIndex: '100',
                overflow: 'hidden'
            });
            document.body.appendChild(STATE.stats.element);

            const initialCode = ParticleFunctions.registry[document.getElementById('particleFunctionSelect').value];
            document.getElementById('particleFunctionEditor').value = formatCode(initialCode);
        }

        function loadSavedFunctions() {
            // Get all keys that start with particle_function_
            const functionKeys = Object.keys(localStorage).filter(key =>
                key.startsWith('particle_function_'));

            // Load each saved function
            functionKeys.forEach(key => {
                const functionName = key.replace('particle_function_', '');
                const functionBody = localStorage.getItem(key);

                if (functionBody) {
                    ParticleFunctions.register(functionName, functionBody);

                    // Add to the select dropdown if not already there
                    const select = document.getElementById('particleFunctionSelect');
                    if (!Array.from(select.options).some(opt => opt.value === functionName)) {
                        const option = document.createElement('option');
                        option.value = functionName;
                        option.textContent = functionName;
                        select.appendChild(option);
                    }

                    // Add to the behavior dropdown if not already there
                    const behaviorSelect = document.getElementById('behavior_extraParticleMode');
                    if (!Array.from(behaviorSelect.options).some(opt => opt.value === functionName)) {
                        const option = document.createElement('option');
                        option.value = functionName;
                        option.textContent = functionName;
                        behaviorSelect.appendChild(option);
                    }
                }
            });
        }

        function initUI() {
            const menu = document.getElementById('menu');

            // Add timer controls section
            const timerSection = document.createElement('div');
            timerSection.className = 'section';
            timerSection.innerHTML = `
                <button id="startTimer" style="padding: 10px 20px; margin-top: 20px;">Start Timer</button>
                <h3>Timer Settings</h3>
                <label>Minutes: <input type="number" id="minutes" min="0" value="1"></label>
                <label>Seconds: <input type="number" id="seconds" min="0" max="59" value="0"></label>
                <div style="margin-top: 10px;">
                    <button style="padding: 10px 20px;" onclick="setTime(5)">5 min</button>
                    <button style="padding: 10px 20px;" onclick="setTime(10)">10 min</button>
                    <button style="padding: 10px 20px;" onclick="setTime(20)">20 min</button>
                </div>
            `;
            menu.appendChild(timerSection);



            // Add preset style section
            const presetSection = document.createElement('div');
            presetSection.className = 'section';
            presetSection.innerHTML = `
                <h3>Particle Style</h3>
                <div style="display: flex; align-items: center; margin-bottom: 10px; max-width: 300px;">
                    <select id="presetStyle" style="width: auto; min-width: 150px; margin-right: 10px;">
                        <!-- Options will be added dynamically -->
                    </select>
                    <button id="deletePreset" style="background: #d44; padding: 5px 10px;">Delete</button>
                </div>
                <div id="presetInfo" style="font-size: 0.8em; font-style: italic; margin-bottom: 10px;">
                    Built-in presets cannot be deleted.
                </div>
            `;

            menu.appendChild(presetSection);
            const presetSelect = document.getElementById('presetStyle');


            const particleFunctionSection = document.createElement('div');
            particleFunctionSection.className = 'section';
            particleFunctionSection.innerHTML = `
                <h3>Particle Function Editor</h3>
                <p style="font-size: 0.8em;">
                    Define how particles are positioned using JavaScript. Available variables:
                    <br>- angle: 0 to 2π for each particle
                    <br>- index: particle index
                    <br>- total: total particle count 
                    <br>- radius: configured radius
                    <br>- aspectRatio: screen aspect ratio
                    <br>- time: elapsed time in seconds
                    <br>- timer: timer object with progress information
                </p>
                <div style="display: flex; margin-bottom: 10px;">
                    <select id="particleFunctionSelect" style="flex: 2; margin-right: 10px;">
                        ${Object.keys(ParticleFunctions.registry).map(name =>
                `<option value="${name}">${name}</option>`
            ).join('')}
                    </select>
                    <input type="text" id="newFunctionName" placeholder="New function name" style="flex: 1;">
                    <button id="saveAsNewFunction" style="margin-left: 10px;">Save As New</button>
                </div>
                <textarea id="particleFunctionEditor" style="width: 100%; height: 150px; background: #333; color: white; font-family: monospace; padding: 10px; tab-size: 2; white-space: pre; overflow: auto;"></textarea>
                <div style="margin-top: 10px; display: flex; justify-content: space-between;">
                    <div>
                        <button id="updateFunction">Update Function</button>
                        <button id="applyFunction">Apply to Timer</button>
                    </div>
                    <div>
                        <button id="formatCode">Format Code</button>
                        <button id="insertTemplate">Insert Template</button>
                    </div>
                </div>
            `;
            menu.appendChild(particleFunctionSection);


            Object.keys(PRESETS).forEach(presetName => {
                const option = document.createElement('option');
                option.value = presetName;

                const displayName = presetName
                    .replace(/([A-Z])/g, ' $1')
                    .replace(/^./, str => str.toUpperCase());

                option.textContent = displayName;
                presetSelect.appendChild(option);
            });


            const saveSection = document.createElement('div');
            saveSection.className = 'section';
            saveSection.innerHTML = `
                <h3>Save Configuration</h3>
                <label>Configuration Name: <input type="text" id="configName"></label>
                <button id="saveConfig">Save</button>
            `;

            menu.appendChild(saveSection);

            ConfigSchema.generateUI(menu);

            const paddingDiv = document.createElement('div');
            paddingDiv.style.paddingBottom = '80px';
            menu.appendChild(paddingDiv);
        }


        // Event handlers
        function setupEventListeners() {
            const canvas = STATE.render.canvas;

            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                STATE.menu.visible = true;
                document.getElementById('menu').style.display = 'block';
                document.getElementById('pauseButton').style.display = 'none';
            });

            document.getElementById('startTimer').addEventListener('click', () => {
                cleanup();
                const minutes = parseInt(document.getElementById('minutes').value);
                const seconds = parseInt(document.getElementById('seconds').value);

                initializeWithConfig(getConfigFromInputs(), minutes, seconds);
                TIMER.start(minutes, seconds);

                // Reset pause state
                STATE.timer.paused = false;
                TIMER.paused = false;

                // Update button appearance
                const pauseButton = document.getElementById('pauseButton');
                pauseButton.classList.remove('play');
                pauseButton.classList.add('pause');
                pauseButton.style.display = 'flex';

                document.getElementById('menu').style.display = 'none';
                STATE.timer.running = true;
                STATE.menu.visible = false;
                requestAnimationFrame(draw);
            });

            document.getElementById('pauseButton').addEventListener('click', togglePause);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    STATE.menu.visible = false;
                    document.getElementById('menu').style.display = 'none';

                    if (STATE.timer.running && !TIMER.msLeft < 1000) {
                        document.getElementById('pauseButton').style.display = 'block';
                    }
                }

            });

            document.getElementById('fullscreenButton').addEventListener('click', () => {
                window.open('https://htmlpreview.github.io/?https://github.com/lexm2/particle-timer/blob/main/shadersOptimized.html', '_blank');
            });


            document.getElementById('colorPreset').addEventListener('change', (e) => {
                const colors = COLOR_PRESETS[e.target.value];
                const container = e.target.parentElement;
                updateColorPickers(colors, container);
                STATE.config.particles.appearance.colors = colors;
            });

            window.addEventListener('resize', optimizedResize);

            canvas.addEventListener('mousedown', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.down = true;
            });

            canvas.addEventListener('mouseup', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.down = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (STATE.menu.visible) return;
                const newMouseX = (e.clientX - STATE.canvas.rect.left) / STATE.canvas.rect.width * 2 - 1;
                const newMouseY = -((e.clientY - STATE.canvas.rect.top) / STATE.canvas.rect.height * 2 - 1);

                if (STATE.mouse.down) {
                    STATE.mouse.velocityX = newMouseX - STATE.mouse.x;
                    STATE.mouse.velocityY = newMouseY - STATE.mouse.y;
                }

                STATE.mouse.x = newMouseX;
                STATE.mouse.y = newMouseY;
            });

            canvas.addEventListener('click', (e) => {
                if (STATE.menu.visible) return;
                STATE.mouse.clicked = true;
            });

            document.getElementById('presetStyle').addEventListener('change', (e) => {
                const presetName = e.target.value;

                applyPreset(presetName);
                const preset = PRESETS[presetName] || STATE.presets.saved.get(presetName);

                if (preset && preset.behavior && preset.behavior.extraParticleMode) {
                    const functionSelect = document.getElementById('particleFunctionSelect');
                    if (Array.from(functionSelect.options).some(opt => opt.value === preset.behavior.extraParticleMode)) {
                        functionSelect.value = preset.behavior.extraParticleMode;
                        document.getElementById('particleFunctionEditor').value =
                            formatCode(ParticleFunctions.registry[preset.behavior.extraParticleMode]);
                    }
                }
            });

            document.getElementById('deletePreset').addEventListener('click', () => {
                const presetSelect = document.getElementById('presetStyle');
                const selectedPreset = presetSelect.value;

                if (Object.keys(PRESETS).includes(selectedPreset)) {
                    alert('Cannot delete built-in presets.');
                    return;
                }

                if (confirm(`Are you sure you want to delete the preset "${selectedPreset}"?`)) {
                    localStorage.removeItem('particle_timer_preset_' + selectedPreset);

                    STATE.presets.saved.delete(selectedPreset);

                    for (let i = 0; i < presetSelect.options.length; i++) {
                        if (presetSelect.options[i].value === selectedPreset) {
                            presetSelect.remove(i);
                            break;
                        }
                    }

                    presetSelect.selectedIndex = 0;
                    applyPreset(presetSelect.value);

                    console.log(`Deleted preset: ${selectedPreset}`);
                }
            });

            document.getElementById('saveConfig').addEventListener('click', () => {
                const configName = document.getElementById('configName').value;
                if (!configName) {
                    alert('Please enter a configuration name');
                    return;
                }

                const config = getConfigFromInputs();
                const storageName = 'particle_timer_preset_' + configName;

                saveLastUsedConfig(configName);

                STATE.presets.saved.set(configName, config);

                if (StorageUtils.set(storageName, config)) {
                    console.log(`Configuration "${configName}" saved successfully`);
                    // Optional: Show feedback to user
                    alert(`Configuration "${configName}" saved successfully`);
                } else {
                    alert('Failed to save configuration');
                }

                loadPresets();
                document.getElementById('configName').value = '';
            });

            const fontSelect = document.getElementById('text_font');
            if (fontSelect) {
                fontSelect.addEventListener('change', function () {
                    const fontPath = this.dataset.configPath;
                    const pathParts = fontPath.split('.');
                    let target = STATE.config;

                    for (let i = 0; i < pathParts.length - 1; i++) {
                        target = target[pathParts[i]];
                    }

                    target[pathParts[pathParts.length - 1]] = this.value;

                    if (STATE.timer.running) {
                        TIMER.update();
                    }
                });
            }

            const boldToggle = document.getElementById('text_isBold');
            if (boldToggle) {
                boldToggle.addEventListener('change', function () {
                    STATE.config.text.isBold = this.checked;
                    if (STATE.timer.running) {
                        TIMER.update();
                    }
                });
            }

            document.getElementById('particleFunctionSelect').addEventListener('change', function () {
                const functionName = this.value;
                let code = ParticleFunctions.registry[functionName];
                code = formatCode(code);

                document.getElementById('behavior_extraParticleMode').value = functionName;
                STATE.config.behavior.extraParticleMode = functionName;

                document.getElementById('particleFunctionEditor').value = code;
            });


            document.getElementById('updateFunction').addEventListener('click', function () {
                const functionName = document.getElementById('particleFunctionSelect').value;

                if (ParticleFunctions.builtInFunctions.has(functionName)) {
                    alert(`"${functionName}" is a built-in function and cannot be modified. Please save your changes as a new function instead.`);
                    return;
                }

                // Rest of your update code...
                let functionBody = document.getElementById('particleFunctionEditor').value;
                functionBody = trimCodeWhitespace(functionBody);

                ParticleFunctions.register(functionName, functionBody);
                localStorage.setItem(`particle_function_${functionName}`, functionBody);

                if (STATE.timer.running) {
                    TIMER.update();
                }

                const button = this;
                const originalText = button.textContent;
                button.textContent = "Updated!";
                setTimeout(() => { button.textContent = originalText; }, 1000);
            });

            document.getElementById('saveAsNewFunction').addEventListener('click', function () {
                const newName = document.getElementById('newFunctionName').value.trim();
                if (!newName) {
                    alert("Please enter a name for the new function");
                    return;
                }

                let functionBody = document.getElementById('particleFunctionEditor').value;

                // Trim leading whitespace while preserving indentation structure
                functionBody = trimCodeWhitespace(functionBody);

                // Register the new function
                ParticleFunctions.register(newName, functionBody);

                // Save to localStorage
                localStorage.setItem(`particle_function_${newName}`, functionBody);

                // Update the select dropdown
                const option = document.createElement('option');
                option.value = newName;
                option.textContent = newName;
                document.getElementById('particleFunctionSelect').appendChild(option);
                document.getElementById('particleFunctionSelect').value = newName;

                // Update the behavior dropdown
                const behaviorSelect = document.getElementById('behavior_extraParticleMode');
                const newOption = document.createElement('option');
                newOption.value = newName;
                newOption.textContent = newName;
                behaviorSelect.appendChild(newOption);

                // Clear the name field
                document.getElementById('newFunctionName').value = '';

                // If timer is running, update display
                if (STATE.timer.running) {
                    TIMER.update();
                }
            });

            document.getElementById('formatCode').addEventListener('click', function () {
                const editor = document.getElementById('particleFunctionEditor');
                let code = editor.value;

                // Basic code formatting
                code = formatCode(code);

                editor.value = code;
            });

            document.getElementById('insertTemplate').addEventListener('click', function () {
                const template = `// Basic particle positioning template
                // Use angle, index, radius, and other variables to position particles
                // Return {x, y} coordinates for each particle

                const adjustedRadius = radius * (1 + 0.2 * Math.sin(time));

                return {
                x: Math.cos(angle) * adjustedRadius,
                y: Math.sin(angle) * adjustedRadius * aspectRatio
                };`;

                document.getElementById('particleFunctionEditor').value = template;
            });

            document.getElementById('applyFunction').addEventListener('click', function () {
                const functionName = document.getElementById('particleFunctionSelect').value;
                document.getElementById('behavior_extraParticleMode').value = functionName;
                STATE.config.behavior.extraParticleMode = functionName;

                if (STATE.timer.running) {
                    TIMER.update();
                }
            });

            // Initialize the function editor with the first function
            document.getElementById('particleFunctionEditor').value =
                ParticleFunctions.registry[document.getElementById('particleFunctionSelect').value];
        }

        function trimCodeWhitespace(code) {
            // Detect leading whitespace in the first non-empty line
            const lines = code.split('\n');
            let minIndent = Infinity;
            let firstNonEmptyLine = -1;

            // Find the common indentation level
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.trim() === '') continue;

                if (firstNonEmptyLine === -1) firstNonEmptyLine = i;

                const indent = line.match(/^[ \t]*/)[0].length;
                if (indent < minIndent) minIndent = indent;
            }

            // If we couldn't detect indentation, return the original code
            if (minIndent === Infinity || firstNonEmptyLine === -1) return code;

            // Remove the common indentation from all lines
            return lines.map(line => {
                if (line.trim() === '') return '';
                return line.substring(minIndent);
            }).join('\n');
        }

        function formatCode(code) {
            // Trim leading/trailing whitespace
            code = code.trim();

            // First, remove any common indentation
            code = trimCodeWhitespace(code);

            // Basic formatting for brackets, add newlines and indentation
            let formatted = '';
            let indent = 0;
            const lines = code.split('\n');

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();

                // Handle closing braces by reducing indent before adding them
                if (line.match(/^[}\])]/) && indent > 0) {
                    indent--;
                }

                // Add proper indentation
                if (line !== '') {
                    formatted += '  '.repeat(indent) + line + '\n';
                } else {
                    formatted += '\n';
                }

                // Count opening and closing braces to adjust indentation
                const openBraces = (line.match(/{|\[|\(/g) || []).length;
                const closeBraces = (line.match(/}|\]|\)/g) || []).length;

                // Special handling for lines that both open and close on the same line
                // but have a net opening count (e.g., "if (x) {")
                if (openBraces > closeBraces) {
                    indent++;
                }
            }

            return formatted;
        }


        function optimizedResize() {
            const pixelRatio = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;

            STATE.render.canvas.width = width * pixelRatio;
            STATE.render.canvas.height = height * pixelRatio;
            STATE.render.canvas.style.width = width + 'px';
            STATE.render.canvas.style.height = height + 'px';

            STATE.render.gl.viewport(0, 0, STATE.render.canvas.width, STATE.render.canvas.height);
            STATE.canvas.aspectRatio = STATE.render.canvas.width / STATE.render.canvas.height;
            STATE.canvas.rect = STATE.render.canvas.getBoundingClientRect();
        }

        init();

    </script>
</body>

</html>